<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pdoc.markdown2 API documentation</title>
<meta name="description" content="A fast and complete Python implementation of Markdown â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pdoc.markdown2</code></h1>
</header>
<section id="section-intro">
<p>A fast and complete Python implementation of Markdown.</p>
<p>[from <a href="http://daringfireball.net/projects/markdown/]">http://daringfireball.net/projects/markdown/]</a></p>
<blockquote>
<p>Markdown is a text-to-HTML filter; it translates an easy-to-read /
easy-to-write structured text format into HTML.
Markdown's text
format is most similar to that of plain text email, and supports
features such as headers, <em>emphasis</em>, code blocks, blockquotes, and
links.</p>
<p>Markdown's syntax is designed not as a generic markup language, but
specifically to serve as a front-end to (X)HTML. You can use span-level
HTML tags anywhere in a Markdown document, and you can use block level
HTML tags (like <div> and <table> as well).</p>
</blockquote>
<p>Module usage:</p>
<pre><code>&gt;&gt;&gt; import markdown2
&gt;&gt;&gt; markdown2.markdown("*boo!*")  # or use `html = markdown_path(PATH)`
u'&lt;p&gt;&lt;em&gt;boo!&lt;/em&gt;&lt;/p&gt;\n'

&gt;&gt;&gt; markdowner = Markdown()
&gt;&gt;&gt; markdowner.convert("*boo!*")
u'&lt;p&gt;&lt;em&gt;boo!&lt;/em&gt;&lt;/p&gt;\n'
&gt;&gt;&gt; markdowner.convert("**boom!**")
u'&lt;p&gt;&lt;strong&gt;boom!&lt;/strong&gt;&lt;/p&gt;\n'
</code></pre>
<p>This implementation of Markdown implements the full "core" syntax plus a
number of extras (e.g., code syntax coloring, footnotes) as described on
<a href="https://github.com/trentm/python-markdown2/wiki/Extras">https://github.com/trentm/python-markdown2/wiki/Extras</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># fmt: off
# flake8: noqa
# type: ignore
# Taken from here: https://github.com/trentm/python-markdown2/blob/bce3f18ed86a19b418c8114a712bb6fee790c4c2/lib/markdown2.py

#!/usr/bin/env python
# Copyright (c) 2012 Trent Mick.
# Copyright (c) 2007-2008 ActiveState Corp.
# License: MIT (http://www.opensource.org/licenses/mit-license.php)

r&#34;&#34;&#34;A fast and complete Python implementation of Markdown.

[from http://daringfireball.net/projects/markdown/]
&gt; Markdown is a text-to-HTML filter; it translates an easy-to-read /
&gt; easy-to-write structured text format into HTML.  Markdown&#39;s text
&gt; format is most similar to that of plain text email, and supports
&gt; features such as headers, *emphasis*, code blocks, blockquotes, and
&gt; links.
&gt;
&gt; Markdown&#39;s syntax is designed not as a generic markup language, but
&gt; specifically to serve as a front-end to (X)HTML. You can use span-level
&gt; HTML tags anywhere in a Markdown document, and you can use block level
&gt; HTML tags (like &lt;div&gt; and &lt;table&gt; as well).

Module usage:

    &gt;&gt;&gt; import markdown2
    &gt;&gt;&gt; markdown2.markdown(&#34;*boo!*&#34;)  # or use `html = markdown_path(PATH)`
    u&#39;&lt;p&gt;&lt;em&gt;boo!&lt;/em&gt;&lt;/p&gt;\n&#39;

    &gt;&gt;&gt; markdowner = Markdown()
    &gt;&gt;&gt; markdowner.convert(&#34;*boo!*&#34;)
    u&#39;&lt;p&gt;&lt;em&gt;boo!&lt;/em&gt;&lt;/p&gt;\n&#39;
    &gt;&gt;&gt; markdowner.convert(&#34;**boom!**&#34;)
    u&#39;&lt;p&gt;&lt;strong&gt;boom!&lt;/strong&gt;&lt;/p&gt;\n&#39;

This implementation of Markdown implements the full &#34;core&#34; syntax plus a
number of extras (e.g., code syntax coloring, footnotes) as described on
&lt;https://github.com/trentm/python-markdown2/wiki/Extras&gt;.
&#34;&#34;&#34;

cmdln_desc = &#34;&#34;&#34;A fast and complete Python implementation of Markdown, a
text-to-HTML conversion tool for web writers.

Supported extra syntax options (see -x|--extras option below and
see &lt;https://github.com/trentm/python-markdown2/wiki/Extras&gt; for details):

* admonitions: Enable parsing of RST admonitions.
* break-on-newline: Replace single new line characters with &lt;br&gt; when True
* code-friendly: Disable _ and __ for em and strong.
* cuddled-lists: Allow lists to be cuddled to the preceding paragraph.
* fenced-code-blocks: Allows a code block to not have to be indented
  by fencing it with &#39;```&#39; on a line before and after. Based on
  &lt;http://github.github.com/github-flavored-markdown/&gt; with support for
  syntax highlighting.
* footnotes: Support footnotes as in use on daringfireball.net and
  implemented in other Markdown processors (tho not in Markdown.pl v1.0.1).
* header-ids: Adds &#34;id&#34; attributes to headers. The id value is a slug of
  the header text.
* highlightjs-lang: Allows specifying the language which used for syntax
  highlighting when using fenced-code-blocks and highlightjs.
* html-classes: Takes a dict mapping html tag names (lowercase) to a
  string to use for a &#34;class&#34; tag attribute. Currently only supports &#34;img&#34;,
  &#34;table&#34;, &#34;thead&#34;, &#34;pre&#34;, &#34;code&#34;, &#34;ul&#34; and &#34;ol&#34; tags. Add an issue if you require
  this for other tags.
* link-patterns: Auto-link given regex patterns in text (e.g. bug number
  references, revision number references).
* markdown-in-html: Allow the use of `markdown=&#34;1&#34;` in a block HTML tag to
  have markdown processing be done on its contents. Similar to
  &lt;http://michelf.com/projects/php-markdown/extra/#markdown-attr&gt; but with
  some limitations.
* metadata: Extract metadata from a leading &#39;---&#39;-fenced block.
  See &lt;https://github.com/trentm/python-markdown2/issues/77&gt; for details.
* nofollow: Add `rel=&#34;nofollow&#34;` to add `&lt;a&gt;` tags with an href. See
  &lt;http://en.wikipedia.org/wiki/Nofollow&gt;.
* numbering: Support of generic counters.  Non standard extension to
  allow sequential numbering of figures, tables, equations, exhibits etc.
* pyshell: Treats unindented Python interactive shell sessions as &lt;code&gt;
  blocks.
* smarty-pants: Replaces &#39; and &#34; with curly quotation marks or curly
  apostrophes.  Replaces --, ---, ..., and . . . with en dashes, em dashes,
  and ellipses.
* spoiler: A special kind of blockquote commonly hidden behind a
  click on SO. Syntax per &lt;http://meta.stackexchange.com/a/72878&gt;.
* strike: text inside of double tilde is ~~strikethrough~~
* tag-friendly: Requires atx style headers to have a space between the # and
  the header text. Useful for applications that require twitter style tags to
  pass through the parser.
* tables: Tables using the same format as GFM
  &lt;https://help.github.com/articles/github-flavored-markdown#tables&gt; and
  PHP-Markdown Extra &lt;https://michelf.ca/projects/php-markdown/extra/#table&gt;.
* toc: The returned HTML string gets a new &#34;toc_html&#34; attribute which is
  a Table of Contents for the document. (experimental)
* use-file-vars: Look for an Emacs-style markdown-extras file variable to turn
  on Extras.
* wiki-tables: Google Code Wiki-style tables. See
  &lt;http://code.google.com/p/support/wiki/WikiSyntax#Tables&gt;.
* wavedrom: Support for generating Wavedrom digital timing diagrams
* xml: Passes one-liner processing instructions and namespaced XML tags.
&#34;&#34;&#34;

# Dev Notes:
# - Python&#39;s regex syntax doesn&#39;t have &#39;\z&#39;, so I&#39;m using &#39;\Z&#39;. I&#39;m
#   not yet sure if there implications with this. Compare &#39;pydoc sre&#39;
#   and &#39;perldoc perlre&#39;.

__version_info__ = (2, 4, 9)
__version__ = &#39;.&#39;.join(map(str, __version_info__))
__author__ = &#34;Trent Mick&#34;

import argparse
import codecs
import logging
import re
import sys
from collections import defaultdict
from hashlib import sha256
from random import randint, random

# ---- globals

DEBUG = False
log = logging.getLogger(&#34;markdown&#34;)

DEFAULT_TAB_WIDTH = 4


SECRET_SALT = bytes(randint(0, 1000000))
# MD5 function was previously used for this; the &#34;md5&#34; prefix was kept for
# backwards compatibility.
def _hash_text(s):
    return &#39;md5-&#39; + sha256(SECRET_SALT + s.encode(&#34;utf-8&#34;)).hexdigest()[32:]

# Table of hash values for escaped characters:
g_escape_table = dict([(ch, _hash_text(ch))
    for ch in &#39;\\`*_{}[]()&gt;#+-.!&#39;])

# Ampersand-encoding based entirely on Nat Irons&#39;s Amputator MT plugin:
#   http://bumppo.net/projects/amputator/
_AMPERSAND_RE = re.compile(r&#39;&amp;(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)&#39;)


# ---- exceptions
class MarkdownError(Exception):
    pass


# ---- public api

def markdown_path(path, encoding=&#34;utf-8&#34;,
                  html4tags=False, tab_width=DEFAULT_TAB_WIDTH,
                  safe_mode=None, extras=None, link_patterns=None,
                  footnote_title=None, footnote_return_symbol=None,
                  use_file_vars=False):
    fp = codecs.open(path, &#39;r&#39;, encoding)
    text = fp.read()
    fp.close()
    return Markdown(html4tags=html4tags, tab_width=tab_width,
                    safe_mode=safe_mode, extras=extras,
                    link_patterns=link_patterns,
                    footnote_title=footnote_title,
                    footnote_return_symbol=footnote_return_symbol,
                    use_file_vars=use_file_vars).convert(text)


def markdown(text, html4tags=False, tab_width=DEFAULT_TAB_WIDTH,
             safe_mode=None, extras=None, link_patterns=None,
             footnote_title=None, footnote_return_symbol=None,
             use_file_vars=False, cli=False):
    return Markdown(html4tags=html4tags, tab_width=tab_width,
                    safe_mode=safe_mode, extras=extras,
                    link_patterns=link_patterns,
                    footnote_title=footnote_title,
                    footnote_return_symbol=footnote_return_symbol,
                    use_file_vars=use_file_vars, cli=cli).convert(text)


class Markdown(object):
    # The dict of &#34;extras&#34; to enable in processing -- a mapping of
    # extra name to argument for the extra. Most extras do not have an
    # argument, in which case the value is None.
    #
    # This can be set via (a) subclassing and (b) the constructor
    # &#34;extras&#34; argument.
    extras = None

    urls = None
    titles = None
    html_blocks = None
    html_spans = None
    html_removed_text = &#34;{(#HTML#)}&#34;  # placeholder removed text that does not trigger bold
    html_removed_text_compat = &#34;[HTML_REMOVED]&#34;  # for compat with markdown.py

    _toc = None

    # Used to track when we&#39;re inside an ordered or unordered list
    # (see _ProcessListItems() for details):
    list_level = 0

    _ws_only_line_re = re.compile(r&#34;^[ \t]+$&#34;, re.M)

    def __init__(self, html4tags=False, tab_width=4, safe_mode=None,
                 extras=None, link_patterns=None,
                 footnote_title=None, footnote_return_symbol=None,
                 use_file_vars=False, cli=False):
        if html4tags:
            self.empty_element_suffix = &#34;&gt;&#34;
        else:
            self.empty_element_suffix = &#34; /&gt;&#34;
        self.tab_width = tab_width
        self.tab = tab_width * &#34; &#34;

        # For compatibility with earlier markdown2.py and with
        # markdown.py&#39;s safe_mode being a boolean,
        #   safe_mode == True -&gt; &#34;replace&#34;
        if safe_mode is True:
            self.safe_mode = &#34;replace&#34;
        else:
            self.safe_mode = safe_mode

        # Massaging and building the &#34;extras&#34; info.
        if self.extras is None:
            self.extras = {}
        elif not isinstance(self.extras, dict):
            self.extras = dict([(e, None) for e in self.extras])
        if extras:
            if not isinstance(extras, dict):
                extras = dict([(e, None) for e in extras])
            self.extras.update(extras)
        assert isinstance(self.extras, dict)

        if &#34;toc&#34; in self.extras:
            if &#34;header-ids&#34; not in self.extras:
                self.extras[&#34;header-ids&#34;] = None   # &#34;toc&#34; implies &#34;header-ids&#34;

            if self.extras[&#34;toc&#34;] is None:
                self._toc_depth = 6
            else:
                self._toc_depth = self.extras[&#34;toc&#34;].get(&#34;depth&#34;, 6)
        self._instance_extras = self.extras.copy()

        if &#39;link-patterns&#39; in self.extras:
            if link_patterns is None:
                # if you have specified that the link-patterns extra SHOULD
                # be used (via self.extras) but you haven&#39;t provided anything
                # via the link_patterns argument then an error is raised
                raise MarkdownError(&#34;If the &#39;link-patterns&#39; extra is used, an argument for &#39;link_patterns&#39; is required&#34;)
        self.link_patterns = link_patterns
        self.footnote_title = footnote_title
        self.footnote_return_symbol = footnote_return_symbol
        self.use_file_vars = use_file_vars
        self._outdent_re = re.compile(r&#39;^(\t|[ ]{1,%d})&#39; % tab_width, re.M)
        self.cli = cli

        self._escape_table = g_escape_table.copy()
        self._code_table = {}
        if &#34;smarty-pants&#34; in self.extras:
            self._escape_table[&#39;&#34;&#39;] = _hash_text(&#39;&#34;&#39;)
            self._escape_table[&#34;&#39;&#34;] = _hash_text(&#34;&#39;&#34;)

    def reset(self):
        self.urls = {}
        self.titles = {}
        self.html_blocks = {}
        self.html_spans = {}
        self.list_level = 0
        self.extras = self._instance_extras.copy()
        self._setup_extras()
        self._toc = None

    def _setup_extras(self):
        if &#34;footnotes&#34; in self.extras:
            self.footnotes = {}
            self.footnote_ids = []
        if &#34;header-ids&#34; in self.extras:
            self._count_from_header_id = defaultdict(int)
        if &#34;metadata&#34; in self.extras:
            self.metadata = {}

    # Per &lt;https://developer.mozilla.org/en-US/docs/HTML/Element/a&gt; &#34;rel&#34;
    # should only be used in &lt;a&gt; tags with an &#34;href&#34; attribute.

    # Opens the linked document in a new window or tab
    # should only used in &lt;a&gt; tags with an &#34;href&#34; attribute.
    # same with _a_nofollow
    _a_nofollow_or_blank_links = re.compile(r&#34;&#34;&#34;
        &lt;(a)
        (
            [^&gt;]*
            href=   # href is required
            [&#39;&#34;]?   # HTML5 attribute values do not have to be quoted
            [^#&#39;&#34;]  # We don&#39;t want to match href values that start with # (like footnotes)
        )
        &#34;&#34;&#34;,
        re.IGNORECASE | re.VERBOSE
    )

    def convert(self, text):
        &#34;&#34;&#34;Convert the given text.&#34;&#34;&#34;
        # Main function. The order in which other subs are called here is
        # essential. Link and image substitutions need to happen before
        # _EscapeSpecialChars(), so that any *&#39;s or _&#39;s in the &lt;a&gt;
        # and &lt;img&gt; tags get encoded.

        # Clear the global hashes. If we don&#39;t clear these, you get conflicts
        # from other articles when generating a page which contains more than
        # one article (e.g. an index page that shows the N most recent
        # articles):
        self.reset()

        if not isinstance(text, str):
            # TODO: perhaps shouldn&#39;t presume UTF-8 for string input?
            text = str(text, &#39;utf-8&#39;)

        if self.use_file_vars:
            # Look for emacs-style file variable hints.
            text = self._emacs_oneliner_vars_pat.sub(self._emacs_vars_oneliner_sub, text)
            emacs_vars = self._get_emacs_vars(text)
            if &#34;markdown-extras&#34; in emacs_vars:
                splitter = re.compile(&#34;[ ,]+&#34;)
                for e in splitter.split(emacs_vars[&#34;markdown-extras&#34;]):
                    if &#39;=&#39; in e:
                        ename, earg = e.split(&#39;=&#39;, 1)
                        try:
                            earg = int(earg)
                        except ValueError:
                            pass
                    else:
                        ename, earg = e, None
                    self.extras[ename] = earg

            self._setup_extras()

        # Standardize line endings:
        text = text.replace(&#34;\r\n&#34;, &#34;\n&#34;)
        text = text.replace(&#34;\r&#34;, &#34;\n&#34;)

        # Make sure $text ends with a couple of newlines:
        text += &#34;\n\n&#34;

        # Convert all tabs to spaces.
        text = self._detab(text)

        # Strip any lines consisting only of spaces and tabs.
        # This makes subsequent regexen easier to write, because we can
        # match consecutive blank lines with /\n+/ instead of something
        # contorted like /[ \t]*\n+/ .
        text = self._ws_only_line_re.sub(&#34;&#34;, text)

        # strip metadata from head and extract
        if &#34;metadata&#34; in self.extras:
            text = self._extract_metadata(text)

        text = self.preprocess(text)

        if &#39;wavedrom&#39; in self.extras:
            text = self._do_wavedrom_blocks(text)

        if &#34;fenced-code-blocks&#34; in self.extras and not self.safe_mode:
            text = self._do_fenced_code_blocks(text)

        if self.safe_mode:
            text = self._hash_html_spans(text)

        # Turn block-level HTML blocks into hash entries
        text = self._hash_html_blocks(text, raw=True)

        if &#34;fenced-code-blocks&#34; in self.extras and self.safe_mode:
            text = self._do_fenced_code_blocks(text)

        if &#39;admonitions&#39; in self.extras:
            text = self._do_admonitions(text)

        # Because numbering references aren&#39;t links (yet?) then we can do everything associated with counters
        # before we get started
        if &#34;numbering&#34; in self.extras:
            text = self._do_numbering(text)

        # Strip link definitions, store in hashes.
        if &#34;footnotes&#34; in self.extras:
            # Must do footnotes first because an unlucky footnote defn
            # looks like a link defn:
            #   [^4]: this &#34;looks like a link defn&#34;
            text = self._strip_footnote_definitions(text)
        text = self._strip_link_definitions(text)

        text = self._run_block_gamut(text)

        if &#34;footnotes&#34; in self.extras:
            text = self._add_footnotes(text)

        text = self.postprocess(text)

        text = self._unescape_special_chars(text)

        if self.safe_mode:
            text = self._unhash_html_spans(text)
            # return the removed text warning to its markdown.py compatible form
            text = text.replace(self.html_removed_text, self.html_removed_text_compat)

        do_target_blank_links = &#34;target-blank-links&#34; in self.extras
        do_nofollow_links = &#34;nofollow&#34; in self.extras

        if do_target_blank_links and do_nofollow_links:
            text = self._a_nofollow_or_blank_links.sub(r&#39;&lt;\1 rel=&#34;nofollow noopener&#34; target=&#34;_blank&#34;\2&#39;, text)
        elif do_target_blank_links:
            text = self._a_nofollow_or_blank_links.sub(r&#39;&lt;\1 rel=&#34;noopener&#34; target=&#34;_blank&#34;\2&#39;, text)
        elif do_nofollow_links:
            text = self._a_nofollow_or_blank_links.sub(r&#39;&lt;\1 rel=&#34;nofollow&#34;\2&#39;, text)

        if &#34;toc&#34; in self.extras and self._toc:
            self._toc_html = calculate_toc_html(self._toc)

            # Prepend toc html to output
            if self.cli:
                text = &#39;{}\n{}&#39;.format(self._toc_html, text)

        text += &#34;\n&#34;

        # Attach attrs to output
        rv = UnicodeWithAttrs(text)

        if &#34;toc&#34; in self.extras and self._toc:
            rv.toc_html = self._toc_html

        if &#34;metadata&#34; in self.extras:
            rv.metadata = self.metadata
        return rv

    def postprocess(self, text):
        &#34;&#34;&#34;A hook for subclasses to do some postprocessing of the html, if
        desired. This is called before unescaping of special chars and
        unhashing of raw HTML spans.
        &#34;&#34;&#34;
        return text

    def preprocess(self, text):
        &#34;&#34;&#34;A hook for subclasses to do some preprocessing of the Markdown, if
        desired. This is called after basic formatting of the text, but prior
        to any extras, safe mode, etc. processing.
        &#34;&#34;&#34;
        return text

    # Is metadata if the content starts with optional &#39;---&#39;-fenced `key: value`
    # pairs. E.g. (indented for presentation):
    #   ---
    #   foo: bar
    #   another-var: blah blah
    #   ---
    #   # header
    # or:
    #   foo: bar
    #   another-var: blah blah
    #
    #   # header
    _meta_data_pattern = re.compile(r&#39;&#39;&#39;
        ^{0}(  # optional opening fence
            (?:
                {1}:(?:\n+[ \t]+.*)+  # indented lists
            )|(?:
                (?:{1}:\s+&gt;(?:\n\s+.*)+?)  # multiline long descriptions
                (?=\n{1}:\s*.*\n|\s*\Z)  # match up until the start of the next key:value definition or the end of the input text
            )|(?:
                {1}:(?! &gt;).*\n?  # simple key:value pair, leading spaces allowed
            )
        ){0}  # optional closing fence
        &#39;&#39;&#39;.format(r&#39;(?:---[\ \t]*\n)?&#39;, r&#39;[\S \t]*\w[\S \t]*\s*&#39;), re.MULTILINE | re.VERBOSE
    )

    _key_val_list_pat = re.compile(
        r&#34;^-(?:[ \t]*([^\n]*)(?:[ \t]*[:-][ \t]*(\S+))?)(?:\n((?:[ \t]+[^\n]+\n?)+))?&#34;,
        re.MULTILINE,
    )
    _key_val_dict_pat = re.compile(
        r&#34;^([^:\n]+)[ \t]*:[ \t]*([^\n]*)(?:((?:\n[ \t]+[^\n]+)+))?&#34;, re.MULTILINE
    )  # grp0: key, grp1: value, grp2: multiline value
    _meta_data_fence_pattern = re.compile(r&#39;^---[\ \t]*\n&#39;, re.MULTILINE)
    _meta_data_newline = re.compile(&#34;^\n&#34;, re.MULTILINE)

    def _extract_metadata(self, text):
        if text.startswith(&#34;---&#34;):
            fence_splits = re.split(self._meta_data_fence_pattern, text, maxsplit=2)
            metadata_content = fence_splits[1]
            match = re.findall(self._meta_data_pattern, metadata_content)
            if not match:
                return text
            tail = fence_splits[2]
        else:
            metadata_split = re.split(self._meta_data_newline, text, maxsplit=1)
            metadata_content = metadata_split[0]
            match = re.findall(self._meta_data_pattern, metadata_content)
            if not match:
                return text
            tail = metadata_split[1]

        def parse_structured_value(value):
            vs = value.lstrip()
            vs = value.replace(v[: len(value) - len(vs)], &#34;\n&#34;)[1:]

            # List
            if vs.startswith(&#34;-&#34;):
                r = []
                for match in re.findall(self._key_val_list_pat, vs):
                    if match[0] and not match[1] and not match[2]:
                        r.append(match[0].strip())
                    elif match[0] == &#34;&gt;&#34; and not match[1] and match[2]:
                        r.append(match[2].strip())
                    elif match[0] and match[1]:
                        r.append({match[0].strip(): match[1].strip()})
                    elif not match[0] and not match[1] and match[2]:
                        r.append(parse_structured_value(match[2]))
                    else:
                        # Broken case
                        pass

                return r

            # Dict
            else:
                return {
                    match[0].strip(): (
                        match[1].strip()
                        if match[1]
                        else parse_structured_value(match[2])
                    )
                    for match in re.findall(self._key_val_dict_pat, vs)
                }

        for item in match:

            k, v = item.split(&#34;:&#34;, 1)

            # Multiline value
            if v[:3] == &#34; &gt;\n&#34;:
                self.metadata[k.strip()] = _dedent(v[3:]).strip()

            # Empty value
            elif v == &#34;\n&#34;:
                self.metadata[k.strip()] = &#34;&#34;

            # Structured value
            elif v[0] == &#34;\n&#34;:
                self.metadata[k.strip()] = parse_structured_value(v)

            # Simple value
            else:
                self.metadata[k.strip()] = v.strip()

        return tail

    _emacs_oneliner_vars_pat = re.compile(r&#34;((?:&lt;!--)?\s*-\*-)\s*(?:(\S[^\r\n]*?)([\r\n]\s*)?)?(-\*-\s*(?:--&gt;)?)&#34;, re.UNICODE)
    # This regular expression is intended to match blocks like this:
    #    PREFIX Local Variables: SUFFIX
    #    PREFIX mode: Tcl SUFFIX
    #    PREFIX End: SUFFIX
    # Some notes:
    # - &#34;[ \t]&#34; is used instead of &#34;\s&#34; to specifically exclude newlines
    # - &#34;(\r\n|\n|\r)&#34; is used instead of &#34;$&#34; because the sre engine does
    #   not like anything other than Unix-style line terminators.
    _emacs_local_vars_pat = re.compile(r&#34;&#34;&#34;^
        (?P&lt;prefix&gt;(?:[^\r\n|\n|\r])*?)
        [\ \t]*Local\ Variables:[\ \t]*
        (?P&lt;suffix&gt;.*?)(?:\r\n|\n|\r)
        (?P&lt;content&gt;.*?\1End:)
        &#34;&#34;&#34;, re.IGNORECASE | re.MULTILINE | re.DOTALL | re.VERBOSE)

    def _emacs_vars_oneliner_sub(self, match):
        if match.group(1).strip() == &#39;-*-&#39; and match.group(4).strip() == &#39;-*-&#39;:
            lead_ws = re.findall(r&#39;^\s*&#39;, match.group(1))[0]
            tail_ws = re.findall(r&#39;\s*$&#39;, match.group(4))[0]
            return &#39;%s&lt;!-- %s %s %s --&gt;%s&#39; % (lead_ws, &#39;-*-&#39;, match.group(2).strip(), &#39;-*-&#39;, tail_ws)

        start, end = match.span()
        return match.string[start: end]

    def _get_emacs_vars(self, text):
        &#34;&#34;&#34;Return a dictionary of emacs-style local variables.

        Parsing is done loosely according to this spec (and according to
        some in-practice deviations from this):
        http://www.gnu.org/software/emacs/manual/html_node/emacs/Specifying-File-Variables.html#Specifying-File-Variables
        &#34;&#34;&#34;
        emacs_vars = {}
        SIZE = pow(2, 13)  # 8kB

        # Search near the start for a &#39;-*-&#39;-style one-liner of variables.
        head = text[:SIZE]
        if &#34;-*-&#34; in head:
            match = self._emacs_oneliner_vars_pat.search(head)
            if match:
                emacs_vars_str = match.group(2)
                assert &#39;\n&#39; not in emacs_vars_str
                emacs_var_strs = [s.strip() for s in emacs_vars_str.split(&#39;;&#39;)
                                  if s.strip()]
                if len(emacs_var_strs) == 1 and &#39;:&#39; not in emacs_var_strs[0]:
                    # While not in the spec, this form is allowed by emacs:
                    #   -*- Tcl -*-
                    # where the implied &#34;variable&#34; is &#34;mode&#34;. This form
                    # is only allowed if there are no other variables.
                    emacs_vars[&#34;mode&#34;] = emacs_var_strs[0].strip()
                else:
                    for emacs_var_str in emacs_var_strs:
                        try:
                            variable, value = emacs_var_str.strip().split(&#39;:&#39;, 1)
                        except ValueError:
                            log.debug(&#34;emacs variables error: malformed -*- &#34;
                                      &#34;line: %r&#34;, emacs_var_str)
                            continue
                        # Lowercase the variable name because Emacs allows &#34;Mode&#34;
                        # or &#34;mode&#34; or &#34;MoDe&#34;, etc.
                        emacs_vars[variable.lower()] = value.strip()

        tail = text[-SIZE:]
        if &#34;Local Variables&#34; in tail:
            match = self._emacs_local_vars_pat.search(tail)
            if match:
                prefix = match.group(&#34;prefix&#34;)
                suffix = match.group(&#34;suffix&#34;)
                lines = match.group(&#34;content&#34;).splitlines(0)
                # print &#34;prefix=%r, suffix=%r, content=%r, lines: %s&#34;\
                #      % (prefix, suffix, match.group(&#34;content&#34;), lines)

                # Validate the Local Variables block: proper prefix and suffix
                # usage.
                for i, line in enumerate(lines):
                    if not line.startswith(prefix):
                        log.debug(&#34;emacs variables error: line &#39;%s&#39; &#34;
                                  &#34;does not use proper prefix &#39;%s&#39;&#34;
                                  % (line, prefix))
                        return {}
                    # Don&#39;t validate suffix on last line. Emacs doesn&#39;t care,
                    # neither should we.
                    if i != len(lines)-1 and not line.endswith(suffix):
                        log.debug(&#34;emacs variables error: line &#39;%s&#39; &#34;
                                  &#34;does not use proper suffix &#39;%s&#39;&#34;
                                  % (line, suffix))
                        return {}

                # Parse out one emacs var per line.
                continued_for = None
                for line in lines[:-1]:  # no var on the last line (&#34;PREFIX End:&#34;)
                    if prefix: line = line[len(prefix):]  # strip prefix
                    if suffix: line = line[:-len(suffix)]  # strip suffix
                    line = line.strip()
                    if continued_for:
                        variable = continued_for
                        if line.endswith(&#39;\\&#39;):
                            line = line[:-1].rstrip()
                        else:
                            continued_for = None
                        emacs_vars[variable] += &#39; &#39; + line
                    else:
                        try:
                            variable, value = line.split(&#39;:&#39;, 1)
                        except ValueError:
                            log.debug(&#34;local variables error: missing colon &#34;
                                      &#34;in local variables entry: &#39;%s&#39;&#34; % line)
                            continue
                        # Do NOT lowercase the variable name, because Emacs only
                        # allows &#34;mode&#34; (and not &#34;Mode&#34;, &#34;MoDe&#34;, etc.) in this block.
                        value = value.strip()
                        if value.endswith(&#39;\\&#39;):
                            value = value[:-1].rstrip()
                            continued_for = variable
                        else:
                            continued_for = None
                        emacs_vars[variable] = value

        # Unquote values.
        for var, val in list(emacs_vars.items()):
            if len(val) &gt; 1 and (val.startswith(&#39;&#34;&#39;) and val.endswith(&#39;&#34;&#39;)
               or val.startswith(&#39;&#34;&#39;) and val.endswith(&#39;&#34;&#39;)):
                emacs_vars[var] = val[1:-1]

        return emacs_vars

    def _detab_line(self, line):
        r&#34;&#34;&#34;Recusively convert tabs to spaces in a single line.

        Called from _detab().&#34;&#34;&#34;
        if &#39;\t&#39; not in line:
            return line
        chunk1, chunk2 = line.split(&#39;\t&#39;, 1)
        chunk1 += (&#39; &#39; * (self.tab_width - len(chunk1) % self.tab_width))
        output = chunk1 + chunk2
        return self._detab_line(output)

    def _detab(self, text):
        r&#34;&#34;&#34;Iterate text line by line and convert tabs to spaces.

            &gt;&gt;&gt; m = Markdown()
            &gt;&gt;&gt; m._detab(&#34;\tfoo&#34;)
            &#39;    foo&#39;
            &gt;&gt;&gt; m._detab(&#34;  \tfoo&#34;)
            &#39;    foo&#39;
            &gt;&gt;&gt; m._detab(&#34;\t  foo&#34;)
            &#39;      foo&#39;
            &gt;&gt;&gt; m._detab(&#34;  foo&#34;)
            &#39;  foo&#39;
            &gt;&gt;&gt; m._detab(&#34;  foo\n\tbar\tblam&#34;)
            &#39;  foo\n    bar blam&#39;
        &#34;&#34;&#34;
        if &#39;\t&#39; not in text:
            return text
        output = []
        for line in text.splitlines():
            output.append(self._detab_line(line))
        return &#39;\n&#39;.join(output)

    # I broke out the html5 tags here and add them to _block_tags_a and
    # _block_tags_b.  This way html5 tags are easy to keep track of.
    _html5tags = &#39;|article|aside|header|hgroup|footer|nav|section|figure|figcaption&#39;

    _block_tags_a = &#39;p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del&#39;
    _block_tags_a += _html5tags

    _strict_tag_block_re = re.compile(r&#34;&#34;&#34;
        (                       # save in \1
            ^                   # start of line  (with re.M)
            &lt;(%s)               # start tag = \2
            \b                  # word break
            (.*\n)*?            # any number of lines, minimally matching
            &lt;/\2&gt;               # the matching end tag
            [ \t]*              # trailing spaces/tabs
            (?=\n+|\Z)          # followed by a newline or end of document
        )
        &#34;&#34;&#34; % _block_tags_a,
        re.X | re.M)

    _block_tags_b = &#39;p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math&#39;
    _block_tags_b += _html5tags

    _liberal_tag_block_re = re.compile(r&#34;&#34;&#34;
        (                       # save in \1
            ^                   # start of line  (with re.M)
            &lt;(%s)               # start tag = \2
            \b                  # word break
            (.*\n)*?            # any number of lines, minimally matching
            .*&lt;/\2&gt;             # the matching end tag
            [ \t]*              # trailing spaces/tabs
            (?=\n+|\Z)          # followed by a newline or end of document
        )
        &#34;&#34;&#34; % _block_tags_b,
        re.X | re.M)

    _html_markdown_attr_re = re.compile(
        r&#39;&#39;&#39;\s+markdown=(&#34;1&#34;|&#39;1&#39;)&#39;&#39;&#39;)
    def _hash_html_block_sub(self, match, raw=False):
        if isinstance(match, str):
            html = match
        else:
            html = match.group(1)

        if raw and self.safe_mode:
            html = self._sanitize_html(html)
        elif &#39;markdown-in-html&#39; in self.extras and &#39;markdown=&#39; in html:
            first_line = html.split(&#39;\n&#39;, 1)[0]
            m = self._html_markdown_attr_re.search(first_line)
            if m:
                lines = html.split(&#39;\n&#39;)
                middle = &#39;\n&#39;.join(lines[1:-1])
                last_line = lines[-1]
                first_line = first_line[:m.start()] + first_line[m.end():]
                f_key = _hash_text(first_line)
                self.html_blocks[f_key] = first_line
                l_key = _hash_text(last_line)
                self.html_blocks[l_key] = last_line
                return &#39;&#39;.join([&#34;\n\n&#34;, f_key,
                    &#34;\n\n&#34;, middle, &#34;\n\n&#34;,
                    l_key, &#34;\n\n&#34;])
        key = _hash_text(html)
        self.html_blocks[key] = html
        return &#34;\n\n&#34; + key + &#34;\n\n&#34;

    def _hash_html_blocks(self, text, raw=False):
        &#34;&#34;&#34;Hashify HTML blocks

        We only want to do this for block-level HTML tags, such as headers,
        lists, and tables. That&#39;s because we still want to wrap &lt;p&gt;s around
        &#34;paragraphs&#34; that are wrapped in non-block-level tags, such as anchors,
        phrase emphasis, and spans. The list of tags we&#39;re looking for is
        hard-coded.

        @param raw {boolean} indicates if these are raw HTML blocks in
            the original source. It makes a difference in &#34;safe&#34; mode.
        &#34;&#34;&#34;
        if &#39;&lt;&#39; not in text:
            return text

        # Pass `raw` value into our calls to self._hash_html_block_sub.
        hash_html_block_sub = _curry(self._hash_html_block_sub, raw=raw)

        # First, look for nested blocks, e.g.:
        #   &lt;div&gt;
        #       &lt;div&gt;
        #       tags for inner block must be indented.
        #       &lt;/div&gt;
        #   &lt;/div&gt;
        #
        # The outermost tags must start at the left margin for this to match, and
        # the inner nested divs must be indented.
        # We need to do this before the next, more liberal match, because the next
        # match will start at the first `&lt;div&gt;` and stop at the first `&lt;/div&gt;`.
        text = self._strict_tag_block_sub(text, self._block_tags_a, hash_html_block_sub)

        # Now match more liberally, simply from `\n&lt;tag&gt;` to `&lt;/tag&gt;\n`
        text = self._liberal_tag_block_re.sub(hash_html_block_sub, text)

        # Special case just for &lt;hr /&gt;. It was easier to make a special
        # case than to make the other regex more complicated.
        if &#34;&lt;hr&#34; in text:
            _hr_tag_re = _hr_tag_re_from_tab_width(self.tab_width)
            text = _hr_tag_re.sub(hash_html_block_sub, text)

        # Special case for standalone HTML comments:
        if &#34;&lt;!--&#34; in text:
            start = 0
            while True:
                # Delimiters for next comment block.
                try:
                    start_idx = text.index(&#34;&lt;!--&#34;, start)
                except ValueError:
                    break
                try:
                    end_idx = text.index(&#34;--&gt;&#34;, start_idx) + 3
                except ValueError:
                    break

                # Start position for next comment block search.
                start = end_idx

                # Validate whitespace before comment.
                if start_idx:
                    # - Up to `tab_width - 1` spaces before start_idx.
                    for i in range(self.tab_width - 1):
                        if text[start_idx - 1] != &#39; &#39;:
                            break
                        start_idx -= 1
                        if start_idx == 0:
                            break
                    # - Must be preceded by 2 newlines or hit the start of
                    #   the document.
                    if start_idx == 0:
                        pass
                    elif start_idx == 1 and text[0] == &#39;\n&#39;:
                        start_idx = 0  # to match minute detail of Markdown.pl regex
                    elif text[start_idx-2:start_idx] == &#39;\n\n&#39;:
                        pass
                    else:
                        break

                # Validate whitespace after comment.
                # - Any number of spaces and tabs.
                while end_idx &lt; len(text):
                    if text[end_idx] not in &#39; \t&#39;:
                        break
                    end_idx += 1
                # - Must be following by 2 newlines or hit end of text.
                if text[end_idx:end_idx+2] not in (&#39;&#39;, &#39;\n&#39;, &#39;\n\n&#39;):
                    continue

                # Escape and hash (must match `_hash_html_block_sub`).
                html = text[start_idx:end_idx]
                if raw and self.safe_mode:
                    html = self._sanitize_html(html)
                key = _hash_text(html)
                self.html_blocks[key] = html
                text = text[:start_idx] + &#34;\n\n&#34; + key + &#34;\n\n&#34; + text[end_idx:]

        if &#34;xml&#34; in self.extras:
            # Treat XML processing instructions and namespaced one-liner
            # tags as if they were block HTML tags. E.g., if standalone
            # (i.e. are their own paragraph), the following do not get
            # wrapped in a &lt;p&gt; tag:
            #    &lt;?foo bar?&gt;
            #
            #    &lt;xi:include xmlns:xi=&#34;http://www.w3.org/2001/XInclude&#34; href=&#34;chapter_1.md&#34;/&gt;
            _xml_oneliner_re = _xml_oneliner_re_from_tab_width(self.tab_width)
            text = _xml_oneliner_re.sub(hash_html_block_sub, text)

        return text

    def _strict_tag_block_sub(self, text, html_tags_re, callback):
        tag_count = 0
        current_tag = html_tags_re
        block = &#39;&#39;
        result = &#39;&#39;

        for chunk in text.splitlines(True):
            is_markup = re.match(r&#39;^(?:&lt;/code&gt;(?=&lt;/pre&gt;))?(&lt;/?(%s)\b&gt;?)&#39; % current_tag, chunk)
            block += chunk

            if is_markup:
                if chunk.startswith(&#39;&lt;/&#39;):
                    tag_count -= 1
                else:
                    # if close tag is in same line
                    if &#39;&lt;/%s&gt;&#39; % is_markup.group(2) in chunk[is_markup.end():]:
                        # we must ignore these
                        is_markup = None
                    else:
                        tag_count += 1
                        current_tag = is_markup.group(2)

            if tag_count == 0:
                if is_markup:
                    block = callback(block.rstrip(&#39;\n&#39;))  # remove trailing newline
                current_tag = html_tags_re
                result += block
                block = &#39;&#39;

        result += block

        return result

    def _strip_link_definitions(self, text):
        # Strips link definitions from text, stores the URLs and titles in
        # hash references.
        less_than_tab = self.tab_width - 1

        # Link defs are in the form:
        #   [id]: url &#34;optional title&#34;
        _link_def_re = re.compile(r&#34;&#34;&#34;
            ^[ ]{0,%d}\[(.+)\]: # id = \1
              [ \t]*
              \n?               # maybe *one* newline
              [ \t]*
            &lt;?(.+?)&gt;?           # url = \2
              [ \t]*
            (?:
                \n?             # maybe one newline
                [ \t]*
                (?&lt;=\s)         # lookbehind for whitespace
                [&#39;&#34;(]
                ([^\n]*)        # title = \3
                [&#39;&#34;)]
                [ \t]*
            )?  # title is optional
            (?:\n+|\Z)
            &#34;&#34;&#34; % less_than_tab, re.X | re.M | re.U)
        return _link_def_re.sub(self._extract_link_def_sub, text)

    def _extract_link_def_sub(self, match):
        id, url, title = match.groups()
        key = id.lower()    # Link IDs are case-insensitive
        self.urls[key] = self._encode_amps_and_angles(url)
        if title:
            self.titles[key] = title
        return &#34;&#34;

    def _do_numbering(self, text):
        &#39;&#39;&#39; We handle the special extension for generic numbering for
            tables, figures etc.
        &#39;&#39;&#39;
        # First pass to define all the references
        self.regex_defns = re.compile(r&#39;&#39;&#39;
            \[\#(\w+) # the counter.  Open square plus hash plus a word \1
            ([^@]*)   # Some optional characters, that aren&#39;t an @. \2
            @(\w+)       # the id.  Should this be normed? \3
            ([^\]]*)\]   # The rest of the text up to the terminating ] \4
            &#39;&#39;&#39;, re.VERBOSE)
        self.regex_subs = re.compile(r&#34;\[@(\w+)\s*\]&#34;)  # [@ref_id]
        counters = {}
        references = {}
        replacements = []
        definition_html = &#39;&lt;figcaption class=&#34;{}&#34; id=&#34;counter-ref-{}&#34;&gt;{}{}{}&lt;/figcaption&gt;&#39;
        reference_html = &#39;&lt;a class=&#34;{}&#34; href=&#34;#counter-ref-{}&#34;&gt;{}&lt;/a&gt;&#39;
        for match in self.regex_defns.finditer(text):
            # We must have four match groups otherwise this isn&#39;t a numbering reference
            if len(match.groups()) != 4:
                continue
            counter = match.group(1)
            text_before = match.group(2).strip()
            ref_id = match.group(3)
            text_after = match.group(4)
            number = counters.get(counter, 1)
            references[ref_id] = (number, counter)
            replacements.append((match.start(0),
                                 definition_html.format(counter,
                                                        ref_id,
                                                        text_before,
                                                        number,
                                                        text_after),
                                 match.end(0)))
            counters[counter] = number + 1
        for repl in reversed(replacements):
            text = text[:repl[0]] + repl[1] + text[repl[2]:]

        # Second pass to replace the references with the right
        # value of the counter
        # Fwiw, it&#39;s vaguely annoying to have to turn the iterator into
        # a list and then reverse it but I can&#39;t think of a better thing to do.
        for match in reversed(list(self.regex_subs.finditer(text))):
            number, counter = references.get(match.group(1), (None, None))
            if number is not None:
                repl = reference_html.format(counter,
                                             match.group(1),
                                             number)
            else:
                repl = reference_html.format(match.group(1),
                                             &#39;countererror&#39;,
                                             &#39;?&#39; + match.group(1) + &#39;?&#39;)
            if &#34;smarty-pants&#34; in self.extras:
                repl = repl.replace(&#39;&#34;&#39;, self._escape_table[&#39;&#34;&#39;])

            text = text[:match.start()] + repl + text[match.end():]
        return text

    def _extract_footnote_def_sub(self, match):
        id, text = match.groups()
        text = _dedent(text, skip_first_line=not text.startswith(&#39;\n&#39;)).strip()
        normed_id = re.sub(r&#39;\W&#39;, &#39;-&#39;, id)
        # Ensure footnote text ends with a couple newlines (for some
        # block gamut matches).
        self.footnotes[normed_id] = text + &#34;\n\n&#34;
        return &#34;&#34;

    def _strip_footnote_definitions(self, text):
        &#34;&#34;&#34;A footnote definition looks like this:

            [^note-id]: Text of the note.

                May include one or more indented paragraphs.

        Where,
        - The &#39;note-id&#39; can be pretty much anything, though typically it
          is the number of the footnote.
        - The first paragraph may start on the next line, like so:

            [^note-id]:
                Text of the note.
        &#34;&#34;&#34;
        less_than_tab = self.tab_width - 1
        footnote_def_re = re.compile(r&#39;&#39;&#39;
            ^[ ]{0,%d}\[\^(.+)\]:   # id = \1
            [ \t]*
            (                       # footnote text = \2
              # First line need not start with the spaces.
              (?:\s*.*\n+)
              (?:
                (?:[ ]{%d} | \t)  # Subsequent lines must be indented.
                .*\n+
              )*
            )
            # Lookahead for non-space at line-start, or end of doc.
            (?:(?=^[ ]{0,%d}\S)|\Z)
            &#39;&#39;&#39; % (less_than_tab, self.tab_width, self.tab_width),
            re.X | re.M)
        return footnote_def_re.sub(self._extract_footnote_def_sub, text)

    _hr_re = re.compile(r&#39;^[ ]{0,3}([-_*])[ ]{0,2}(\1[ ]{0,2}){2,}$&#39;, re.M)

    def _run_block_gamut(self, text):
        # These are all the transformations that form block-level
        # tags like paragraphs, headers, and list items.

        if &#39;admonitions&#39; in self.extras:
            text = self._do_admonitions(text)

        if &#39;wavedrom&#39; in self.extras:
            text = self._do_wavedrom_blocks(text)

        if &#34;fenced-code-blocks&#34; in self.extras:
            text = self._do_fenced_code_blocks(text)

        text = self._do_headers(text)

        # Do Horizontal Rules:
        # On the number of spaces in horizontal rules: The spec is fuzzy: &#34;If
        # you wish, you may use spaces between the hyphens or asterisks.&#34;
        # Markdown.pl 1.0.1&#39;s hr regexes limit the number of spaces between the
        # hr chars to one or two. We&#39;ll reproduce that limit here.
        hr = &#34;\n&lt;hr&#34;+self.empty_element_suffix+&#34;\n&#34;
        text = re.sub(self._hr_re, hr, text)

        text = self._do_lists(text)

        if &#34;pyshell&#34; in self.extras:
            text = self._prepare_pyshell_blocks(text)
        if &#34;wiki-tables&#34; in self.extras:
            text = self._do_wiki_tables(text)
        if &#34;tables&#34; in self.extras:
            text = self._do_tables(text)

        text = self._do_code_blocks(text)

        text = self._do_block_quotes(text)

        # We already ran _HashHTMLBlocks() before, in Markdown(), but that
        # was to escape raw HTML in the original Markdown source. This time,
        # we&#39;re escaping the markup we&#39;ve just created, so that we don&#39;t wrap
        # &lt;p&gt; tags around block-level tags.
        text = self._hash_html_blocks(text)

        text = self._form_paragraphs(text)

        return text

    def _pyshell_block_sub(self, match):
        if &#34;fenced-code-blocks&#34; in self.extras:
            dedented = _dedent(match.group(0))
            return self._do_fenced_code_blocks(&#34;```pycon\n&#34; + dedented + &#34;```\n&#34;)
        lines = match.group(0).splitlines(0)
        _dedentlines(lines)
        indent = &#39; &#39; * self.tab_width
        s = (&#39;\n&#39;  # separate from possible cuddled paragraph
             + indent + (&#39;\n&#39;+indent).join(lines)
             + &#39;\n&#39;)
        return s

    def _prepare_pyshell_blocks(self, text):
        &#34;&#34;&#34;Ensure that Python interactive shell sessions are put in
        code blocks -- even if not properly indented.
        &#34;&#34;&#34;
        if &#34;&gt;&gt;&gt;&#34; not in text:
            return text

        less_than_tab = self.tab_width - 1
        _pyshell_block_re = re.compile(r&#34;&#34;&#34;
            ^([ ]{0,%d})&gt;&gt;&gt;[ ].*\n  # first line
            ^(\1[^\S\n]*\S.*\n)*    # any number of subsequent lines with at least one character
            (?=^\1?\n|\Z)           # ends with a blank line or end of document
            &#34;&#34;&#34; % less_than_tab, re.M | re.X)

        return _pyshell_block_re.sub(self._pyshell_block_sub, text)

    def _table_sub(self, match):
        trim_space_re = &#39;^[ \t\n]+|[ \t\n]+$&#39;
        trim_bar_re = r&#39;^\||\|$&#39;
        split_bar_re = r&#39;^\||(?&lt;![\`\\])\|&#39;
        escape_bar_re = r&#39;\\\|&#39;

        head, underline, body = match.groups()

        # Determine aligns for columns.
        cols = [re.sub(escape_bar_re, &#39;|&#39;, cell.strip()) for cell in re.split(split_bar_re, re.sub(trim_bar_re, &#34;&#34;, re.sub(trim_space_re, &#34;&#34;, underline)))]
        align_from_col_idx = {}
        for col_idx, col in enumerate(cols):
            if col[0] == &#39;:&#39; and col[-1] == &#39;:&#39;:
                align_from_col_idx[col_idx] = &#39; style=&#34;text-align:center;&#34;&#39;
            elif col[0] == &#39;:&#39;:
                align_from_col_idx[col_idx] = &#39; style=&#34;text-align:left;&#34;&#39;
            elif col[-1] == &#39;:&#39;:
                align_from_col_idx[col_idx] = &#39; style=&#34;text-align:right;&#34;&#39;

        # thead
        hlines = [&#39;&lt;table%s&gt;&#39; % self._html_class_str_from_tag(&#39;table&#39;), &#39;&lt;thead%s&gt;&#39; % self._html_class_str_from_tag(&#39;thead&#39;), &#39;&lt;tr&gt;&#39;]
        cols = [re.sub(escape_bar_re, &#39;|&#39;, cell.strip()) for cell in re.split(split_bar_re, re.sub(trim_bar_re, &#34;&#34;, re.sub(trim_space_re, &#34;&#34;, head)))]
        for col_idx, col in enumerate(cols):
            hlines.append(&#39;  &lt;th%s&gt;%s&lt;/th&gt;&#39; % (
                align_from_col_idx.get(col_idx, &#39;&#39;),
                self._run_span_gamut(col)
            ))
        hlines.append(&#39;&lt;/tr&gt;&#39;)
        hlines.append(&#39;&lt;/thead&gt;&#39;)

        # tbody
        hlines.append(&#39;&lt;tbody&gt;&#39;)
        for line in body.strip(&#39;\n&#39;).split(&#39;\n&#39;):
            hlines.append(&#39;&lt;tr&gt;&#39;)
            cols = [re.sub(escape_bar_re, &#39;|&#39;, cell.strip()) for cell in re.split(split_bar_re, re.sub(trim_bar_re, &#34;&#34;, re.sub(trim_space_re, &#34;&#34;, line)))]
            for col_idx, col in enumerate(cols):
                hlines.append(&#39;  &lt;td%s&gt;%s&lt;/td&gt;&#39; % (
                    align_from_col_idx.get(col_idx, &#39;&#39;),
                    self._run_span_gamut(col)
                ))
            hlines.append(&#39;&lt;/tr&gt;&#39;)
        hlines.append(&#39;&lt;/tbody&gt;&#39;)
        hlines.append(&#39;&lt;/table&gt;&#39;)

        return &#39;\n&#39;.join(hlines) + &#39;\n&#39;

    def _do_tables(self, text):
        &#34;&#34;&#34;Copying PHP-Markdown and GFM table syntax. Some regex borrowed from
        https://github.com/michelf/php-markdown/blob/lib/Michelf/Markdown.php#L2538
        &#34;&#34;&#34;
        less_than_tab = self.tab_width - 1
        table_re = re.compile(r&#39;&#39;&#39;
                (?:(?&lt;=\n\n)|\A\n?)             # leading blank line

                ^[ ]{0,%d}                      # allowed whitespace
                (.*[|].*)  \n                   # $1: header row (at least one pipe)

                ^[ ]{0,%d}                      # allowed whitespace
                (                               # $2: underline row
                    # underline row with leading bar
                    (?:  \|\ *:?-+:?\ *  )+  \|? \s? \n
                    |
                    # or, underline row without leading bar
                    (?:  \ *:?-+:?\ *\|  )+  (?:  \ *:?-+:?\ *  )? \s? \n
                )

                (                               # $3: data rows
                    (?:
                        ^[ ]{0,%d}(?!\ )         # ensure line begins with 0 to less_than_tab spaces
                        .*\|.*  \n
                    )+
                )
            &#39;&#39;&#39; % (less_than_tab, less_than_tab, less_than_tab), re.M | re.X)
        return table_re.sub(self._table_sub, text)

    def _wiki_table_sub(self, match):
        ttext = match.group(0).strip()
        # print(&#39;wiki table: %r&#39; % match.group(0))
        rows = []
        for line in ttext.splitlines(0):
            line = line.strip()[2:-2].strip()
            row = [c.strip() for c in re.split(r&#39;(?&lt;!\\)\|\|&#39;, line)]
            rows.append(row)
        # from pprint import pprint
        # pprint(rows)
        hlines = []

        def add_hline(line, indents=0):
            hlines.append((self.tab * indents) + line)

        def format_cell(text):
            return self._run_span_gamut(re.sub(r&#34;^\s*~&#34;, &#34;&#34;, cell).strip(&#34; &#34;))

        add_hline(&#39;&lt;table%s&gt;&#39; % self._html_class_str_from_tag(&#39;table&#39;))
        # Check if first cell of first row is a header cell. If so, assume the whole row is a header row.
        if rows and rows[0] and re.match(r&#34;^\s*~&#34;, rows[0][0]):
            add_hline(&#39;&lt;thead%s&gt;&#39; % self._html_class_str_from_tag(&#39;thead&#39;), 1)
            add_hline(&#39;&lt;tr&gt;&#39;, 2)
            for cell in rows[0]:
                add_hline(&#34;&lt;th&gt;{}&lt;/th&gt;&#34;.format(format_cell(cell)), 3)
            add_hline(&#39;&lt;/tr&gt;&#39;, 2)
            add_hline(&#39;&lt;/thead&gt;&#39;, 1)
            # Only one header row allowed.
            rows = rows[1:]
        # If no more rows, don&#39;t create a tbody.
        if rows:
            add_hline(&#39;&lt;tbody&gt;&#39;, 1)
            for row in rows:
                add_hline(&#39;&lt;tr&gt;&#39;, 2)
                for cell in row:
                    add_hline(&#39;&lt;td&gt;{}&lt;/td&gt;&#39;.format(format_cell(cell)), 3)
                add_hline(&#39;&lt;/tr&gt;&#39;, 2)
            add_hline(&#39;&lt;/tbody&gt;&#39;, 1)
        add_hline(&#39;&lt;/table&gt;&#39;)
        return &#39;\n&#39;.join(hlines) + &#39;\n&#39;

    def _do_wiki_tables(self, text):
        # Optimization.
        if &#34;||&#34; not in text:
            return text

        less_than_tab = self.tab_width - 1
        wiki_table_re = re.compile(r&#39;&#39;&#39;
            (?:(?&lt;=\n\n)|\A\n?)            # leading blank line
            ^([ ]{0,%d})\|\|.+?\|\|[ ]*\n  # first line
            (^\1\|\|.+?\|\|\n)*        # any number of subsequent lines
            &#39;&#39;&#39; % less_than_tab, re.M | re.X)
        return wiki_table_re.sub(self._wiki_table_sub, text)

    def _run_span_gamut(self, text):
        # These are all the transformations that occur *within* block-level
        # tags like paragraphs, headers, and list items.

        text = self._do_code_spans(text)

        text = self._escape_special_chars(text)

        # Process anchor and image tags.
        if &#34;link-patterns&#34; in self.extras:
            text = self._do_link_patterns(text)

        text = self._do_links(text)

        # Make links out of things like `&lt;http://example.com/&gt;`
        # Must come after _do_links(), because you can use &lt; and &gt;
        # delimiters in inline links like [this](&lt;url&gt;).
        text = self._do_auto_links(text)

        text = self._encode_amps_and_angles(text)

        if &#34;strike&#34; in self.extras:
            text = self._do_strike(text)

        if &#34;underline&#34; in self.extras:
            text = self._do_underline(text)

        text = self._do_italics_and_bold(text)

        if &#34;tg-spoiler&#34; in self.extras:
            text = self._do_tg_spoiler(text)

        if &#34;smarty-pants&#34; in self.extras:
            text = self._do_smart_punctuation(text)

        # Do hard breaks:
        if &#34;break-on-newline&#34; in self.extras:
            text = re.sub(r&#34; *\n(?!\&lt;(?:\/?(ul|ol|li))\&gt;)&#34;, &#34;&lt;br%s\n&#34; % self.empty_element_suffix, text)
        else:
            text = re.sub(r&#34; {2,}\n&#34;, &#34; &lt;br%s\n&#34; % self.empty_element_suffix, text)

        return text

    # &#34;Sorta&#34; because auto-links are identified as &#34;tag&#34; tokens.
    _sorta_html_tokenize_re = re.compile(r&#34;&#34;&#34;
        (
            \\*  # escapes
            (?:
                # tag
                &lt;/?
                (?:\w+)                                     # tag name
                (?:\s+(?:[\w-]+:)?[\w-]+=(?:&#34;.*?&#34;|&#39;.*?&#39;))*  # attributes
                \s*/?&gt;
                |
                # auto-link (e.g., &lt;http://www.activestate.com/&gt;)
                &lt;[\w~:/?#\[\]@!$&amp;&#39;\(\)*+,;%=\.\\-]+&gt;
                |
                &lt;!--.*?--&gt;      # comment
                |
                &lt;\?.*?\?&gt;       # processing instruction
            )
        )
        &#34;&#34;&#34;, re.X)

    def _escape_special_chars(self, text):
        # Python markdown note: the HTML tokenization here differs from
        # that in Markdown.pl, hence the behaviour for subtle cases can
        # differ (I believe the tokenizer here does a better job because
        # it isn&#39;t susceptible to unmatched &#39;&lt;&#39; and &#39;&gt;&#39; in HTML tags).
        # Note, however, that &#39;&gt;&#39; is not allowed in an auto-link URL
        # here.
        lead_escape_re = re.compile(r&#39;^((?:\\\\)*(?!\\))&#39;)
        escaped = []
        is_html_markup = False
        for token in self._sorta_html_tokenize_re.split(text):
            # check token is preceded by 0 or more PAIRS of escapes, because escape pairs
            # escape themselves and don&#39;t affect the token
            if is_html_markup and lead_escape_re.match(token):
                # Within tags/HTML-comments/auto-links, encode * and _
                # so they don&#39;t conflict with their use in Markdown for
                # italics and strong.  We&#39;re replacing each such
                # character with its corresponding MD5 checksum value;
                # this is likely overkill, but it should prevent us from
                # colliding with the escape values by accident.
                escape_seq, token = lead_escape_re.split(token)[1:] or (&#39;&#39;, token)
                escaped.append(
                    escape_seq.replace(&#39;\\\\&#39;, self._escape_table[&#39;\\&#39;])
                    + token.replace(&#39;*&#39;, self._escape_table[&#39;*&#39;])
                           .replace(&#39;_&#39;, self._escape_table[&#39;_&#39;])
                )
            else:
                escaped.append(self._encode_backslash_escapes(token.replace(&#39;\\&lt;&#39;, &#39;&amp;lt;&#39;)))
            is_html_markup = not is_html_markup
        return &#39;&#39;.join(escaped)

    def _hash_html_spans(self, text):
        # Used for safe_mode.

        def _is_auto_link(s):
            if &#39;:&#39; in s and self._auto_link_re.match(s):
                return True
            elif &#39;@&#39; in s and self._auto_email_link_re.match(s):
                return True
            return False

        def _is_code_span(index, token):
            try:
                if token == &#39;&lt;code&gt;&#39;:
                    peek_tokens = split_tokens[index: index + 3]
                elif token == &#39;&lt;/code&gt;&#39;:
                    peek_tokens = split_tokens[index - 2: index + 1]
                else:
                    return False
            except IndexError:
                return False

            return re.match(r&#39;&lt;code&gt;md5-[A-Fa-f0-9]{32}&lt;/code&gt;&#39;, &#39;&#39;.join(peek_tokens))

        tokens = []
        split_tokens = self._sorta_html_tokenize_re.split(text)
        is_html_markup = False
        for index, token in enumerate(split_tokens):
            if is_html_markup and not _is_auto_link(token) and not _is_code_span(index, token):
                sanitized = self._sanitize_html(token)
                key = _hash_text(sanitized)
                self.html_spans[key] = sanitized
                tokens.append(key)
            else:
                tokens.append(self._encode_incomplete_tags(token))
            is_html_markup = not is_html_markup
        return &#39;&#39;.join(tokens)

    def _unhash_html_spans(self, text):
        for key, sanitized in list(self.html_spans.items()):
            text = text.replace(key, sanitized)
        return text

    def _sanitize_html(self, s):
        if self.safe_mode == &#34;replace&#34;:
            return self.html_removed_text
        elif self.safe_mode == &#34;escape&#34;:
            replacements = [
                (&#39;&amp;&#39;, &#39;&amp;amp;&#39;),
                (&#39;&lt;&#39;, &#39;&amp;lt;&#39;),
                (&#39;&gt;&#39;, &#39;&amp;gt;&#39;),
            ]
            for before, after in replacements:
                s = s.replace(before, after)
            return s
        else:
            raise MarkdownError(&#34;invalid value for &#39;safe_mode&#39;: %r (must be &#34;
                                &#34;&#39;escape&#39; or &#39;replace&#39;)&#34; % self.safe_mode)

    _inline_link_title = re.compile(r&#39;&#39;&#39;
            (                   # \1
              [ \t]+
              ([&#39;&#34;])            # quote char = \2
              (?P&lt;title&gt;.*?)
              \2
            )?                  # title is optional
          \)$
        &#39;&#39;&#39;, re.X | re.S)
    _tail_of_reference_link_re = re.compile(r&#39;&#39;&#39;
          # Match tail of: [text][id]
          [ ]?          # one optional space
          (?:\n[ ]*)?   # one optional newline followed by spaces
          \[
            (?P&lt;id&gt;.*?)
          \]
        &#39;&#39;&#39;, re.X | re.S)

    _whitespace = re.compile(r&#39;\s*&#39;)

    _strip_anglebrackets = re.compile(r&#39;&lt;(.*)&gt;.*&#39;)

    def _find_non_whitespace(self, text, start):
        &#34;&#34;&#34;Returns the index of the first non-whitespace character in text
        after (and including) start
        &#34;&#34;&#34;
        match = self._whitespace.match(text, start)
        return match.end()

    def _find_balanced(self, text, start, open_c, close_c):
        &#34;&#34;&#34;Returns the index where the open_c and close_c characters balance
        out - the same number of open_c and close_c are encountered - or the
        end of string if it&#39;s reached before the balance point is found.
        &#34;&#34;&#34;
        i = start
        l = len(text)
        count = 1
        while count &gt; 0 and i &lt; l:
            if text[i] == open_c:
                count += 1
            elif text[i] == close_c:
                count -= 1
            i += 1
        return i

    def _extract_url_and_title(self, text, start):
        &#34;&#34;&#34;Extracts the url and (optional) title from the tail of a link&#34;&#34;&#34;
        # text[start] equals the opening parenthesis
        idx = self._find_non_whitespace(text, start+1)
        if idx == len(text):
            return None, None, None
        end_idx = idx
        has_anglebrackets = text[idx] == &#34;&lt;&#34;
        if has_anglebrackets:
            end_idx = self._find_balanced(text, end_idx+1, &#34;&lt;&#34;, &#34;&gt;&#34;)
        end_idx = self._find_balanced(text, end_idx, &#34;(&#34;, &#34;)&#34;)
        match = self._inline_link_title.search(text, idx, end_idx)
        if not match:
            return None, None, None
        url, title = text[idx:match.start()], match.group(&#34;title&#34;)
        if has_anglebrackets:
            url = self._strip_anglebrackets.sub(r&#39;\1&#39;, url)
        return url, title, end_idx

    def _protect_url(self, url):
        &#39;&#39;&#39;
        Function that passes a URL through `_html_escape_url` to remove any nasty characters,
        and then hashes the now &#34;safe&#34; URL to prevent other safety mechanisms from tampering
        with it (eg: escaping &#34;&amp;&#34; in URL parameters)
        &#39;&#39;&#39;
        url = _html_escape_url(url, safe_mode=self.safe_mode)
        key = _hash_text(url)
        self._escape_table[url] = key
        return key

    _safe_protocols = re.compile(r&#39;(https?|ftp):&#39;, re.I)
    def _do_links(self, text):
        &#34;&#34;&#34;Turn Markdown link shortcuts into XHTML &lt;a&gt; and &lt;img&gt; tags.

        This is a combination of Markdown.pl&#39;s _DoAnchors() and
        _DoImages(). They are done together because that simplified the
        approach. It was necessary to use a different approach than
        Markdown.pl because of the lack of atomic matching support in
        Python&#39;s regex engine used in $g_nested_brackets.
        &#34;&#34;&#34;
        MAX_LINK_TEXT_SENTINEL = 3000  # markdown2 issue 24

        # `anchor_allowed_pos` is used to support img links inside
        # anchors, but not anchors inside anchors. An anchor&#39;s start
        # pos must be `&gt;= anchor_allowed_pos`.
        anchor_allowed_pos = 0

        curr_pos = 0
        while True:  # Handle the next link.
            # The next &#39;[&#39; is the start of:
            # - an inline anchor:   [text](url &#34;title&#34;)
            # - a reference anchor: [text][id]
            # - an inline img:      ![text](url &#34;title&#34;)
            # - a reference img:    ![text][id]
            # - a footnote ref:     [^id]
            #   (Only if &#39;footnotes&#39; extra enabled)
            # - a footnote defn:    [^id]: ...
            #   (Only if &#39;footnotes&#39; extra enabled) These have already
            #   been stripped in _strip_footnote_definitions() so no
            #   need to watch for them.
            # - a link definition:  [id]: url &#34;title&#34;
            #   These have already been stripped in
            #   _strip_link_definitions() so no need to watch for them.
            # - not markup:         [...anything else...
            try:
                start_idx = text.index(&#39;[&#39;, curr_pos)
            except ValueError:
                break
            text_length = len(text)

            # Find the matching closing &#39;]&#39;.
            # Markdown.pl allows *matching* brackets in link text so we
            # will here too. Markdown.pl *doesn&#39;t* currently allow
            # matching brackets in img alt text -- we&#39;ll differ in that
            # regard.
            bracket_depth = 0
            for p in range(start_idx+1, min(start_idx+MAX_LINK_TEXT_SENTINEL,
                                            text_length)):
                ch = text[p]
                if ch == &#39;]&#39;:
                    bracket_depth -= 1
                    if bracket_depth &lt; 0:
                        break
                elif ch == &#39;[&#39;:
                    bracket_depth += 1
            else:
                # Closing bracket not found within sentinel length.
                # This isn&#39;t markup.
                curr_pos = start_idx + 1
                continue
            link_text = text[start_idx+1:p]

            # Fix for issue 341 - Injecting XSS into link text
            if self.safe_mode:
                link_text = self._hash_html_spans(link_text)
                link_text = self._unhash_html_spans(link_text)

            # Possibly a footnote ref?
            if &#34;footnotes&#34; in self.extras and link_text.startswith(&#34;^&#34;):
                normed_id = re.sub(r&#39;\W&#39;, &#39;-&#39;, link_text[1:])
                if normed_id in self.footnotes:
                    self.footnote_ids.append(normed_id)
                    result = &#39;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref-%s&#34;&gt;&#39; \
                             &#39;&lt;a href=&#34;#fn-%s&#34;&gt;%s&lt;/a&gt;&lt;/sup&gt;&#39; \
                             % (normed_id, normed_id, len(self.footnote_ids))
                    text = text[:start_idx] + result + text[p+1:]
                else:
                    # This id isn&#39;t defined, leave the markup alone.
                    curr_pos = p+1
                continue

            # Now determine what this is by the remainder.
            p += 1

            # Inline anchor or img?
            if text[p:p + 1] == &#39;(&#39;:  # attempt at perf improvement
                url, title, url_end_idx = self._extract_url_and_title(text, p)
                if url is not None:
                    # Handle an inline anchor or img.
                    is_img = start_idx &gt; 0 and text[start_idx-1] == &#34;!&#34;
                    if is_img:
                        start_idx -= 1

                    # We&#39;ve got to encode these to avoid conflicting
                    # with italics/bold.
                    url = url.replace(&#39;*&#39;, self._escape_table[&#39;*&#39;]) \
                             .replace(&#39;_&#39;, self._escape_table[&#39;_&#39;])
                    if title:
                        title_str = &#39; title=&#34;%s&#34;&#39; % (
                            _xml_escape_attr(title)
                                .replace(&#39;*&#39;, self._escape_table[&#39;*&#39;])
                                .replace(&#39;_&#39;, self._escape_table[&#39;_&#39;]))
                    else:
                        title_str = &#39;&#39;
                    if is_img:
                        img_class_str = self._html_class_str_from_tag(&#34;img&#34;)
                        result = &#39;&lt;img src=&#34;%s&#34; alt=&#34;%s&#34;%s%s%s&#39; \
                            % (self._protect_url(url),
                               _xml_escape_attr(link_text),
                               title_str,
                               img_class_str,
                               self.empty_element_suffix)
                        if &#34;smarty-pants&#34; in self.extras:
                            result = result.replace(&#39;&#34;&#39;, self._escape_table[&#39;&#34;&#39;])
                        curr_pos = start_idx + len(result)
                        anchor_allowed_pos = start_idx + len(result)
                        text = text[:start_idx] + result + text[url_end_idx:]
                    elif start_idx &gt;= anchor_allowed_pos:
                        safe_link = self._safe_protocols.match(url) or url.startswith(&#39;#&#39;)
                        if self.safe_mode and not safe_link:
                            result_head = &#39;&lt;a href=&#34;#&#34;%s&gt;&#39; % (title_str)
                        else:
                            result_head = &#39;&lt;a href=&#34;%s&#34;%s&gt;&#39; % (self._protect_url(url), title_str)
                        result = &#39;%s%s&lt;/a&gt;&#39; % (result_head, link_text)
                        if &#34;smarty-pants&#34; in self.extras:
                            result = result.replace(&#39;&#34;&#39;, self._escape_table[&#39;&#34;&#39;])
                        # &lt;img&gt; allowed from curr_pos on, &lt;a&gt; from
                        # anchor_allowed_pos on.
                        curr_pos = start_idx + len(result_head)
                        anchor_allowed_pos = start_idx + len(result)
                        text = text[:start_idx] + result + text[url_end_idx:]
                    else:
                        # Anchor not allowed here.
                        curr_pos = start_idx + 1
                    continue

            # Reference anchor or img?
            else:
                match = self._tail_of_reference_link_re.match(text, p)
                if match:
                    # Handle a reference-style anchor or img.
                    is_img = start_idx &gt; 0 and text[start_idx-1] == &#34;!&#34;
                    if is_img:
                        start_idx -= 1
                    link_id = match.group(&#34;id&#34;).lower()
                    if not link_id:
                        link_id = link_text.lower()  # for links like [this][]
                    if link_id in self.urls:
                        url = self.urls[link_id]
                        # We&#39;ve got to encode these to avoid conflicting
                        # with italics/bold.
                        url = url.replace(&#39;*&#39;, self._escape_table[&#39;*&#39;]) \
                                 .replace(&#39;_&#39;, self._escape_table[&#39;_&#39;])
                        title = self.titles.get(link_id)
                        if title:
                            title = _xml_escape_attr(title) \
                                .replace(&#39;*&#39;, self._escape_table[&#39;*&#39;]) \
                                .replace(&#39;_&#39;, self._escape_table[&#39;_&#39;])
                            title_str = &#39; title=&#34;%s&#34;&#39; % title
                        else:
                            title_str = &#39;&#39;
                        if is_img:
                            img_class_str = self._html_class_str_from_tag(&#34;img&#34;)
                            result = &#39;&lt;img src=&#34;%s&#34; alt=&#34;%s&#34;%s%s%s&#39; \
                                % (self._protect_url(url),
                                   _xml_escape_attr(link_text),
                                   title_str,
                                   img_class_str,
                                   self.empty_element_suffix)
                            if &#34;smarty-pants&#34; in self.extras:
                                result = result.replace(&#39;&#34;&#39;, self._escape_table[&#39;&#34;&#39;])
                            curr_pos = start_idx + len(result)
                            text = text[:start_idx] + result + text[match.end():]
                        elif start_idx &gt;= anchor_allowed_pos:
                            if self.safe_mode and not self._safe_protocols.match(url):
                                result_head = &#39;&lt;a href=&#34;#&#34;%s&gt;&#39; % (title_str)
                            else:
                                result_head = &#39;&lt;a href=&#34;%s&#34;%s&gt;&#39; % (self._protect_url(url), title_str)
                            result = &#39;%s%s&lt;/a&gt;&#39; % (result_head, link_text)
                            if &#34;smarty-pants&#34; in self.extras:
                                result = result.replace(&#39;&#34;&#39;, self._escape_table[&#39;&#34;&#39;])
                            # &lt;img&gt; allowed from curr_pos on, &lt;a&gt; from
                            # anchor_allowed_pos on.
                            curr_pos = start_idx + len(result_head)
                            anchor_allowed_pos = start_idx + len(result)
                            text = text[:start_idx] + result + text[match.end():]
                        else:
                            # Anchor not allowed here.
                            curr_pos = start_idx + 1
                    else:
                        # This id isn&#39;t defined, leave the markup alone.
                        curr_pos = match.end()
                    continue

            # Otherwise, it isn&#39;t markup.
            curr_pos = start_idx + 1

        return text

    def header_id_from_text(self, text, prefix, n):
        &#34;&#34;&#34;Generate a header id attribute value from the given header
        HTML content.

        This is only called if the &#34;header-ids&#34; extra is enabled.
        Subclasses may override this for different header ids.

        @param text {str} The text of the header tag
        @param prefix {str} The requested prefix for header ids. This is the
            value of the &#34;header-ids&#34; extra key, if any. Otherwise, None.
        @param n {int} The &lt;hN&gt; tag number, i.e. `1` for an &lt;h1&gt; tag.
        @returns {str} The value for the header tag&#39;s &#34;id&#34; attribute. Return
            None to not have an id attribute and to exclude this header from
            the TOC (if the &#34;toc&#34; extra is specified).
        &#34;&#34;&#34;
        header_id = _slugify(text)
        if prefix and isinstance(prefix, str):
            header_id = prefix + &#39;-&#39; + header_id

        self._count_from_header_id[header_id] += 1
        if 0 == len(header_id) or self._count_from_header_id[header_id] &gt; 1:
            header_id += &#39;-%s&#39; % self._count_from_header_id[header_id]

        return header_id

    def _toc_add_entry(self, level, id, name):
        if level &gt; self._toc_depth:
            return
        if self._toc is None:
            self._toc = []
        self._toc.append((level, id, self._unescape_special_chars(name)))

    _h_re_base = r&#39;&#39;&#39;
        (^(.+)[ \t]{0,99}\n(=+|-+)[ \t]*\n+)
        |
        (^(\#{1,6})  # \1 = string of #&#39;s
        [ \t]%s
        (.+?)       # \2 = Header text
        [ \t]{0,99}
        (?&lt;!\\)     # ensure not an escaped trailing &#39;#&#39;
        \#*         # optional closing #&#39;s (not counted)
        \n+
        )
        &#39;&#39;&#39;

    _h_re = re.compile(_h_re_base % &#39;*&#39;, re.X | re.M)
    _h_re_tag_friendly = re.compile(_h_re_base % &#39;+&#39;, re.X | re.M)

    def _h_sub(self, match):
        if match.group(1) is not None and match.group(3) == &#34;-&#34;:
            return match.group(1)
        elif match.group(1) is not None:
            # Setext header
            n = {&#34;=&#34;: 1, &#34;-&#34;: 2}[match.group(3)[0]]
            header_group = match.group(2)
        else:
            # atx header
            n = len(match.group(5))
            header_group = match.group(6)

        demote_headers = self.extras.get(&#34;demote-headers&#34;)
        if demote_headers:
            n = min(n + demote_headers, 6)
        header_id_attr = &#34;&#34;
        if &#34;header-ids&#34; in self.extras:
            header_id = self.header_id_from_text(header_group,
                self.extras[&#34;header-ids&#34;], n)
            if header_id:
                header_id_attr = &#39; id=&#34;%s&#34;&#39; % header_id
        html = self._run_span_gamut(header_group)
        if &#34;toc&#34; in self.extras and header_id:
            self._toc_add_entry(n, header_id, html)
        return &#34;&lt;h%d%s&gt;%s&lt;/h%d&gt;\n\n&#34; % (n, header_id_attr, html, n)

    def _do_headers(self, text):
        # Setext-style headers:
        #     Header 1
        #     ========
        #
        #     Header 2
        #     --------

        # atx-style headers:
        #   # Header 1
        #   ## Header 2
        #   ## Header 2 with closing hashes ##
        #   ...
        #   ###### Header 6

        if &#39;tag-friendly&#39; in self.extras:
            return self._h_re_tag_friendly.sub(self._h_sub, text)
        return self._h_re.sub(self._h_sub, text)

    _marker_ul_chars = &#39;*+-&#39;
    _marker_any = r&#39;(?:[%s]|\d+\.)&#39; % _marker_ul_chars
    _marker_ul = &#39;(?:[%s])&#39; % _marker_ul_chars
    _marker_ol = r&#39;(?:\d+\.)&#39;

    def _list_sub(self, match):
        lst = match.group(1)
        lst_type = match.group(4) in self._marker_ul_chars and &#34;ul&#34; or &#34;ol&#34;

        if lst_type == &#39;ol&#39; and match.group(4) != &#39;1.&#39;:
            # if list doesn&#39;t start at 1 then set the ol start attribute
            lst_opts = &#39; start=&#34;%s&#34;&#39; % match.group(4)[:-1]
        else:
            lst_opts = &#39;&#39;

        lst_opts = lst_opts + self._html_class_str_from_tag(lst_type)

        result = self._process_list_items(lst)
        if self.list_level:
            return &#34;&lt;%s%s&gt;\n%s&lt;/%s&gt;\n&#34; % (lst_type, lst_opts, result, lst_type)
        else:
            return &#34;&lt;%s%s&gt;\n%s&lt;/%s&gt;\n\n&#34; % (lst_type, lst_opts, result, lst_type)

    def _do_lists(self, text):
        # Form HTML ordered (numbered) and unordered (bulleted) lists.

        # Iterate over each *non-overlapping* list match.
        pos = 0
        while True:
            # Find the *first* hit for either list style (ul or ol). We
            # match ul and ol separately to avoid adjacent lists of different
            # types running into each other (see issue #16).
            hits = []
            for marker_pat in (self._marker_ul, self._marker_ol):
                less_than_tab = self.tab_width - 1
                other_marker_pat = self._marker_ul if marker_pat == self._marker_ol else self._marker_ol
                whole_list = r&#39;&#39;&#39;
                    (                   # \1 = whole list
                      (                 # \2
                        ([ ]{0,%d})     # \3 = the indentation level of the list item marker
                        (%s)            # \4 = first list item marker
                        [ \t]+
                        (?!\ *\4\ )     # &#39;- - - ...&#39; isn&#39;t a list. See &#39;not_quite_a_list&#39; test case.
                      )
                      (?:.+?)
                      (                 # \5
                          \Z
                        |
                          \n{2,}
                          (?=\S)
                          (?!           # Negative lookahead for another list item marker
                            [ \t]*
                            %s[ \t]+
                          )
                        |
                          \n+
                          (?=
                            \3          # lookahead for a different style of list item marker
                            %s[ \t]+
                          )
                      )
                    )
                &#39;&#39;&#39; % (less_than_tab, marker_pat, marker_pat, other_marker_pat)
                if self.list_level:  # sub-list
                    list_re = re.compile(&#34;^&#34;+whole_list, re.X | re.M | re.S)
                else:
                    list_re = re.compile(r&#34;(?:(?&lt;=\n\n)|\A\n?)&#34;+whole_list,
                                         re.X | re.M | re.S)
                match = list_re.search(text, pos)
                if match:
                    hits.append((match.start(), match))
            if not hits:
                break
            hits.sort()
            match = hits[0][1]
            start, end = match.span()
            middle = self._list_sub(match)
            text = text[:start] + middle + text[end:]
            pos = start + len(middle)  # start pos for next attempted match

        return text

    _list_item_re = re.compile(r&#39;&#39;&#39;
        (\n)?                   # leading line = \1
        (^[ \t]*)               # leading whitespace = \2
        (?P&lt;marker&gt;%s) [ \t]+   # list marker = \3
        ((?:.+?)                # list item text = \4
        (\n{1,2}))              # eols = \5
        (?= \n* (\Z | \2 (?P&lt;next_marker&gt;%s) [ \t]+))
        &#39;&#39;&#39; % (_marker_any, _marker_any),
        re.M | re.X | re.S)

    _task_list_item_re = re.compile(r&#39;&#39;&#39;
        (\[[\ xX]\])[ \t]+       # tasklist marker = \1
        (.*)                   # list item text = \2
    &#39;&#39;&#39;, re.M | re.X | re.S)

    _task_list_warpper_str = r&#39;&lt;input type=&#34;checkbox&#34; class=&#34;task-list-item-checkbox&#34; %sdisabled&gt; %s&#39;

    def _task_list_item_sub(self, match):
        marker = match.group(1)
        item_text = match.group(2)
        if marker in [&#39;[x]&#39;,&#39;[X]&#39;]:
                return self._task_list_warpper_str % (&#39;checked &#39;, item_text)
        elif marker == &#39;[ ]&#39;:
                return self._task_list_warpper_str % (&#39;&#39;, item_text)

    _last_li_endswith_two_eols = False
    def _list_item_sub(self, match):
        item = match.group(4)
        leading_line = match.group(1)
        if leading_line or &#34;\n\n&#34; in item or self._last_li_endswith_two_eols:
            item = self._run_block_gamut(self._outdent(item))
        else:
            # Recursion for sub-lists:
            item = self._do_lists(self._uniform_outdent(item, min_outdent=&#39; &#39;)[1])
            if item.endswith(&#39;\n&#39;):
                item = item[:-1]
            item = self._run_span_gamut(item)
        self._last_li_endswith_two_eols = (len(match.group(5)) == 2)

        if &#34;task_list&#34; in self.extras:
            item = self._task_list_item_re.sub(self._task_list_item_sub, item)

        return &#34;&lt;li&gt;%s&lt;/li&gt;\n&#34; % item

    def _process_list_items(self, list_str):
        # Process the contents of a single ordered or unordered list,
        # splitting it into individual list items.

        # The $g_list_level global keeps track of when we&#39;re inside a list.
        # Each time we enter a list, we increment it; when we leave a list,
        # we decrement. If it&#39;s zero, we&#39;re not in a list anymore.
        #
        # We do this because when we&#39;re not inside a list, we want to treat
        # something like this:
        #
        #       I recommend upgrading to version
        #       8. Oops, now this line is treated
        #       as a sub-list.
        #
        # As a single paragraph, despite the fact that the second line starts
        # with a digit-period-space sequence.
        #
        # Whereas when we&#39;re inside a list (or sub-list), that line will be
        # treated as the start of a sub-list. What a kludge, huh? This is
        # an aspect of Markdown&#39;s syntax that&#39;s hard to parse perfectly
        # without resorting to mind-reading. Perhaps the solution is to
        # change the syntax rules such that sub-lists must start with a
        # starting cardinal number; e.g. &#34;1.&#34; or &#34;a.&#34;.
        self.list_level += 1
        self._last_li_endswith_two_eols = False
        list_str = list_str.rstrip(&#39;\n&#39;) + &#39;\n&#39;
        list_str = self._list_item_re.sub(self._list_item_sub, list_str)
        self.list_level -= 1
        return list_str

    def _get_pygments_lexer(self, lexer_name):
        try:
            from pygments import lexers, util
        except ImportError:
            return None
        try:
            return lexers.get_lexer_by_name(lexer_name)
        except util.ClassNotFound:
            return None

    def _color_with_pygments(self, codeblock, lexer, **formatter_opts):
        import pygments
        import pygments.formatters

        class HtmlCodeFormatter(pygments.formatters.HtmlFormatter):
            def _wrap_code(self, inner):
                &#34;&#34;&#34;A function for use in a Pygments Formatter which
                wraps in &lt;code&gt; tags.
                &#34;&#34;&#34;
                yield 0, &#34;&lt;code&gt;&#34;
                for tup in inner:
                    yield tup
                yield 0, &#34;&lt;/code&gt;&#34;

            def _add_newline(self, inner):
                # Add newlines around the inner contents so that _strict_tag_block_re matches the outer div.
                yield 0, &#34;\n&#34;
                yield from inner
                yield 0, &#34;\n&#34;

            def wrap(self, source, outfile=None):
                &#34;&#34;&#34;Return the source with a code, pre, and div.&#34;&#34;&#34;
                if outfile is None:
                    # pygments &gt;= 2.12
                    return self._add_newline(self._wrap_pre(self._wrap_code(source)))
                else:
                    # pygments &lt; 2.12
                    return self._wrap_div(self._add_newline(self._wrap_pre(self._wrap_code(source))))

        formatter_opts.setdefault(&#34;cssclass&#34;, &#34;codehilite&#34;)
        formatter = HtmlCodeFormatter(**formatter_opts)
        return pygments.highlight(codeblock, lexer, formatter)

    def _code_block_sub(self, match, is_fenced_code_block=False):
        lexer_name = None
        if is_fenced_code_block:
            lexer_name = match.group(2)
            codeblock = match.group(3)
            codeblock = codeblock[:-1]  # drop one trailing newline
        else:
            codeblock = match.group(1)
            codeblock = self._outdent(codeblock)
            codeblock = self._detab(codeblock)
            codeblock = codeblock.lstrip(&#39;\n&#39;)  # trim leading newlines
            codeblock = codeblock.rstrip()      # trim trailing whitespace

        # Use pygments only if not using the highlightjs-lang extra
        if lexer_name and &#34;highlightjs-lang&#34; not in self.extras:
            lexer = self._get_pygments_lexer(lexer_name)
            if lexer:
                leading_indent = &#39; &#39;*(len(match.group(1)) - len(match.group(1).lstrip()))
                return self._code_block_with_lexer_sub(codeblock, leading_indent, lexer, is_fenced_code_block)

        pre_class_str = self._html_class_str_from_tag(&#34;pre&#34;)

        if &#34;highlightjs-lang&#34; in self.extras and lexer_name:
            code_class_str = &#39; class=&#34;%s language-%s&#34;&#39; % (lexer_name, lexer_name)
        else:
            code_class_str = self._html_class_str_from_tag(&#34;code&#34;)

        if is_fenced_code_block:
            # Fenced code blocks need to be outdented before encoding, and then reapplied
            leading_indent = &#39; &#39; * (len(match.group(1)) - len(match.group(1).lstrip()))
            if codeblock:
                # only run the codeblock through the outdenter if not empty
                leading_indent, codeblock = self._uniform_outdent(codeblock, max_outdent=leading_indent)

            codeblock = self._encode_code(codeblock)

            if lexer_name == &#39;mermaid&#39; and &#39;mermaid&#39; in self.extras:
                return &#39;\n%s&lt;pre class=&#34;mermaid-pre&#34;&gt;&lt;div class=&#34;mermaid&#34;&gt;%s\n&lt;/div&gt;&lt;/pre&gt;\n&#39; % (
                    leading_indent, codeblock)

            return &#34;\n%s&lt;pre%s&gt;&lt;code%s&gt;%s\n&lt;/code&gt;&lt;/pre&gt;\n&#34; % (
                leading_indent, pre_class_str, code_class_str, codeblock)
        else:
            codeblock = self._encode_code(codeblock)

            return &#34;\n&lt;pre%s&gt;&lt;code%s&gt;%s\n&lt;/code&gt;&lt;/pre&gt;\n&#34; % (
                pre_class_str, code_class_str, codeblock)

    def _code_block_with_lexer_sub(self, codeblock, leading_indent, lexer, is_fenced_code_block):
        if is_fenced_code_block:
            formatter_opts = self.extras[&#39;fenced-code-blocks&#39;] or {}
        else:
            formatter_opts = {}

        def unhash_code(codeblock):
            for key, sanitized in list(self.html_spans.items()):
                codeblock = codeblock.replace(key, sanitized)
            replacements = [
                (&#34;&amp;amp;&#34;, &#34;&amp;&#34;),
                (&#34;&amp;lt;&#34;, &#34;&lt;&#34;),
                (&#34;&amp;gt;&#34;, &#34;&gt;&#34;)
            ]
            for old, new in replacements:
                codeblock = codeblock.replace(old, new)
            return codeblock
        # remove leading indent from code block
        _, codeblock = self._uniform_outdent(codeblock, max_outdent=leading_indent)

        codeblock = unhash_code(codeblock)
        colored = self._color_with_pygments(codeblock, lexer,
                                            **formatter_opts)

        # add back the indent to all lines
        return &#34;\n%s\n&#34; % self._uniform_indent(colored, leading_indent, True)

    def _html_class_str_from_tag(self, tag):
        &#34;&#34;&#34;Get the appropriate &#39; class=&#34;...&#34;&#39; string (note the leading
        space), if any, for the given tag.
        &#34;&#34;&#34;
        if &#34;html-classes&#34; not in self.extras:
            return &#34;&#34;
        try:
            html_classes_from_tag = self.extras[&#34;html-classes&#34;]
        except TypeError:
            return &#34;&#34;
        else:
            if isinstance(html_classes_from_tag, dict):
                if tag in html_classes_from_tag:
                    return &#39; class=&#34;%s&#34;&#39; % html_classes_from_tag[tag]
        return &#34;&#34;

    def _do_code_blocks(self, text):
        &#34;&#34;&#34;Process Markdown `&lt;pre&gt;&lt;code&gt;` blocks.&#34;&#34;&#34;
        code_block_re = re.compile(r&#39;&#39;&#39;
            (?:\n\n|\A\n?)
            (               # $1 = the code block -- one or more lines, starting with a space/tab
              (?:
                (?:[ ]{%d} | \t)  # Lines must start with a tab or a tab-width of spaces
                .*\n+
              )+
            )
            ((?=^[ ]{0,%d}\S)|\Z)   # Lookahead for non-space at line-start, or end of doc
            # Lookahead to make sure this block isn&#39;t already in a code block.
            # Needed when syntax highlighting is being used.
            (?!([^&lt;]|&lt;(/?)span)*\&lt;/code\&gt;)
            &#39;&#39;&#39; % (self.tab_width, self.tab_width),
            re.M | re.X)
        return code_block_re.sub(self._code_block_sub, text)

    _fenced_code_block_re = re.compile(r&#39;&#39;&#39;
        (?:\n+|\A\n?|(?&lt;=\n))
        (^[ \t]*`{3,})\s{0,99}?([\w+-]+)?\s{0,99}?\n  # $1 = opening fence (captured for back-referencing), $2 = optional lang
        (.*?)                             # $3 = code block content
        \1[ \t]*\n                      # closing fence
        &#39;&#39;&#39;, re.M | re.X | re.S)

    def _fenced_code_block_sub(self, match):
        return self._code_block_sub(match, is_fenced_code_block=True)

    def _do_fenced_code_blocks(self, text):
        &#34;&#34;&#34;Process ```-fenced unindented code blocks (&#39;fenced-code-blocks&#39; extra).&#34;&#34;&#34;
        return self._fenced_code_block_re.sub(self._fenced_code_block_sub, text)

    # Rules for a code span:
    # - backslash escapes are not interpreted in a code span
    # - to include one or or a run of more backticks the delimiters must
    #   be a longer run of backticks
    # - cannot start or end a code span with a backtick; pad with a
    #   space and that space will be removed in the emitted HTML
    # See `test/tm-cases/escapes.text` for a number of edge-case
    # examples.
    _code_span_re = re.compile(r&#39;&#39;&#39;
            (?&lt;!\\)
            (`+)        # \1 = Opening run of `
            (?!`)       # See Note A test/tm-cases/escapes.text
            (.+?)       # \2 = The code block
            (?&lt;!`)
            \1          # Matching closer
            (?!`)
        &#39;&#39;&#39;, re.X | re.S)

    def _code_span_sub(self, match):
        c = match.group(2).strip(&#34; \t&#34;)
        c = self._encode_code(c)
        return &#34;&lt;code%s&gt;%s&lt;/code&gt;&#34; % (self._html_class_str_from_tag(&#34;code&#34;), c)

    def _do_code_spans(self, text):
        #   *   Backtick quotes are used for &lt;code&gt;&lt;/code&gt; spans.
        #
        #   *   You can use multiple backticks as the delimiters if you want to
        #       include literal backticks in the code span. So, this input:
        #
        #         Just type ``foo `bar` baz`` at the prompt.
        #
        #       Will translate to:
        #
        #         &lt;p&gt;Just type &lt;code&gt;foo `bar` baz&lt;/code&gt; at the prompt.&lt;/p&gt;
        #
        #       There&#39;s no arbitrary limit to the number of backticks you
        #       can use as delimters. If you need three consecutive backticks
        #       in your code, use four for delimiters, etc.
        #
        #   *   You can use spaces to get literal backticks at the edges:
        #
        #         ... type `` `bar` `` ...
        #
        #       Turns to:
        #
        #         ... type &lt;code&gt;`bar`&lt;/code&gt; ...
        return self._code_span_re.sub(self._code_span_sub, text)

    def _encode_code(self, text):
        &#34;&#34;&#34;Encode/escape certain characters inside Markdown code runs.
        The point is that in code, these characters are literals,
        and lose their special Markdown meanings.
        &#34;&#34;&#34;
        replacements = [
            # Encode all ampersands; HTML entities are not
            # entities within a Markdown code span.
            (&#39;&amp;&#39;, &#39;&amp;amp;&#39;),
            # Do the angle bracket song and dance:
            (&#39;&lt;&#39;, &#39;&amp;lt;&#39;),
            (&#39;&gt;&#39;, &#39;&amp;gt;&#39;),
        ]
        for before, after in replacements:
            text = text.replace(before, after)
        hashed = _hash_text(text)
        self._code_table[text] = hashed
        return hashed

    def _wavedrom_block_sub(self, match):
        # if this isn&#39;t a wavedrom diagram block, exit now
        if match.group(2) != &#39;wavedrom&#39;:
            return match.string[match.start():match.end()]

        # dedent the block for processing
        lead_indent, waves = self._uniform_outdent(match.group(3))
        # default tags to wrap the wavedrom block in
        open_tag, close_tag = &#39;&lt;script type=&#34;WaveDrom&#34;&gt;\n&#39;, &#39;&lt;/script&gt;&#39;

        # check if the user would prefer to have the SVG embedded directly
        if not isinstance(self.extras[&#39;wavedrom&#39;], dict):
            embed_svg = True
        else:
            # default behaviour is to embed SVGs
            embed_svg = self.extras[&#39;wavedrom&#39;].get(&#39;prefer_embed_svg&#39;, True)

        if embed_svg:
            try:
                import wavedrom
                waves = wavedrom.render(waves).tostring()
                open_tag, close_tag = &#39;&lt;div&gt;&#39;, &#39;\n&lt;/div&gt;&#39;
            except ImportError:
                pass

        # hash SVG to prevent &lt;&gt; chars being messed with
        self._escape_table[waves] = _hash_text(waves)

        return self._uniform_indent(
            &#39;\n%s%s%s\n&#39; % (open_tag, self._escape_table[waves], close_tag),
            lead_indent, include_empty_lines=True
        )

    def _do_wavedrom_blocks(self, text):
        return self._fenced_code_block_re.sub(self._wavedrom_block_sub, text)

    _admonitions = r&#39;admonition|attention|caution|danger|error|hint|important|note|tip|warning&#39;
    _admonitions_re = re.compile(r&#39;&#39;&#39;
        ^(\ *)\.\.\ (%s)::\ *                # $1 leading indent, $2 the admonition
        (.*)?                                # $3 admonition title
        ((?:\s*\n\1\ {3,}.*)+?)              # $4 admonition body (required)
        (?=\s*(?:\Z|\n{4,}|\n\1?\ {0,2}\S))  # until EOF, 3 blank lines or something less indented
        &#39;&#39;&#39; % _admonitions,
        re.IGNORECASE | re.MULTILINE | re.VERBOSE
    )

    def _do_admonitions_sub(self, match):
        lead_indent, admonition_name, title, body = match.groups()

        admonition_type = &#39;&lt;strong&gt;%s&lt;/strong&gt;&#39; % admonition_name

        # figure out the class names to assign the block
        if admonition_name.lower() == &#39;admonition&#39;:
            admonition_class = &#39;admonition&#39;
        else:
            admonition_class = &#39;admonition %s&#39; % admonition_name.lower()

        # titles are generally optional
        if title:
            title = &#39;&lt;em&gt;%s&lt;/em&gt;&#39; % title

        # process the admonition body like regular markdown
        body = self._run_block_gamut(&#34;\n%s\n&#34; % self._uniform_outdent(body)[1])

        # indent the body before placing inside the aside block
        admonition = self._uniform_indent(&#39;%s\n%s\n\n%s\n&#39; % (admonition_type, title, body), self.tab, False)
        # wrap it in an aside
        admonition = &#39;&lt;aside class=&#34;%s&#34;&gt;\n%s&lt;/aside&gt;&#39; % (admonition_class, admonition)
        # now indent the whole admonition back to where it started
        return self._uniform_indent(admonition, lead_indent, False)

    def _do_admonitions(self, text):
        return self._admonitions_re.sub(self._do_admonitions_sub, text)

    _strike_re = re.compile(r&#34;~~(?=\S)(.+?)(?&lt;=\S)~~&#34;, re.S)
    def _do_strike(self, text):
        text = self._strike_re.sub(r&#34;&lt;s&gt;\1&lt;/s&gt;&#34;, text)
        return text

    _underline_re = re.compile(r&#34;(?&lt;!&lt;!)--(?!&gt;)(?=\S)(.+?)(?&lt;=\S)(?&lt;!&lt;!)--(?!&gt;)&#34;, re.S)
    def _do_underline(self, text):
        text = self._underline_re.sub(r&#34;&lt;u&gt;\1&lt;/u&gt;&#34;, text)
        return text

    _tg_spoiler_re = re.compile(r&#34;\|\|\s?(.+?)\s?\|\|&#34;, re.S)
    def _do_tg_spoiler(self, text):
        text = self._tg_spoiler_re.sub(r&#34;&lt;tg-spoiler&gt;\1&lt;/tg-spoiler&gt;&#34;, text)
        return text

    _strong_re = re.compile(r&#34;(\*\*|__)(?=\S)(.+?[*_]*)(?&lt;=\S)\1&#34;, re.S)
    _em_re = re.compile(r&#34;(\*|_)(?=\S)(.+?)(?&lt;=\S)\1&#34;, re.S)
    _code_friendly_strong_re = re.compile(r&#34;\*\*(?=\S)(.+?[*_]*)(?&lt;=\S)\*\*&#34;, re.S)
    _code_friendly_em_re = re.compile(r&#34;\*(?=\S)(.+?)(?&lt;=\S)\*&#34;, re.S)
    def _do_italics_and_bold(self, text):
        # &lt;strong&gt; must go first:
        if &#34;code-friendly&#34; in self.extras:
            text = self._code_friendly_strong_re.sub(r&#34;&lt;strong&gt;\1&lt;/strong&gt;&#34;, text)
            text = self._code_friendly_em_re.sub(r&#34;&lt;em&gt;\1&lt;/em&gt;&#34;, text)
        else:
            text = self._strong_re.sub(r&#34;&lt;strong&gt;\2&lt;/strong&gt;&#34;, text)
            text = self._em_re.sub(r&#34;&lt;em&gt;\2&lt;/em&gt;&#34;, text)
        return text

    # &#34;smarty-pants&#34; extra: Very liberal in interpreting a single prime as an
    # apostrophe; e.g. ignores the fact that &#34;round&#34;, &#34;bout&#34;, &#34;twer&#34;, and
    # &#34;twixt&#34; can be written without an initial apostrophe. This is fine because
    # using scare quotes (single quotation marks) is rare.
    _apostrophe_year_re = re.compile(r&#34;&#39;(\d\d)(?=(\s|,|;|\.|\?|!|$))&#34;)
    _contractions = [&#34;tis&#34;, &#34;twas&#34;, &#34;twer&#34;, &#34;neath&#34;, &#34;o&#34;, &#34;n&#34;,
        &#34;round&#34;, &#34;bout&#34;, &#34;twixt&#34;, &#34;nuff&#34;, &#34;fraid&#34;, &#34;sup&#34;]
    def _do_smart_contractions(self, text):
        text = self._apostrophe_year_re.sub(r&#34;&amp;#8217;\1&#34;, text)
        for c in self._contractions:
            text = text.replace(&#34;&#39;%s&#34; % c, &#34;&amp;#8217;%s&#34; % c)
            text = text.replace(&#34;&#39;%s&#34; % c.capitalize(),
                &#34;&amp;#8217;%s&#34; % c.capitalize())
        return text

    # Substitute double-quotes before single-quotes.
    _opening_single_quote_re = re.compile(r&#34;(?&lt;!\S)&#39;(?=\S)&#34;)
    _opening_double_quote_re = re.compile(r&#39;(?&lt;!\S)&#34;(?=\S)&#39;)
    _closing_single_quote_re = re.compile(r&#34;(?&lt;=\S)&#39;&#34;)
    _closing_double_quote_re = re.compile(r&#39;(?&lt;=\S)&#34;(?=(\s|,|;|\.|\?|!|$))&#39;)
    def _do_smart_punctuation(self, text):
        &#34;&#34;&#34;Fancifies &#39;single quotes&#39;, &#34;double quotes&#34;, and apostrophes.
        Converts --, ---, and ... into en dashes, em dashes, and ellipses.

        Inspiration is: &lt;http://daringfireball.net/projects/smartypants/&gt;
        See &#34;test/tm-cases/smarty_pants.text&#34; for a full discussion of the
        support here and
        &lt;http://code.google.com/p/python-markdown2/issues/detail?id=42&gt; for a
        discussion of some diversion from the original SmartyPants.
        &#34;&#34;&#34;
        if &#34;&#39;&#34; in text:  # guard for perf
            text = self._do_smart_contractions(text)
            text = self._opening_single_quote_re.sub(&#34;&amp;#8216;&#34;, text)
            text = self._closing_single_quote_re.sub(&#34;&amp;#8217;&#34;, text)

        if &#39;&#34;&#39; in text:  # guard for perf
            text = self._opening_double_quote_re.sub(&#34;&amp;#8220;&#34;, text)
            text = self._closing_double_quote_re.sub(&#34;&amp;#8221;&#34;, text)

        text = text.replace(&#34;---&#34;, &#34;&amp;#8212;&#34;)
        text = text.replace(&#34;--&#34;, &#34;&amp;#8211;&#34;)
        text = text.replace(&#34;...&#34;, &#34;&amp;#8230;&#34;)
        text = text.replace(&#34; . . . &#34;, &#34;&amp;#8230;&#34;)
        text = text.replace(&#34;. . .&#34;, &#34;&amp;#8230;&#34;)

        # TODO: Temporary hack to fix https://github.com/trentm/python-markdown2/issues/150
        if &#34;footnotes&#34; in self.extras and &#34;footnote-ref&#34; in text:
            # Quotes in the footnote back ref get converted to &#34;smart&#34; quotes
            # Change them back here to ensure they work.
            text = text.replace(&#39;class=&#34;footnote-ref&amp;#8221;&#39;, &#39;class=&#34;footnote-ref&#34;&#39;)

        return text

    _block_quote_base = r&#39;&#39;&#39;
        (                           # Wrap whole match in \1
          (
            ^[ \t]*&gt;%s[ \t]?        # &#39;&gt;&#39; at the start of a line
              .+\n                  # rest of the first line
            (.+\n)*                 # subsequent consecutive lines
          )+
        )
    &#39;&#39;&#39;
    _block_quote_re = re.compile(_block_quote_base % &#39;&#39;, re.M | re.X)
    _block_quote_re_spoiler = re.compile(_block_quote_base % &#39;[ \t]*?!?&#39;, re.M | re.X)
    _bq_one_level_re = re.compile(&#39;^[ \t]*&gt;[ \t]?&#39;, re.M)
    _bq_one_level_re_spoiler = re.compile(&#39;^[ \t]*&gt;[ \t]*?![ \t]?&#39;, re.M)
    _bq_all_lines_spoilers = re.compile(r&#39;\A(?:^[ \t]*&gt;[ \t]*?!.*[\n\r]*)+\Z&#39;, re.M)
    _html_pre_block_re = re.compile(r&#39;(\s*&lt;pre&gt;.+?&lt;/pre&gt;)&#39;, re.S)
    def _dedent_two_spaces_sub(self, match):
        return re.sub(r&#39;(?m)^  &#39;, &#39;&#39;, match.group(1))

    def _block_quote_sub(self, match):
        bq = match.group(1)
        is_spoiler = &#39;spoiler&#39; in self.extras and self._bq_all_lines_spoilers.match(bq)
        # trim one level of quoting
        if is_spoiler:
            bq = self._bq_one_level_re_spoiler.sub(&#39;&#39;, bq)
        else:
            bq = self._bq_one_level_re.sub(&#39;&#39;, bq)
        # trim whitespace-only lines
        bq = self._ws_only_line_re.sub(&#39;&#39;, bq)
        bq = self._run_block_gamut(bq)          # recurse

        bq = re.sub(&#39;(?m)^&#39;, &#39;  &#39;, bq)
        # These leading spaces screw with &lt;pre&gt; content, so we need to fix that:
        bq = self._html_pre_block_re.sub(self._dedent_two_spaces_sub, bq)

        if is_spoiler:
            return &#39;&lt;blockquote class=&#34;spoiler&#34;&gt;\n%s\n&lt;/blockquote&gt;\n\n&#39; % bq
        else:
            return &#39;&lt;blockquote&gt;\n%s\n&lt;/blockquote&gt;\n\n&#39; % bq

    def _do_block_quotes(self, text):
        if &#39;&gt;&#39; not in text:
            return text
        if &#39;spoiler&#39; in self.extras:
            return self._block_quote_re_spoiler.sub(self._block_quote_sub, text)
        else:
            return self._block_quote_re.sub(self._block_quote_sub, text)

    def _form_paragraphs(self, text):
        # Strip leading and trailing lines:
        text = text.strip(&#39;\n&#39;)

        # Wrap &lt;p&gt; tags.
        grafs = []
        for i, graf in enumerate(re.split(r&#34;\n{2,}&#34;, text)):
            if graf in self.html_blocks:
                # Unhashify HTML blocks
                grafs.append(self.html_blocks[graf])
            else:
                cuddled_list = None
                if &#34;cuddled-lists&#34; in self.extras:
                    # Need to put back trailing &#39;\n&#39; for `_list_item_re`
                    # match at the end of the paragraph.
                    li = self._list_item_re.search(graf + &#39;\n&#39;)
                    # Two of the same list marker in this paragraph: a likely
                    # candidate for a list cuddled to preceding paragraph
                    # text (issue 33). Note the `[-1]` is a quick way to
                    # consider numeric bullets (e.g. &#34;1.&#34; and &#34;2.&#34;) to be
                    # equal.
                    if (li and len(li.group(2)) &lt;= 3
                            and (
                                    (li.group(&#34;next_marker&#34;) and li.group(&#34;marker&#34;)[-1] == li.group(&#34;next_marker&#34;)[-1])
                                    or
                                    li.group(&#34;next_marker&#34;) is None
                            )
                    ):
                        start = li.start()
                        cuddled_list = self._do_lists(graf[start:]).rstrip(&#34;\n&#34;)
                        assert re.match(r&#39;^&lt;(?:ul|ol).*?&gt;&#39;, cuddled_list)
                        graf = graf[:start]

                # Wrap &lt;p&gt; tags.
                graf = self._run_span_gamut(graf)
                grafs.append(&#34;&lt;p%s&gt;&#34; % self._html_class_str_from_tag(&#39;p&#39;) + graf.lstrip(&#34; \t&#34;) + &#34;&lt;/p&gt;&#34;)

                if cuddled_list:
                    grafs.append(cuddled_list)

        return &#34;\n\n&#34;.join(grafs)

    def _add_footnotes(self, text):
        if self.footnotes:
            footer = [
                &#39;&lt;div class=&#34;footnotes&#34;&gt;&#39;,
                &#39;&lt;hr&#39; + self.empty_element_suffix,
                &#39;&lt;ol&gt;&#39;,
            ]

            if not self.footnote_title:
                self.footnote_title = &#34;Jump back to footnote %d in the text.&#34;
            if not self.footnote_return_symbol:
                self.footnote_return_symbol = &#34;&amp;#8617;&#34;

            for i, id in enumerate(self.footnote_ids):
                if i != 0:
                    footer.append(&#39;&#39;)
                footer.append(&#39;&lt;li id=&#34;fn-%s&#34;&gt;&#39; % id)
                footer.append(self._run_block_gamut(self.footnotes[id]))
                try:
                    backlink = (&#39;&lt;a href=&#34;#fnref-%s&#34; &#39; +
                            &#39;class=&#34;footnoteBackLink&#34; &#39; +
                            &#39;title=&#34;&#39; + self.footnote_title + &#39;&#34;&gt;&#39; +
                            self.footnote_return_symbol +
                            &#39;&lt;/a&gt;&#39;) % (id, i+1)
                except TypeError:
                    log.debug(&#34;Footnote error. `footnote_title` &#34;
                              &#34;must include parameter. Using defaults.&#34;)
                    backlink = (&#39;&lt;a href=&#34;#fnref-%s&#34; &#39;
                        &#39;class=&#34;footnoteBackLink&#34; &#39;
                        &#39;title=&#34;Jump back to footnote %d in the text.&#34;&gt;&#39;
                        &#39;&amp;#8617;&lt;/a&gt;&#39; % (id, i+1))

                if footer[-1].endswith(&#34;&lt;/p&gt;&#34;):
                    footer[-1] = footer[-1][:-len(&#34;&lt;/p&gt;&#34;)] \
                        + &#39;&amp;#160;&#39; + backlink + &#34;&lt;/p&gt;&#34;
                else:
                    footer.append(&#34;\n&lt;p&gt;%s&lt;/p&gt;&#34; % backlink)
                footer.append(&#39;&lt;/li&gt;&#39;)
            footer.append(&#39;&lt;/ol&gt;&#39;)
            footer.append(&#39;&lt;/div&gt;&#39;)
            return text + &#39;\n\n&#39; + &#39;\n&#39;.join(footer)
        else:
            return text

    _naked_lt_re = re.compile(r&#39;&lt;(?![a-z/?\$!])&#39;, re.I)
    _naked_gt_re = re.compile(r&#39;&#39;&#39;(?&lt;![a-z0-9?!/&#39;&#34;-])&gt;&#39;&#39;&#39;, re.I)

    def _encode_amps_and_angles(self, text):
        # Smart processing for ampersands and angle brackets that need
        # to be encoded.
        text = _AMPERSAND_RE.sub(&#39;&amp;amp;&#39;, text)

        # Encode naked &lt;&#39;s
        text = self._naked_lt_re.sub(&#39;&amp;lt;&#39;, text)

        # Encode naked &gt;&#39;s
        # Note: Other markdown implementations (e.g. Markdown.pl, PHP
        # Markdown) don&#39;t do this.
        text = self._naked_gt_re.sub(&#39;&amp;gt;&#39;, text)
        return text

    _incomplete_tags_re = re.compile(r&#34;&lt;(/?\w+?(?!\w)\s*?.+?[\s/]+?)&#34;)

    def _encode_incomplete_tags(self, text):
        if self.safe_mode not in (&#34;replace&#34;, &#34;escape&#34;):
            return text

        if text.endswith(&#34;&gt;&#34;):
            return text  # this is not an incomplete tag, this is a link in the form &lt;http://x.y.z&gt;

        def incomplete_tags_sub(match):
            return match.group().replace(&#39;&lt;&#39;, &#39;&amp;lt;&#39;)

        return self._incomplete_tags_re.sub(incomplete_tags_sub, text)

    def _encode_backslash_escapes(self, text):
        for ch, escape in list(self._escape_table.items()):
            text = text.replace(&#34;\\&#34;+ch, escape)
        return text

    _auto_link_re = re.compile(r&#39;&lt;((https?|ftp):[^\&#39;&#34;&gt;\s]+)&gt;&#39;, re.I)
    def _auto_link_sub(self, match):
        g1 = match.group(1)
        return &#39;&lt;a href=&#34;%s&#34;&gt;%s&lt;/a&gt;&#39; % (self._protect_url(g1), g1)

    _auto_email_link_re = re.compile(r&#34;&#34;&#34;
          &lt;
           (?:mailto:)?
          (
              [-.\w]+
              \@
              [-\w]+(\.[-\w]+)*\.[a-z]+
          )
          &gt;
        &#34;&#34;&#34;, re.I | re.X | re.U)
    def _auto_email_link_sub(self, match):
        return self._encode_email_address(
            self._unescape_special_chars(match.group(1)))

    def _do_auto_links(self, text):
        text = self._auto_link_re.sub(self._auto_link_sub, text)
        text = self._auto_email_link_re.sub(self._auto_email_link_sub, text)
        return text

    def _encode_email_address(self, addr):
        #  Input: an email address, e.g. &#34;foo@example.com&#34;
        #
        #  Output: the email address as a mailto link, with each character
        #      of the address encoded as either a decimal or hex entity, in
        #      the hopes of foiling most address harvesting spam bots. E.g.:
        #
        #    &lt;a href=&#34;&amp;#x6D;&amp;#97;&amp;#105;&amp;#108;&amp;#x74;&amp;#111;:&amp;#102;&amp;#111;&amp;#111;&amp;#64;&amp;#101;
        #       x&amp;#x61;&amp;#109;&amp;#x70;&amp;#108;&amp;#x65;&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&#34;&gt;&amp;#102;&amp;#111;&amp;#111;
        #       &amp;#64;&amp;#101;x&amp;#x61;&amp;#109;&amp;#x70;&amp;#108;&amp;#x65;&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;
        #
        #  Based on a filter by Matthew Wickline, posted to the BBEdit-Talk
        #  mailing list: &lt;http://tinyurl.com/yu7ue&gt;
        chars = [_xml_encode_email_char_at_random(ch)
                 for ch in &#34;mailto:&#34; + addr]
        # Strip the mailto: from the visible part.
        addr = &#39;&lt;a href=&#34;%s&#34;&gt;%s&lt;/a&gt;&#39; \
               % (&#39;&#39;.join(chars), &#39;&#39;.join(chars[7:]))
        return addr

    _basic_link_re = re.compile(r&#39;!?\[.*?\]\(.*?\)&#39;)
    def _do_link_patterns(self, text):
        link_from_hash = {}
        for regex, repl in self.link_patterns:
            replacements = []
            for match in regex.finditer(text):
                if any(self._match_overlaps_substr(text, match, h) for h in link_from_hash):
                    continue

                if hasattr(repl, &#34;__call__&#34;):
                    href = repl(match)
                else:
                    href = match.expand(repl)
                replacements.append((match.span(), href))
            for (start, end), href in reversed(replacements):

                # Do not match against links inside brackets.
                if text[start - 1:start] == &#39;[&#39; and text[end:end + 1] == &#39;]&#39;:
                    continue

                # Do not match against links in the standard markdown syntax.
                if text[start - 2:start] == &#39;](&#39; or text[end:end + 2] == &#39;&#34;)&#39;:
                    continue

                # Do not match against links which are escaped.
                if text[start - 3:start] == &#39;&#34;&#34;&#34;&#39; and text[end:end + 3] == &#39;&#34;&#34;&#34;&#39;:
                    text = text[:start - 3] + text[start:end] + text[end + 3:]
                    continue

                # search the text for anything that looks like a link
                is_inside_link = False
                for link_re in (self._auto_link_re, self._basic_link_re):
                    for match in link_re.finditer(text):
                        if any((r[0] &lt;= start and end &lt;= r[1]) for r in match.regs):
                            # if the link pattern start and end pos is within the bounds of
                            # something that looks like a link, then don&#39;t process it
                            is_inside_link = True
                            break
                    else:
                        continue
                    break

                if is_inside_link:
                    continue

                escaped_href = (
                    href.replace(&#39;&#34;&#39;, &#39;&amp;quot;&#39;)  # b/c of attr quote
                        # To avoid markdown &lt;em&gt; and &lt;strong&gt;:
                        .replace(&#39;*&#39;, self._escape_table[&#39;*&#39;])
                        .replace(&#39;_&#39;, self._escape_table[&#39;_&#39;]))
                link = &#39;&lt;a href=&#34;%s&#34;&gt;%s&lt;/a&gt;&#39; % (escaped_href, text[start:end])
                hash = _hash_text(link)
                link_from_hash[hash] = link
                text = text[:start] + hash + text[end:]
        for hash, link in list(link_from_hash.items()):
            text = text.replace(hash, link)
        return text

    def _unescape_special_chars(self, text):
        # Swap back in all the special characters we&#39;ve hidden.
        while True:
            orig_text = text
            for ch, hash in list(self._escape_table.items()) + list(self._code_table.items()):
                text = text.replace(hash, ch)
            if text == orig_text:
                break
        return text

    def _outdent(self, text):
        # Remove one level of line-leading tabs or spaces
        return self._outdent_re.sub(&#39;&#39;, text)

    def _uniform_outdent(self, text, min_outdent=None, max_outdent=None):
        # Removes the smallest common leading indentation from each (non empty)
        # line of `text` and returns said indent along with the outdented text.
        # The `min_outdent` kwarg makes sure the smallest common whitespace
        # must be at least this size
        # The `max_outdent` sets the maximum amount a line can be
        # outdented by

        # find the leading whitespace for every line
        whitespace = [
            re.findall(r&#39;^[ \t]*&#39;, line)[0] if line else None
            for line in text.splitlines()
        ]
        whitespace_not_empty = [i for i in whitespace if i is not None]

        # if no whitespace detected (ie: no lines in code block, issue #505)
        if not whitespace_not_empty:
            return &#39;&#39;, text

        # get minimum common whitespace
        outdent = min(whitespace_not_empty)
        # adjust min common ws to be within bounds
        if min_outdent is not None:
            outdent = min([i for i in whitespace_not_empty if i &gt;= min_outdent] or [min_outdent])
        if max_outdent is not None:
            outdent = min(outdent, max_outdent)

        outdented = []
        for line_ws, line in zip(whitespace, text.splitlines(True)):
            if line.startswith(outdent):
                # if line starts with smallest common ws, dedent it
                outdented.append(line.replace(outdent, &#39;&#39;, 1))
            elif line_ws is not None and line_ws &lt; outdent:
                # if less indented than min common whitespace then outdent as much as possible
                outdented.append(line.replace(line_ws, &#39;&#39;, 1))
            else:
                outdented.append(line)

        return outdent, &#39;&#39;.join(outdented)

    def _uniform_indent(self, text, indent, include_empty_lines=False):
        return &#39;&#39;.join(
            (indent + line if line.strip() or include_empty_lines else &#39;&#39;)
            for line in text.splitlines(True)
        )

    @staticmethod
    def _match_overlaps_substr(text, match, substr):
        &#39;&#39;&#39;
        Checks if a regex match overlaps with a substring in the given text.
        &#39;&#39;&#39;
        for instance in re.finditer(re.escape(substr), text):
            start, end = instance.span()
            if start &lt;= match.start() &lt;= end:
                return True
            if start &lt;= match.end() &lt;= end:
                return True
        return False


class MarkdownWithExtras(Markdown):
    &#34;&#34;&#34;A markdowner class that enables most extras:

    - footnotes
    - fenced-code-blocks (only highlights code if &#39;pygments&#39; Python module on path)

    These are not included:
    - pyshell (specific to Python-related documenting)
    - code-friendly (because it *disables* part of the syntax)
    - link-patterns (because you need to specify some actual
      link-patterns anyway)
    &#34;&#34;&#34;
    extras = [&#34;footnotes&#34;, &#34;fenced-code-blocks&#34;]


# ---- internal support functions


def calculate_toc_html(toc):
    &#34;&#34;&#34;Return the HTML for the current TOC.

    This expects the `_toc` attribute to have been set on this instance.
    &#34;&#34;&#34;
    if toc is None:
        return None

    def indent():
        return &#39;  &#39; * (len(h_stack) - 1)
    lines = []
    h_stack = [0]   # stack of header-level numbers
    for level, id, name in toc:
        if level &gt; h_stack[-1]:
            lines.append(&#34;%s&lt;ul&gt;&#34; % indent())
            h_stack.append(level)
        elif level == h_stack[-1]:
            lines[-1] += &#34;&lt;/li&gt;&#34;
        else:
            while level &lt; h_stack[-1]:
                h_stack.pop()
                if not lines[-1].endswith(&#34;&lt;/li&gt;&#34;):
                    lines[-1] += &#34;&lt;/li&gt;&#34;
                lines.append(&#34;%s&lt;/ul&gt;&lt;/li&gt;&#34; % indent())
        lines.append(&#39;%s&lt;li&gt;&lt;a href=&#34;#%s&#34;&gt;%s&lt;/a&gt;&#39; % (
            indent(), id, name))
    while len(h_stack) &gt; 1:
        h_stack.pop()
        if not lines[-1].endswith(&#34;&lt;/li&gt;&#34;):
            lines[-1] += &#34;&lt;/li&gt;&#34;
        lines.append(&#34;%s&lt;/ul&gt;&#34; % indent())
    return &#39;\n&#39;.join(lines) + &#39;\n&#39;


class UnicodeWithAttrs(str):
    &#34;&#34;&#34;A subclass of unicode used for the return value of conversion to
    possibly attach some attributes. E.g. the &#34;toc_html&#34; attribute when
    the &#34;toc&#34; extra is used.
    &#34;&#34;&#34;
    metadata = None
    toc_html = None

## {{{ http://code.activestate.com/recipes/577257/ (r1)
_slugify_strip_re = re.compile(r&#39;[^\w\s-]&#39;)
_slugify_hyphenate_re = re.compile(r&#39;[-\s]+&#39;)
def _slugify(value):
    &#34;&#34;&#34;
    Normalizes string, converts to lowercase, removes non-alpha characters,
    and converts spaces to hyphens.

    From Django&#39;s &#34;django/template/defaultfilters.py&#34;.
    &#34;&#34;&#34;
    import unicodedata
    value = unicodedata.normalize(&#39;NFKD&#39;, value).encode(&#39;ascii&#39;, &#39;ignore&#39;).decode()
    value = _slugify_strip_re.sub(&#39;&#39;, value).strip().lower()
    return _slugify_hyphenate_re.sub(&#39;-&#39;, value)
## end of http://code.activestate.com/recipes/577257/ }}}


# From http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52549
def _curry(*args, **kwargs):
    function, args = args[0], args[1:]
    def result(*rest, **kwrest):
        combined = kwargs.copy()
        combined.update(kwrest)
        return function(*args + rest, **combined)
    return result


# Recipe: regex_from_encoded_pattern (1.0)
def _regex_from_encoded_pattern(s):
    &#34;&#34;&#34;&#39;foo&#39;    -&gt; re.compile(re.escape(&#39;foo&#39;))
       &#39;/foo/&#39;  -&gt; re.compile(&#39;foo&#39;)
       &#39;/foo/i&#39; -&gt; re.compile(&#39;foo&#39;, re.I)
    &#34;&#34;&#34;
    if s.startswith(&#39;/&#39;) and s.rfind(&#39;/&#39;) != 0:
        # Parse it: /PATTERN/FLAGS
        idx = s.rfind(&#39;/&#39;)
        _, flags_str = s[1:idx], s[idx+1:]
        flag_from_char = {
            &#34;i&#34;: re.IGNORECASE,
            &#34;l&#34;: re.LOCALE,
            &#34;s&#34;: re.DOTALL,
            &#34;m&#34;: re.MULTILINE,
            &#34;u&#34;: re.UNICODE,
        }
        flags = 0
        for char in flags_str:
            try:
                flags |= flag_from_char[char]
            except KeyError:
                raise ValueError(&#34;unsupported regex flag: &#39;%s&#39; in &#39;%s&#39; &#34;
                                 &#34;(must be one of &#39;%s&#39;)&#34;
                                 % (char, s, &#39;&#39;.join(list(flag_from_char.keys()))))
        return re.compile(s[1:idx], flags)
    else:  # not an encoded regex
        return re.compile(re.escape(s))


# Recipe: dedent (0.1.2)
def _dedentlines(lines, tabsize=8, skip_first_line=False):
    &#34;&#34;&#34;_dedentlines(lines, tabsize=8, skip_first_line=False) -&gt; dedented lines

        &#34;lines&#34; is a list of lines to dedent.
        &#34;tabsize&#34; is the tab width to use for indent width calculations.
        &#34;skip_first_line&#34; is a boolean indicating if the first line should
            be skipped for calculating the indent width and for dedenting.
            This is sometimes useful for docstrings and similar.

    Same as dedent() except operates on a sequence of lines. Note: the
    lines list is modified **in-place**.
    &#34;&#34;&#34;
    DEBUG = False
    if DEBUG:
        print(&#34;dedent: dedent(..., tabsize=%d, skip_first_line=%r)&#34;\
              % (tabsize, skip_first_line))
    margin = None
    for i, line in enumerate(lines):
        if i == 0 and skip_first_line: continue
        indent = 0
        for ch in line:
            if ch == &#39; &#39;:
                indent += 1
            elif ch == &#39;\t&#39;:
                indent += tabsize - (indent % tabsize)
            elif ch in &#39;\r\n&#39;:
                continue  # skip all-whitespace lines
            else:
                break
        else:
            continue  # skip all-whitespace lines
        if DEBUG: print(&#34;dedent: indent=%d: %r&#34; % (indent, line))
        if margin is None:
            margin = indent
        else:
            margin = min(margin, indent)
    if DEBUG: print(&#34;dedent: margin=%r&#34; % margin)

    if margin is not None and margin &gt; 0:
        for i, line in enumerate(lines):
            if i == 0 and skip_first_line: continue
            removed = 0
            for j, ch in enumerate(line):
                if ch == &#39; &#39;:
                    removed += 1
                elif ch == &#39;\t&#39;:
                    removed += tabsize - (removed % tabsize)
                elif ch in &#39;\r\n&#39;:
                    if DEBUG: print(&#34;dedent: %r: EOL -&gt; strip up to EOL&#34; % line)
                    lines[i] = lines[i][j:]
                    break
                else:
                    raise ValueError(&#34;unexpected non-whitespace char %r in &#34;
                                     &#34;line %r while removing %d-space margin&#34;
                                     % (ch, line, margin))
                if DEBUG:
                    print(&#34;dedent: %r: %r -&gt; removed %d/%d&#34;\
                          % (line, ch, removed, margin))
                if removed == margin:
                    lines[i] = lines[i][j+1:]
                    break
                elif removed &gt; margin:
                    lines[i] = &#39; &#39;*(removed-margin) + lines[i][j+1:]
                    break
            else:
                if removed:
                    lines[i] = lines[i][removed:]
    return lines


def _dedent(text, tabsize=8, skip_first_line=False):
    &#34;&#34;&#34;_dedent(text, tabsize=8, skip_first_line=False) -&gt; dedented text

        &#34;text&#34; is the text to dedent.
        &#34;tabsize&#34; is the tab width to use for indent width calculations.
        &#34;skip_first_line&#34; is a boolean indicating if the first line should
            be skipped for calculating the indent width and for dedenting.
            This is sometimes useful for docstrings and similar.

    textwrap.dedent(s), but don&#39;t expand tabs to spaces
    &#34;&#34;&#34;
    lines = text.splitlines(1)
    _dedentlines(lines, tabsize=tabsize, skip_first_line=skip_first_line)
    return &#39;&#39;.join(lines)


class _memoized(object):
    &#34;&#34;&#34;Decorator that caches a function&#39;s return value each time it is called.
    If called later with the same arguments, the cached value is returned, and
    not re-evaluated.

    http://wiki.python.org/moin/PythonDecoratorLibrary
    &#34;&#34;&#34;
    def __init__(self, func):
        self.func = func
        self.cache = {}

    def __call__(self, *args):
        try:
            return self.cache[args]
        except KeyError:
            self.cache[args] = value = self.func(*args)
            return value
        except TypeError:
            # uncachable -- for instance, passing a list as an argument.
            # Better to not cache than to blow up entirely.
            return self.func(*args)

    def __repr__(self):
        &#34;&#34;&#34;Return the function&#39;s docstring.&#34;&#34;&#34;
        return self.func.__doc__


def _xml_oneliner_re_from_tab_width(tab_width):
    &#34;&#34;&#34;Standalone XML processing instruction regex.&#34;&#34;&#34;
    return re.compile(r&#34;&#34;&#34;
        (?:
            (?&lt;=\n\n)       # Starting after a blank line
            |               # or
            \A\n?           # the beginning of the doc
        )
        (                           # save in $1
            [ ]{0,%d}
            (?:
                &lt;\?\w+\b\s+.*?\?&gt;   # XML processing instruction
                |
                &lt;\w+:\w+\b\s+.*?/&gt;  # namespaced single tag
            )
            [ \t]*
            (?=\n{2,}|\Z)       # followed by a blank line or end of document
        )
        &#34;&#34;&#34; % (tab_width - 1), re.X)
_xml_oneliner_re_from_tab_width = _memoized(_xml_oneliner_re_from_tab_width)


def _hr_tag_re_from_tab_width(tab_width):
    return re.compile(r&#34;&#34;&#34;
        (?:
            (?&lt;=\n\n)       # Starting after a blank line
            |               # or
            \A\n?           # the beginning of the doc
        )
        (                       # save in \1
            [ ]{0,%d}
            &lt;(hr)               # start tag = \2
            \b                  # word break
            ([^&lt;&gt;])*?           #
            /?&gt;                 # the matching end tag
            [ \t]*
            (?=\n{2,}|\Z)       # followed by a blank line or end of document
        )
        &#34;&#34;&#34; % (tab_width - 1), re.X)
_hr_tag_re_from_tab_width = _memoized(_hr_tag_re_from_tab_width)


def _xml_escape_attr(attr, skip_single_quote=True):
    &#34;&#34;&#34;Escape the given string for use in an HTML/XML tag attribute.

    By default this doesn&#39;t bother with escaping `&#39;` to `&amp;#39;`, presuming that
    the tag attribute is surrounded by double quotes.
    &#34;&#34;&#34;
    escaped = _AMPERSAND_RE.sub(&#39;&amp;amp;&#39;, attr)

    escaped = (attr
        .replace(&#39;&#34;&#39;, &#39;&amp;quot;&#39;)
        .replace(&#39;&lt;&#39;, &#39;&amp;lt;&#39;)
        .replace(&#39;&gt;&#39;, &#39;&amp;gt;&#39;))
    if not skip_single_quote:
        escaped = escaped.replace(&#34;&#39;&#34;, &#34;&amp;#39;&#34;)
    return escaped


def _xml_encode_email_char_at_random(ch):
    r = random()
    # Roughly 10% raw, 45% hex, 45% dec.
    # &#39;@&#39; *must* be encoded. I [John Gruber] insist.
    # Issue 26: &#39;_&#39; must be encoded.
    if r &gt; 0.9 and ch not in &#34;@_&#34;:
        return ch
    elif r &lt; 0.45:
        # The [1:] is to drop leading &#39;0&#39;: 0x63 -&gt; x63
        return &#39;&amp;#%s;&#39; % hex(ord(ch))[1:]
    else:
        return &#39;&amp;#%s;&#39; % ord(ch)


def _html_escape_url(attr, safe_mode=False):
    &#34;&#34;&#34;Replace special characters that are potentially malicious in url string.&#34;&#34;&#34;
    escaped = (attr
        .replace(&#39;&#34;&#39;, &#39;&amp;quot;&#39;)
        .replace(&#39;&lt;&#39;, &#39;&amp;lt;&#39;)
        .replace(&#39;&gt;&#39;, &#39;&amp;gt;&#39;))
    if safe_mode:
        escaped = escaped.replace(&#39;+&#39;, &#39; &#39;)
        escaped = escaped.replace(&#34;&#39;&#34;, &#34;&amp;#39;&#34;)
    return escaped


# ---- mainline

class _NoReflowFormatter(argparse.RawDescriptionHelpFormatter):
    &#34;&#34;&#34;An argparse formatter that does NOT reflow the description.&#34;&#34;&#34;
    def format_description(self, description):
        return description or &#34;&#34;


def _test():
    import doctest
    doctest.testmod()


def main(argv=None):
    if argv is None:
        argv = sys.argv
    if not logging.root.handlers:
        logging.basicConfig()

    parser = argparse.ArgumentParser(
        prog=&#34;markdown2&#34;, description=cmdln_desc, usage=&#39;%(prog)s [PATHS...]&#39;,
        formatter_class=_NoReflowFormatter
    )
    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;,
                        version=&#39;%(prog)s {version}&#39;.format(version=__version__))
    parser.add_argument(&#39;paths&#39;, nargs=&#39;*&#39;,
                        help=(
                            &#39;optional list of files to convert.&#39;
                            &#39;If none are given, stdin will be used&#39;
                        ))
    parser.add_argument(&#34;-v&#34;, &#34;--verbose&#34;, dest=&#34;log_level&#34;,
                      action=&#34;store_const&#34;, const=logging.DEBUG,
                      help=&#34;more verbose output&#34;)
    parser.add_argument(&#34;--encoding&#34;,
                      help=&#34;specify encoding of text content&#34;)
    parser.add_argument(&#34;--html4tags&#34;, action=&#34;store_true&#34;, default=False,
                      help=&#34;use HTML 4 style for empty element tags&#34;)
    parser.add_argument(&#34;-s&#34;, &#34;--safe&#34;, metavar=&#34;MODE&#34;, dest=&#34;safe_mode&#34;,
                      help=&#34;sanitize literal HTML: &#39;escape&#39; escapes &#34;
                           &#34;HTML meta chars, &#39;replace&#39; replaces with an &#34;
                           &#34;[HTML_REMOVED] note&#34;)
    parser.add_argument(&#34;-x&#34;, &#34;--extras&#34;, action=&#34;append&#34;,
                      help=&#34;Turn on specific extra features (not part of &#34;
                           &#34;the core Markdown spec). See above.&#34;)
    parser.add_argument(&#34;--use-file-vars&#34;,
                      help=&#34;Look for and use Emacs-style &#39;markdown-extras&#39; &#34;
                           &#34;file var to turn on extras. See &#34;
                           &#34;&lt;https://github.com/trentm/python-markdown2/wiki/Extras&gt;&#34;)
    parser.add_argument(&#34;--link-patterns-file&#34;,
                      help=&#34;path to a link pattern file&#34;)
    parser.add_argument(&#34;--self-test&#34;, action=&#34;store_true&#34;,
                      help=&#34;run internal self-tests (some doctests)&#34;)
    parser.add_argument(&#34;--compare&#34;, action=&#34;store_true&#34;,
                      help=&#34;run against Markdown.pl as well (for testing)&#34;)
    parser.set_defaults(log_level=logging.INFO, compare=False,
                        encoding=&#34;utf-8&#34;, safe_mode=None, use_file_vars=False)
    opts = parser.parse_args()
    paths = opts.paths
    log.setLevel(opts.log_level)

    if opts.self_test:
        return _test()

    if opts.extras:
        extras = {}
        for s in opts.extras:
            splitter = re.compile(&#34;[,;: ]+&#34;)
            for e in splitter.split(s):
                if &#39;=&#39; in e:
                    ename, earg = e.split(&#39;=&#39;, 1)
                    try:
                        earg = int(earg)
                    except ValueError:
                        pass
                else:
                    ename, earg = e, None
                extras[ename] = earg
    else:
        extras = None

    if opts.link_patterns_file:
        link_patterns = []
        f = open(opts.link_patterns_file)
        try:
            for i, line in enumerate(f.readlines()):
                if not line.strip(): continue
                if line.lstrip().startswith(&#34;#&#34;): continue
                try:
                    pat, href = line.rstrip().rsplit(None, 1)
                except ValueError:
                    raise MarkdownError(&#34;%s:%d: invalid link pattern line: %r&#34;
                                        % (opts.link_patterns_file, i+1, line))
                link_patterns.append(
                    (_regex_from_encoded_pattern(pat), href))
        finally:
            f.close()
    else:
        link_patterns = None

    from os.path import abspath, dirname, exists, join
    markdown_pl = join(dirname(dirname(abspath(__file__))), &#34;test&#34;,
                       &#34;Markdown.pl&#34;)
    if not paths:
        paths = [&#39;-&#39;]
    for path in paths:
        if path == &#39;-&#39;:
            text = sys.stdin.read()
        else:
            fp = codecs.open(path, &#39;r&#39;, opts.encoding)
            text = fp.read()
            fp.close()
        if opts.compare:
            from subprocess import PIPE, Popen
            print(&#34;==== Markdown.pl ====&#34;)
            p = Popen(&#39;perl %s&#39; % markdown_pl, shell=True, stdin=PIPE, stdout=PIPE, close_fds=True)
            p.stdin.write(text.encode(&#39;utf-8&#39;))
            p.stdin.close()
            perl_html = p.stdout.read().decode(&#39;utf-8&#39;)
            sys.stdout.write(perl_html)
            print(&#34;==== markdown2.py ====&#34;)
        html = markdown(text,
            html4tags=opts.html4tags,
            safe_mode=opts.safe_mode,
            extras=extras, link_patterns=link_patterns,
            use_file_vars=opts.use_file_vars,
            cli=True)
        sys.stdout.write(html)
        if extras and &#34;toc&#34; in extras:
            log.debug(&#34;toc_html: &#34; +
                str(html.toc_html.encode(sys.stdout.encoding or &#34;utf-8&#34;, &#39;xmlcharrefreplace&#39;)))
        if opts.compare:
            test_dir = join(dirname(dirname(abspath(__file__))), &#34;test&#34;)
            if exists(join(test_dir, &#34;test_markdown2.py&#34;)):
                sys.path.insert(0, test_dir)
                from test_markdown2 import norm_html_from_html
                norm_html = norm_html_from_html(html)
                norm_perl_html = norm_html_from_html(perl_html)
            else:
                norm_html = html
                norm_perl_html = perl_html
            print(&#34;==== match? %r ====&#34; % (norm_perl_html == norm_html))


if __name__ == &#34;__main__&#34;:
    sys.exit(main(sys.argv))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pdoc.markdown2.calculate_toc_html"><code class="name flex">
<span>def <span class="ident">calculate_toc_html</span></span>(<span>toc)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the HTML for the current TOC.</p>
<p>This expects the <code>_toc</code> attribute to have been set on this instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_toc_html(toc):
    &#34;&#34;&#34;Return the HTML for the current TOC.

    This expects the `_toc` attribute to have been set on this instance.
    &#34;&#34;&#34;
    if toc is None:
        return None

    def indent():
        return &#39;  &#39; * (len(h_stack) - 1)
    lines = []
    h_stack = [0]   # stack of header-level numbers
    for level, id, name in toc:
        if level &gt; h_stack[-1]:
            lines.append(&#34;%s&lt;ul&gt;&#34; % indent())
            h_stack.append(level)
        elif level == h_stack[-1]:
            lines[-1] += &#34;&lt;/li&gt;&#34;
        else:
            while level &lt; h_stack[-1]:
                h_stack.pop()
                if not lines[-1].endswith(&#34;&lt;/li&gt;&#34;):
                    lines[-1] += &#34;&lt;/li&gt;&#34;
                lines.append(&#34;%s&lt;/ul&gt;&lt;/li&gt;&#34; % indent())
        lines.append(&#39;%s&lt;li&gt;&lt;a href=&#34;#%s&#34;&gt;%s&lt;/a&gt;&#39; % (
            indent(), id, name))
    while len(h_stack) &gt; 1:
        h_stack.pop()
        if not lines[-1].endswith(&#34;&lt;/li&gt;&#34;):
            lines[-1] += &#34;&lt;/li&gt;&#34;
        lines.append(&#34;%s&lt;/ul&gt;&#34; % indent())
    return &#39;\n&#39;.join(lines) + &#39;\n&#39;</code></pre>
</details>
</dd>
<dt id="pdoc.markdown2.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>argv=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(argv=None):
    if argv is None:
        argv = sys.argv
    if not logging.root.handlers:
        logging.basicConfig()

    parser = argparse.ArgumentParser(
        prog=&#34;markdown2&#34;, description=cmdln_desc, usage=&#39;%(prog)s [PATHS...]&#39;,
        formatter_class=_NoReflowFormatter
    )
    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;,
                        version=&#39;%(prog)s {version}&#39;.format(version=__version__))
    parser.add_argument(&#39;paths&#39;, nargs=&#39;*&#39;,
                        help=(
                            &#39;optional list of files to convert.&#39;
                            &#39;If none are given, stdin will be used&#39;
                        ))
    parser.add_argument(&#34;-v&#34;, &#34;--verbose&#34;, dest=&#34;log_level&#34;,
                      action=&#34;store_const&#34;, const=logging.DEBUG,
                      help=&#34;more verbose output&#34;)
    parser.add_argument(&#34;--encoding&#34;,
                      help=&#34;specify encoding of text content&#34;)
    parser.add_argument(&#34;--html4tags&#34;, action=&#34;store_true&#34;, default=False,
                      help=&#34;use HTML 4 style for empty element tags&#34;)
    parser.add_argument(&#34;-s&#34;, &#34;--safe&#34;, metavar=&#34;MODE&#34;, dest=&#34;safe_mode&#34;,
                      help=&#34;sanitize literal HTML: &#39;escape&#39; escapes &#34;
                           &#34;HTML meta chars, &#39;replace&#39; replaces with an &#34;
                           &#34;[HTML_REMOVED] note&#34;)
    parser.add_argument(&#34;-x&#34;, &#34;--extras&#34;, action=&#34;append&#34;,
                      help=&#34;Turn on specific extra features (not part of &#34;
                           &#34;the core Markdown spec). See above.&#34;)
    parser.add_argument(&#34;--use-file-vars&#34;,
                      help=&#34;Look for and use Emacs-style &#39;markdown-extras&#39; &#34;
                           &#34;file var to turn on extras. See &#34;
                           &#34;&lt;https://github.com/trentm/python-markdown2/wiki/Extras&gt;&#34;)
    parser.add_argument(&#34;--link-patterns-file&#34;,
                      help=&#34;path to a link pattern file&#34;)
    parser.add_argument(&#34;--self-test&#34;, action=&#34;store_true&#34;,
                      help=&#34;run internal self-tests (some doctests)&#34;)
    parser.add_argument(&#34;--compare&#34;, action=&#34;store_true&#34;,
                      help=&#34;run against Markdown.pl as well (for testing)&#34;)
    parser.set_defaults(log_level=logging.INFO, compare=False,
                        encoding=&#34;utf-8&#34;, safe_mode=None, use_file_vars=False)
    opts = parser.parse_args()
    paths = opts.paths
    log.setLevel(opts.log_level)

    if opts.self_test:
        return _test()

    if opts.extras:
        extras = {}
        for s in opts.extras:
            splitter = re.compile(&#34;[,;: ]+&#34;)
            for e in splitter.split(s):
                if &#39;=&#39; in e:
                    ename, earg = e.split(&#39;=&#39;, 1)
                    try:
                        earg = int(earg)
                    except ValueError:
                        pass
                else:
                    ename, earg = e, None
                extras[ename] = earg
    else:
        extras = None

    if opts.link_patterns_file:
        link_patterns = []
        f = open(opts.link_patterns_file)
        try:
            for i, line in enumerate(f.readlines()):
                if not line.strip(): continue
                if line.lstrip().startswith(&#34;#&#34;): continue
                try:
                    pat, href = line.rstrip().rsplit(None, 1)
                except ValueError:
                    raise MarkdownError(&#34;%s:%d: invalid link pattern line: %r&#34;
                                        % (opts.link_patterns_file, i+1, line))
                link_patterns.append(
                    (_regex_from_encoded_pattern(pat), href))
        finally:
            f.close()
    else:
        link_patterns = None

    from os.path import abspath, dirname, exists, join
    markdown_pl = join(dirname(dirname(abspath(__file__))), &#34;test&#34;,
                       &#34;Markdown.pl&#34;)
    if not paths:
        paths = [&#39;-&#39;]
    for path in paths:
        if path == &#39;-&#39;:
            text = sys.stdin.read()
        else:
            fp = codecs.open(path, &#39;r&#39;, opts.encoding)
            text = fp.read()
            fp.close()
        if opts.compare:
            from subprocess import PIPE, Popen
            print(&#34;==== Markdown.pl ====&#34;)
            p = Popen(&#39;perl %s&#39; % markdown_pl, shell=True, stdin=PIPE, stdout=PIPE, close_fds=True)
            p.stdin.write(text.encode(&#39;utf-8&#39;))
            p.stdin.close()
            perl_html = p.stdout.read().decode(&#39;utf-8&#39;)
            sys.stdout.write(perl_html)
            print(&#34;==== markdown2.py ====&#34;)
        html = markdown(text,
            html4tags=opts.html4tags,
            safe_mode=opts.safe_mode,
            extras=extras, link_patterns=link_patterns,
            use_file_vars=opts.use_file_vars,
            cli=True)
        sys.stdout.write(html)
        if extras and &#34;toc&#34; in extras:
            log.debug(&#34;toc_html: &#34; +
                str(html.toc_html.encode(sys.stdout.encoding or &#34;utf-8&#34;, &#39;xmlcharrefreplace&#39;)))
        if opts.compare:
            test_dir = join(dirname(dirname(abspath(__file__))), &#34;test&#34;)
            if exists(join(test_dir, &#34;test_markdown2.py&#34;)):
                sys.path.insert(0, test_dir)
                from test_markdown2 import norm_html_from_html
                norm_html = norm_html_from_html(html)
                norm_perl_html = norm_html_from_html(perl_html)
            else:
                norm_html = html
                norm_perl_html = perl_html
            print(&#34;==== match? %r ====&#34; % (norm_perl_html == norm_html))</code></pre>
</details>
</dd>
<dt id="pdoc.markdown2.markdown"><code class="name flex">
<span>def <span class="ident">markdown</span></span>(<span>text, html4tags=False, tab_width=4, safe_mode=None, extras=None, link_patterns=None, footnote_title=None, footnote_return_symbol=None, use_file_vars=False, cli=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markdown(text, html4tags=False, tab_width=DEFAULT_TAB_WIDTH,
             safe_mode=None, extras=None, link_patterns=None,
             footnote_title=None, footnote_return_symbol=None,
             use_file_vars=False, cli=False):
    return Markdown(html4tags=html4tags, tab_width=tab_width,
                    safe_mode=safe_mode, extras=extras,
                    link_patterns=link_patterns,
                    footnote_title=footnote_title,
                    footnote_return_symbol=footnote_return_symbol,
                    use_file_vars=use_file_vars, cli=cli).convert(text)</code></pre>
</details>
</dd>
<dt id="pdoc.markdown2.markdown_path"><code class="name flex">
<span>def <span class="ident">markdown_path</span></span>(<span>path, encoding='utf-8', html4tags=False, tab_width=4, safe_mode=None, extras=None, link_patterns=None, footnote_title=None, footnote_return_symbol=None, use_file_vars=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markdown_path(path, encoding=&#34;utf-8&#34;,
                  html4tags=False, tab_width=DEFAULT_TAB_WIDTH,
                  safe_mode=None, extras=None, link_patterns=None,
                  footnote_title=None, footnote_return_symbol=None,
                  use_file_vars=False):
    fp = codecs.open(path, &#39;r&#39;, encoding)
    text = fp.read()
    fp.close()
    return Markdown(html4tags=html4tags, tab_width=tab_width,
                    safe_mode=safe_mode, extras=extras,
                    link_patterns=link_patterns,
                    footnote_title=footnote_title,
                    footnote_return_symbol=footnote_return_symbol,
                    use_file_vars=use_file_vars).convert(text)</code></pre>
</details>
</dd>
<dt id="pdoc.markdown2.random"><code class="name flex">
<span>def <span class="ident">random</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>random() -&gt; x in the interval [0, 1).</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pdoc.markdown2.Markdown"><code class="flex name class">
<span>class <span class="ident">Markdown</span></span>
<span>(</span><span>html4tags=False, tab_width=4, safe_mode=None, extras=None, link_patterns=None, footnote_title=None, footnote_return_symbol=None, use_file_vars=False, cli=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Markdown(object):
    # The dict of &#34;extras&#34; to enable in processing -- a mapping of
    # extra name to argument for the extra. Most extras do not have an
    # argument, in which case the value is None.
    #
    # This can be set via (a) subclassing and (b) the constructor
    # &#34;extras&#34; argument.
    extras = None

    urls = None
    titles = None
    html_blocks = None
    html_spans = None
    html_removed_text = &#34;{(#HTML#)}&#34;  # placeholder removed text that does not trigger bold
    html_removed_text_compat = &#34;[HTML_REMOVED]&#34;  # for compat with markdown.py

    _toc = None

    # Used to track when we&#39;re inside an ordered or unordered list
    # (see _ProcessListItems() for details):
    list_level = 0

    _ws_only_line_re = re.compile(r&#34;^[ \t]+$&#34;, re.M)

    def __init__(self, html4tags=False, tab_width=4, safe_mode=None,
                 extras=None, link_patterns=None,
                 footnote_title=None, footnote_return_symbol=None,
                 use_file_vars=False, cli=False):
        if html4tags:
            self.empty_element_suffix = &#34;&gt;&#34;
        else:
            self.empty_element_suffix = &#34; /&gt;&#34;
        self.tab_width = tab_width
        self.tab = tab_width * &#34; &#34;

        # For compatibility with earlier markdown2.py and with
        # markdown.py&#39;s safe_mode being a boolean,
        #   safe_mode == True -&gt; &#34;replace&#34;
        if safe_mode is True:
            self.safe_mode = &#34;replace&#34;
        else:
            self.safe_mode = safe_mode

        # Massaging and building the &#34;extras&#34; info.
        if self.extras is None:
            self.extras = {}
        elif not isinstance(self.extras, dict):
            self.extras = dict([(e, None) for e in self.extras])
        if extras:
            if not isinstance(extras, dict):
                extras = dict([(e, None) for e in extras])
            self.extras.update(extras)
        assert isinstance(self.extras, dict)

        if &#34;toc&#34; in self.extras:
            if &#34;header-ids&#34; not in self.extras:
                self.extras[&#34;header-ids&#34;] = None   # &#34;toc&#34; implies &#34;header-ids&#34;

            if self.extras[&#34;toc&#34;] is None:
                self._toc_depth = 6
            else:
                self._toc_depth = self.extras[&#34;toc&#34;].get(&#34;depth&#34;, 6)
        self._instance_extras = self.extras.copy()

        if &#39;link-patterns&#39; in self.extras:
            if link_patterns is None:
                # if you have specified that the link-patterns extra SHOULD
                # be used (via self.extras) but you haven&#39;t provided anything
                # via the link_patterns argument then an error is raised
                raise MarkdownError(&#34;If the &#39;link-patterns&#39; extra is used, an argument for &#39;link_patterns&#39; is required&#34;)
        self.link_patterns = link_patterns
        self.footnote_title = footnote_title
        self.footnote_return_symbol = footnote_return_symbol
        self.use_file_vars = use_file_vars
        self._outdent_re = re.compile(r&#39;^(\t|[ ]{1,%d})&#39; % tab_width, re.M)
        self.cli = cli

        self._escape_table = g_escape_table.copy()
        self._code_table = {}
        if &#34;smarty-pants&#34; in self.extras:
            self._escape_table[&#39;&#34;&#39;] = _hash_text(&#39;&#34;&#39;)
            self._escape_table[&#34;&#39;&#34;] = _hash_text(&#34;&#39;&#34;)

    def reset(self):
        self.urls = {}
        self.titles = {}
        self.html_blocks = {}
        self.html_spans = {}
        self.list_level = 0
        self.extras = self._instance_extras.copy()
        self._setup_extras()
        self._toc = None

    def _setup_extras(self):
        if &#34;footnotes&#34; in self.extras:
            self.footnotes = {}
            self.footnote_ids = []
        if &#34;header-ids&#34; in self.extras:
            self._count_from_header_id = defaultdict(int)
        if &#34;metadata&#34; in self.extras:
            self.metadata = {}

    # Per &lt;https://developer.mozilla.org/en-US/docs/HTML/Element/a&gt; &#34;rel&#34;
    # should only be used in &lt;a&gt; tags with an &#34;href&#34; attribute.

    # Opens the linked document in a new window or tab
    # should only used in &lt;a&gt; tags with an &#34;href&#34; attribute.
    # same with _a_nofollow
    _a_nofollow_or_blank_links = re.compile(r&#34;&#34;&#34;
        &lt;(a)
        (
            [^&gt;]*
            href=   # href is required
            [&#39;&#34;]?   # HTML5 attribute values do not have to be quoted
            [^#&#39;&#34;]  # We don&#39;t want to match href values that start with # (like footnotes)
        )
        &#34;&#34;&#34;,
        re.IGNORECASE | re.VERBOSE
    )

    def convert(self, text):
        &#34;&#34;&#34;Convert the given text.&#34;&#34;&#34;
        # Main function. The order in which other subs are called here is
        # essential. Link and image substitutions need to happen before
        # _EscapeSpecialChars(), so that any *&#39;s or _&#39;s in the &lt;a&gt;
        # and &lt;img&gt; tags get encoded.

        # Clear the global hashes. If we don&#39;t clear these, you get conflicts
        # from other articles when generating a page which contains more than
        # one article (e.g. an index page that shows the N most recent
        # articles):
        self.reset()

        if not isinstance(text, str):
            # TODO: perhaps shouldn&#39;t presume UTF-8 for string input?
            text = str(text, &#39;utf-8&#39;)

        if self.use_file_vars:
            # Look for emacs-style file variable hints.
            text = self._emacs_oneliner_vars_pat.sub(self._emacs_vars_oneliner_sub, text)
            emacs_vars = self._get_emacs_vars(text)
            if &#34;markdown-extras&#34; in emacs_vars:
                splitter = re.compile(&#34;[ ,]+&#34;)
                for e in splitter.split(emacs_vars[&#34;markdown-extras&#34;]):
                    if &#39;=&#39; in e:
                        ename, earg = e.split(&#39;=&#39;, 1)
                        try:
                            earg = int(earg)
                        except ValueError:
                            pass
                    else:
                        ename, earg = e, None
                    self.extras[ename] = earg

            self._setup_extras()

        # Standardize line endings:
        text = text.replace(&#34;\r\n&#34;, &#34;\n&#34;)
        text = text.replace(&#34;\r&#34;, &#34;\n&#34;)

        # Make sure $text ends with a couple of newlines:
        text += &#34;\n\n&#34;

        # Convert all tabs to spaces.
        text = self._detab(text)

        # Strip any lines consisting only of spaces and tabs.
        # This makes subsequent regexen easier to write, because we can
        # match consecutive blank lines with /\n+/ instead of something
        # contorted like /[ \t]*\n+/ .
        text = self._ws_only_line_re.sub(&#34;&#34;, text)

        # strip metadata from head and extract
        if &#34;metadata&#34; in self.extras:
            text = self._extract_metadata(text)

        text = self.preprocess(text)

        if &#39;wavedrom&#39; in self.extras:
            text = self._do_wavedrom_blocks(text)

        if &#34;fenced-code-blocks&#34; in self.extras and not self.safe_mode:
            text = self._do_fenced_code_blocks(text)

        if self.safe_mode:
            text = self._hash_html_spans(text)

        # Turn block-level HTML blocks into hash entries
        text = self._hash_html_blocks(text, raw=True)

        if &#34;fenced-code-blocks&#34; in self.extras and self.safe_mode:
            text = self._do_fenced_code_blocks(text)

        if &#39;admonitions&#39; in self.extras:
            text = self._do_admonitions(text)

        # Because numbering references aren&#39;t links (yet?) then we can do everything associated with counters
        # before we get started
        if &#34;numbering&#34; in self.extras:
            text = self._do_numbering(text)

        # Strip link definitions, store in hashes.
        if &#34;footnotes&#34; in self.extras:
            # Must do footnotes first because an unlucky footnote defn
            # looks like a link defn:
            #   [^4]: this &#34;looks like a link defn&#34;
            text = self._strip_footnote_definitions(text)
        text = self._strip_link_definitions(text)

        text = self._run_block_gamut(text)

        if &#34;footnotes&#34; in self.extras:
            text = self._add_footnotes(text)

        text = self.postprocess(text)

        text = self._unescape_special_chars(text)

        if self.safe_mode:
            text = self._unhash_html_spans(text)
            # return the removed text warning to its markdown.py compatible form
            text = text.replace(self.html_removed_text, self.html_removed_text_compat)

        do_target_blank_links = &#34;target-blank-links&#34; in self.extras
        do_nofollow_links = &#34;nofollow&#34; in self.extras

        if do_target_blank_links and do_nofollow_links:
            text = self._a_nofollow_or_blank_links.sub(r&#39;&lt;\1 rel=&#34;nofollow noopener&#34; target=&#34;_blank&#34;\2&#39;, text)
        elif do_target_blank_links:
            text = self._a_nofollow_or_blank_links.sub(r&#39;&lt;\1 rel=&#34;noopener&#34; target=&#34;_blank&#34;\2&#39;, text)
        elif do_nofollow_links:
            text = self._a_nofollow_or_blank_links.sub(r&#39;&lt;\1 rel=&#34;nofollow&#34;\2&#39;, text)

        if &#34;toc&#34; in self.extras and self._toc:
            self._toc_html = calculate_toc_html(self._toc)

            # Prepend toc html to output
            if self.cli:
                text = &#39;{}\n{}&#39;.format(self._toc_html, text)

        text += &#34;\n&#34;

        # Attach attrs to output
        rv = UnicodeWithAttrs(text)

        if &#34;toc&#34; in self.extras and self._toc:
            rv.toc_html = self._toc_html

        if &#34;metadata&#34; in self.extras:
            rv.metadata = self.metadata
        return rv

    def postprocess(self, text):
        &#34;&#34;&#34;A hook for subclasses to do some postprocessing of the html, if
        desired. This is called before unescaping of special chars and
        unhashing of raw HTML spans.
        &#34;&#34;&#34;
        return text

    def preprocess(self, text):
        &#34;&#34;&#34;A hook for subclasses to do some preprocessing of the Markdown, if
        desired. This is called after basic formatting of the text, but prior
        to any extras, safe mode, etc. processing.
        &#34;&#34;&#34;
        return text

    # Is metadata if the content starts with optional &#39;---&#39;-fenced `key: value`
    # pairs. E.g. (indented for presentation):
    #   ---
    #   foo: bar
    #   another-var: blah blah
    #   ---
    #   # header
    # or:
    #   foo: bar
    #   another-var: blah blah
    #
    #   # header
    _meta_data_pattern = re.compile(r&#39;&#39;&#39;
        ^{0}(  # optional opening fence
            (?:
                {1}:(?:\n+[ \t]+.*)+  # indented lists
            )|(?:
                (?:{1}:\s+&gt;(?:\n\s+.*)+?)  # multiline long descriptions
                (?=\n{1}:\s*.*\n|\s*\Z)  # match up until the start of the next key:value definition or the end of the input text
            )|(?:
                {1}:(?! &gt;).*\n?  # simple key:value pair, leading spaces allowed
            )
        ){0}  # optional closing fence
        &#39;&#39;&#39;.format(r&#39;(?:---[\ \t]*\n)?&#39;, r&#39;[\S \t]*\w[\S \t]*\s*&#39;), re.MULTILINE | re.VERBOSE
    )

    _key_val_list_pat = re.compile(
        r&#34;^-(?:[ \t]*([^\n]*)(?:[ \t]*[:-][ \t]*(\S+))?)(?:\n((?:[ \t]+[^\n]+\n?)+))?&#34;,
        re.MULTILINE,
    )
    _key_val_dict_pat = re.compile(
        r&#34;^([^:\n]+)[ \t]*:[ \t]*([^\n]*)(?:((?:\n[ \t]+[^\n]+)+))?&#34;, re.MULTILINE
    )  # grp0: key, grp1: value, grp2: multiline value
    _meta_data_fence_pattern = re.compile(r&#39;^---[\ \t]*\n&#39;, re.MULTILINE)
    _meta_data_newline = re.compile(&#34;^\n&#34;, re.MULTILINE)

    def _extract_metadata(self, text):
        if text.startswith(&#34;---&#34;):
            fence_splits = re.split(self._meta_data_fence_pattern, text, maxsplit=2)
            metadata_content = fence_splits[1]
            match = re.findall(self._meta_data_pattern, metadata_content)
            if not match:
                return text
            tail = fence_splits[2]
        else:
            metadata_split = re.split(self._meta_data_newline, text, maxsplit=1)
            metadata_content = metadata_split[0]
            match = re.findall(self._meta_data_pattern, metadata_content)
            if not match:
                return text
            tail = metadata_split[1]

        def parse_structured_value(value):
            vs = value.lstrip()
            vs = value.replace(v[: len(value) - len(vs)], &#34;\n&#34;)[1:]

            # List
            if vs.startswith(&#34;-&#34;):
                r = []
                for match in re.findall(self._key_val_list_pat, vs):
                    if match[0] and not match[1] and not match[2]:
                        r.append(match[0].strip())
                    elif match[0] == &#34;&gt;&#34; and not match[1] and match[2]:
                        r.append(match[2].strip())
                    elif match[0] and match[1]:
                        r.append({match[0].strip(): match[1].strip()})
                    elif not match[0] and not match[1] and match[2]:
                        r.append(parse_structured_value(match[2]))
                    else:
                        # Broken case
                        pass

                return r

            # Dict
            else:
                return {
                    match[0].strip(): (
                        match[1].strip()
                        if match[1]
                        else parse_structured_value(match[2])
                    )
                    for match in re.findall(self._key_val_dict_pat, vs)
                }

        for item in match:

            k, v = item.split(&#34;:&#34;, 1)

            # Multiline value
            if v[:3] == &#34; &gt;\n&#34;:
                self.metadata[k.strip()] = _dedent(v[3:]).strip()

            # Empty value
            elif v == &#34;\n&#34;:
                self.metadata[k.strip()] = &#34;&#34;

            # Structured value
            elif v[0] == &#34;\n&#34;:
                self.metadata[k.strip()] = parse_structured_value(v)

            # Simple value
            else:
                self.metadata[k.strip()] = v.strip()

        return tail

    _emacs_oneliner_vars_pat = re.compile(r&#34;((?:&lt;!--)?\s*-\*-)\s*(?:(\S[^\r\n]*?)([\r\n]\s*)?)?(-\*-\s*(?:--&gt;)?)&#34;, re.UNICODE)
    # This regular expression is intended to match blocks like this:
    #    PREFIX Local Variables: SUFFIX
    #    PREFIX mode: Tcl SUFFIX
    #    PREFIX End: SUFFIX
    # Some notes:
    # - &#34;[ \t]&#34; is used instead of &#34;\s&#34; to specifically exclude newlines
    # - &#34;(\r\n|\n|\r)&#34; is used instead of &#34;$&#34; because the sre engine does
    #   not like anything other than Unix-style line terminators.
    _emacs_local_vars_pat = re.compile(r&#34;&#34;&#34;^
        (?P&lt;prefix&gt;(?:[^\r\n|\n|\r])*?)
        [\ \t]*Local\ Variables:[\ \t]*
        (?P&lt;suffix&gt;.*?)(?:\r\n|\n|\r)
        (?P&lt;content&gt;.*?\1End:)
        &#34;&#34;&#34;, re.IGNORECASE | re.MULTILINE | re.DOTALL | re.VERBOSE)

    def _emacs_vars_oneliner_sub(self, match):
        if match.group(1).strip() == &#39;-*-&#39; and match.group(4).strip() == &#39;-*-&#39;:
            lead_ws = re.findall(r&#39;^\s*&#39;, match.group(1))[0]
            tail_ws = re.findall(r&#39;\s*$&#39;, match.group(4))[0]
            return &#39;%s&lt;!-- %s %s %s --&gt;%s&#39; % (lead_ws, &#39;-*-&#39;, match.group(2).strip(), &#39;-*-&#39;, tail_ws)

        start, end = match.span()
        return match.string[start: end]

    def _get_emacs_vars(self, text):
        &#34;&#34;&#34;Return a dictionary of emacs-style local variables.

        Parsing is done loosely according to this spec (and according to
        some in-practice deviations from this):
        http://www.gnu.org/software/emacs/manual/html_node/emacs/Specifying-File-Variables.html#Specifying-File-Variables
        &#34;&#34;&#34;
        emacs_vars = {}
        SIZE = pow(2, 13)  # 8kB

        # Search near the start for a &#39;-*-&#39;-style one-liner of variables.
        head = text[:SIZE]
        if &#34;-*-&#34; in head:
            match = self._emacs_oneliner_vars_pat.search(head)
            if match:
                emacs_vars_str = match.group(2)
                assert &#39;\n&#39; not in emacs_vars_str
                emacs_var_strs = [s.strip() for s in emacs_vars_str.split(&#39;;&#39;)
                                  if s.strip()]
                if len(emacs_var_strs) == 1 and &#39;:&#39; not in emacs_var_strs[0]:
                    # While not in the spec, this form is allowed by emacs:
                    #   -*- Tcl -*-
                    # where the implied &#34;variable&#34; is &#34;mode&#34;. This form
                    # is only allowed if there are no other variables.
                    emacs_vars[&#34;mode&#34;] = emacs_var_strs[0].strip()
                else:
                    for emacs_var_str in emacs_var_strs:
                        try:
                            variable, value = emacs_var_str.strip().split(&#39;:&#39;, 1)
                        except ValueError:
                            log.debug(&#34;emacs variables error: malformed -*- &#34;
                                      &#34;line: %r&#34;, emacs_var_str)
                            continue
                        # Lowercase the variable name because Emacs allows &#34;Mode&#34;
                        # or &#34;mode&#34; or &#34;MoDe&#34;, etc.
                        emacs_vars[variable.lower()] = value.strip()

        tail = text[-SIZE:]
        if &#34;Local Variables&#34; in tail:
            match = self._emacs_local_vars_pat.search(tail)
            if match:
                prefix = match.group(&#34;prefix&#34;)
                suffix = match.group(&#34;suffix&#34;)
                lines = match.group(&#34;content&#34;).splitlines(0)
                # print &#34;prefix=%r, suffix=%r, content=%r, lines: %s&#34;\
                #      % (prefix, suffix, match.group(&#34;content&#34;), lines)

                # Validate the Local Variables block: proper prefix and suffix
                # usage.
                for i, line in enumerate(lines):
                    if not line.startswith(prefix):
                        log.debug(&#34;emacs variables error: line &#39;%s&#39; &#34;
                                  &#34;does not use proper prefix &#39;%s&#39;&#34;
                                  % (line, prefix))
                        return {}
                    # Don&#39;t validate suffix on last line. Emacs doesn&#39;t care,
                    # neither should we.
                    if i != len(lines)-1 and not line.endswith(suffix):
                        log.debug(&#34;emacs variables error: line &#39;%s&#39; &#34;
                                  &#34;does not use proper suffix &#39;%s&#39;&#34;
                                  % (line, suffix))
                        return {}

                # Parse out one emacs var per line.
                continued_for = None
                for line in lines[:-1]:  # no var on the last line (&#34;PREFIX End:&#34;)
                    if prefix: line = line[len(prefix):]  # strip prefix
                    if suffix: line = line[:-len(suffix)]  # strip suffix
                    line = line.strip()
                    if continued_for:
                        variable = continued_for
                        if line.endswith(&#39;\\&#39;):
                            line = line[:-1].rstrip()
                        else:
                            continued_for = None
                        emacs_vars[variable] += &#39; &#39; + line
                    else:
                        try:
                            variable, value = line.split(&#39;:&#39;, 1)
                        except ValueError:
                            log.debug(&#34;local variables error: missing colon &#34;
                                      &#34;in local variables entry: &#39;%s&#39;&#34; % line)
                            continue
                        # Do NOT lowercase the variable name, because Emacs only
                        # allows &#34;mode&#34; (and not &#34;Mode&#34;, &#34;MoDe&#34;, etc.) in this block.
                        value = value.strip()
                        if value.endswith(&#39;\\&#39;):
                            value = value[:-1].rstrip()
                            continued_for = variable
                        else:
                            continued_for = None
                        emacs_vars[variable] = value

        # Unquote values.
        for var, val in list(emacs_vars.items()):
            if len(val) &gt; 1 and (val.startswith(&#39;&#34;&#39;) and val.endswith(&#39;&#34;&#39;)
               or val.startswith(&#39;&#34;&#39;) and val.endswith(&#39;&#34;&#39;)):
                emacs_vars[var] = val[1:-1]

        return emacs_vars

    def _detab_line(self, line):
        r&#34;&#34;&#34;Recusively convert tabs to spaces in a single line.

        Called from _detab().&#34;&#34;&#34;
        if &#39;\t&#39; not in line:
            return line
        chunk1, chunk2 = line.split(&#39;\t&#39;, 1)
        chunk1 += (&#39; &#39; * (self.tab_width - len(chunk1) % self.tab_width))
        output = chunk1 + chunk2
        return self._detab_line(output)

    def _detab(self, text):
        r&#34;&#34;&#34;Iterate text line by line and convert tabs to spaces.

            &gt;&gt;&gt; m = Markdown()
            &gt;&gt;&gt; m._detab(&#34;\tfoo&#34;)
            &#39;    foo&#39;
            &gt;&gt;&gt; m._detab(&#34;  \tfoo&#34;)
            &#39;    foo&#39;
            &gt;&gt;&gt; m._detab(&#34;\t  foo&#34;)
            &#39;      foo&#39;
            &gt;&gt;&gt; m._detab(&#34;  foo&#34;)
            &#39;  foo&#39;
            &gt;&gt;&gt; m._detab(&#34;  foo\n\tbar\tblam&#34;)
            &#39;  foo\n    bar blam&#39;
        &#34;&#34;&#34;
        if &#39;\t&#39; not in text:
            return text
        output = []
        for line in text.splitlines():
            output.append(self._detab_line(line))
        return &#39;\n&#39;.join(output)

    # I broke out the html5 tags here and add them to _block_tags_a and
    # _block_tags_b.  This way html5 tags are easy to keep track of.
    _html5tags = &#39;|article|aside|header|hgroup|footer|nav|section|figure|figcaption&#39;

    _block_tags_a = &#39;p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del&#39;
    _block_tags_a += _html5tags

    _strict_tag_block_re = re.compile(r&#34;&#34;&#34;
        (                       # save in \1
            ^                   # start of line  (with re.M)
            &lt;(%s)               # start tag = \2
            \b                  # word break
            (.*\n)*?            # any number of lines, minimally matching
            &lt;/\2&gt;               # the matching end tag
            [ \t]*              # trailing spaces/tabs
            (?=\n+|\Z)          # followed by a newline or end of document
        )
        &#34;&#34;&#34; % _block_tags_a,
        re.X | re.M)

    _block_tags_b = &#39;p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math&#39;
    _block_tags_b += _html5tags

    _liberal_tag_block_re = re.compile(r&#34;&#34;&#34;
        (                       # save in \1
            ^                   # start of line  (with re.M)
            &lt;(%s)               # start tag = \2
            \b                  # word break
            (.*\n)*?            # any number of lines, minimally matching
            .*&lt;/\2&gt;             # the matching end tag
            [ \t]*              # trailing spaces/tabs
            (?=\n+|\Z)          # followed by a newline or end of document
        )
        &#34;&#34;&#34; % _block_tags_b,
        re.X | re.M)

    _html_markdown_attr_re = re.compile(
        r&#39;&#39;&#39;\s+markdown=(&#34;1&#34;|&#39;1&#39;)&#39;&#39;&#39;)
    def _hash_html_block_sub(self, match, raw=False):
        if isinstance(match, str):
            html = match
        else:
            html = match.group(1)

        if raw and self.safe_mode:
            html = self._sanitize_html(html)
        elif &#39;markdown-in-html&#39; in self.extras and &#39;markdown=&#39; in html:
            first_line = html.split(&#39;\n&#39;, 1)[0]
            m = self._html_markdown_attr_re.search(first_line)
            if m:
                lines = html.split(&#39;\n&#39;)
                middle = &#39;\n&#39;.join(lines[1:-1])
                last_line = lines[-1]
                first_line = first_line[:m.start()] + first_line[m.end():]
                f_key = _hash_text(first_line)
                self.html_blocks[f_key] = first_line
                l_key = _hash_text(last_line)
                self.html_blocks[l_key] = last_line
                return &#39;&#39;.join([&#34;\n\n&#34;, f_key,
                    &#34;\n\n&#34;, middle, &#34;\n\n&#34;,
                    l_key, &#34;\n\n&#34;])
        key = _hash_text(html)
        self.html_blocks[key] = html
        return &#34;\n\n&#34; + key + &#34;\n\n&#34;

    def _hash_html_blocks(self, text, raw=False):
        &#34;&#34;&#34;Hashify HTML blocks

        We only want to do this for block-level HTML tags, such as headers,
        lists, and tables. That&#39;s because we still want to wrap &lt;p&gt;s around
        &#34;paragraphs&#34; that are wrapped in non-block-level tags, such as anchors,
        phrase emphasis, and spans. The list of tags we&#39;re looking for is
        hard-coded.

        @param raw {boolean} indicates if these are raw HTML blocks in
            the original source. It makes a difference in &#34;safe&#34; mode.
        &#34;&#34;&#34;
        if &#39;&lt;&#39; not in text:
            return text

        # Pass `raw` value into our calls to self._hash_html_block_sub.
        hash_html_block_sub = _curry(self._hash_html_block_sub, raw=raw)

        # First, look for nested blocks, e.g.:
        #   &lt;div&gt;
        #       &lt;div&gt;
        #       tags for inner block must be indented.
        #       &lt;/div&gt;
        #   &lt;/div&gt;
        #
        # The outermost tags must start at the left margin for this to match, and
        # the inner nested divs must be indented.
        # We need to do this before the next, more liberal match, because the next
        # match will start at the first `&lt;div&gt;` and stop at the first `&lt;/div&gt;`.
        text = self._strict_tag_block_sub(text, self._block_tags_a, hash_html_block_sub)

        # Now match more liberally, simply from `\n&lt;tag&gt;` to `&lt;/tag&gt;\n`
        text = self._liberal_tag_block_re.sub(hash_html_block_sub, text)

        # Special case just for &lt;hr /&gt;. It was easier to make a special
        # case than to make the other regex more complicated.
        if &#34;&lt;hr&#34; in text:
            _hr_tag_re = _hr_tag_re_from_tab_width(self.tab_width)
            text = _hr_tag_re.sub(hash_html_block_sub, text)

        # Special case for standalone HTML comments:
        if &#34;&lt;!--&#34; in text:
            start = 0
            while True:
                # Delimiters for next comment block.
                try:
                    start_idx = text.index(&#34;&lt;!--&#34;, start)
                except ValueError:
                    break
                try:
                    end_idx = text.index(&#34;--&gt;&#34;, start_idx) + 3
                except ValueError:
                    break

                # Start position for next comment block search.
                start = end_idx

                # Validate whitespace before comment.
                if start_idx:
                    # - Up to `tab_width - 1` spaces before start_idx.
                    for i in range(self.tab_width - 1):
                        if text[start_idx - 1] != &#39; &#39;:
                            break
                        start_idx -= 1
                        if start_idx == 0:
                            break
                    # - Must be preceded by 2 newlines or hit the start of
                    #   the document.
                    if start_idx == 0:
                        pass
                    elif start_idx == 1 and text[0] == &#39;\n&#39;:
                        start_idx = 0  # to match minute detail of Markdown.pl regex
                    elif text[start_idx-2:start_idx] == &#39;\n\n&#39;:
                        pass
                    else:
                        break

                # Validate whitespace after comment.
                # - Any number of spaces and tabs.
                while end_idx &lt; len(text):
                    if text[end_idx] not in &#39; \t&#39;:
                        break
                    end_idx += 1
                # - Must be following by 2 newlines or hit end of text.
                if text[end_idx:end_idx+2] not in (&#39;&#39;, &#39;\n&#39;, &#39;\n\n&#39;):
                    continue

                # Escape and hash (must match `_hash_html_block_sub`).
                html = text[start_idx:end_idx]
                if raw and self.safe_mode:
                    html = self._sanitize_html(html)
                key = _hash_text(html)
                self.html_blocks[key] = html
                text = text[:start_idx] + &#34;\n\n&#34; + key + &#34;\n\n&#34; + text[end_idx:]

        if &#34;xml&#34; in self.extras:
            # Treat XML processing instructions and namespaced one-liner
            # tags as if they were block HTML tags. E.g., if standalone
            # (i.e. are their own paragraph), the following do not get
            # wrapped in a &lt;p&gt; tag:
            #    &lt;?foo bar?&gt;
            #
            #    &lt;xi:include xmlns:xi=&#34;http://www.w3.org/2001/XInclude&#34; href=&#34;chapter_1.md&#34;/&gt;
            _xml_oneliner_re = _xml_oneliner_re_from_tab_width(self.tab_width)
            text = _xml_oneliner_re.sub(hash_html_block_sub, text)

        return text

    def _strict_tag_block_sub(self, text, html_tags_re, callback):
        tag_count = 0
        current_tag = html_tags_re
        block = &#39;&#39;
        result = &#39;&#39;

        for chunk in text.splitlines(True):
            is_markup = re.match(r&#39;^(?:&lt;/code&gt;(?=&lt;/pre&gt;))?(&lt;/?(%s)\b&gt;?)&#39; % current_tag, chunk)
            block += chunk

            if is_markup:
                if chunk.startswith(&#39;&lt;/&#39;):
                    tag_count -= 1
                else:
                    # if close tag is in same line
                    if &#39;&lt;/%s&gt;&#39; % is_markup.group(2) in chunk[is_markup.end():]:
                        # we must ignore these
                        is_markup = None
                    else:
                        tag_count += 1
                        current_tag = is_markup.group(2)

            if tag_count == 0:
                if is_markup:
                    block = callback(block.rstrip(&#39;\n&#39;))  # remove trailing newline
                current_tag = html_tags_re
                result += block
                block = &#39;&#39;

        result += block

        return result

    def _strip_link_definitions(self, text):
        # Strips link definitions from text, stores the URLs and titles in
        # hash references.
        less_than_tab = self.tab_width - 1

        # Link defs are in the form:
        #   [id]: url &#34;optional title&#34;
        _link_def_re = re.compile(r&#34;&#34;&#34;
            ^[ ]{0,%d}\[(.+)\]: # id = \1
              [ \t]*
              \n?               # maybe *one* newline
              [ \t]*
            &lt;?(.+?)&gt;?           # url = \2
              [ \t]*
            (?:
                \n?             # maybe one newline
                [ \t]*
                (?&lt;=\s)         # lookbehind for whitespace
                [&#39;&#34;(]
                ([^\n]*)        # title = \3
                [&#39;&#34;)]
                [ \t]*
            )?  # title is optional
            (?:\n+|\Z)
            &#34;&#34;&#34; % less_than_tab, re.X | re.M | re.U)
        return _link_def_re.sub(self._extract_link_def_sub, text)

    def _extract_link_def_sub(self, match):
        id, url, title = match.groups()
        key = id.lower()    # Link IDs are case-insensitive
        self.urls[key] = self._encode_amps_and_angles(url)
        if title:
            self.titles[key] = title
        return &#34;&#34;

    def _do_numbering(self, text):
        &#39;&#39;&#39; We handle the special extension for generic numbering for
            tables, figures etc.
        &#39;&#39;&#39;
        # First pass to define all the references
        self.regex_defns = re.compile(r&#39;&#39;&#39;
            \[\#(\w+) # the counter.  Open square plus hash plus a word \1
            ([^@]*)   # Some optional characters, that aren&#39;t an @. \2
            @(\w+)       # the id.  Should this be normed? \3
            ([^\]]*)\]   # The rest of the text up to the terminating ] \4
            &#39;&#39;&#39;, re.VERBOSE)
        self.regex_subs = re.compile(r&#34;\[@(\w+)\s*\]&#34;)  # [@ref_id]
        counters = {}
        references = {}
        replacements = []
        definition_html = &#39;&lt;figcaption class=&#34;{}&#34; id=&#34;counter-ref-{}&#34;&gt;{}{}{}&lt;/figcaption&gt;&#39;
        reference_html = &#39;&lt;a class=&#34;{}&#34; href=&#34;#counter-ref-{}&#34;&gt;{}&lt;/a&gt;&#39;
        for match in self.regex_defns.finditer(text):
            # We must have four match groups otherwise this isn&#39;t a numbering reference
            if len(match.groups()) != 4:
                continue
            counter = match.group(1)
            text_before = match.group(2).strip()
            ref_id = match.group(3)
            text_after = match.group(4)
            number = counters.get(counter, 1)
            references[ref_id] = (number, counter)
            replacements.append((match.start(0),
                                 definition_html.format(counter,
                                                        ref_id,
                                                        text_before,
                                                        number,
                                                        text_after),
                                 match.end(0)))
            counters[counter] = number + 1
        for repl in reversed(replacements):
            text = text[:repl[0]] + repl[1] + text[repl[2]:]

        # Second pass to replace the references with the right
        # value of the counter
        # Fwiw, it&#39;s vaguely annoying to have to turn the iterator into
        # a list and then reverse it but I can&#39;t think of a better thing to do.
        for match in reversed(list(self.regex_subs.finditer(text))):
            number, counter = references.get(match.group(1), (None, None))
            if number is not None:
                repl = reference_html.format(counter,
                                             match.group(1),
                                             number)
            else:
                repl = reference_html.format(match.group(1),
                                             &#39;countererror&#39;,
                                             &#39;?&#39; + match.group(1) + &#39;?&#39;)
            if &#34;smarty-pants&#34; in self.extras:
                repl = repl.replace(&#39;&#34;&#39;, self._escape_table[&#39;&#34;&#39;])

            text = text[:match.start()] + repl + text[match.end():]
        return text

    def _extract_footnote_def_sub(self, match):
        id, text = match.groups()
        text = _dedent(text, skip_first_line=not text.startswith(&#39;\n&#39;)).strip()
        normed_id = re.sub(r&#39;\W&#39;, &#39;-&#39;, id)
        # Ensure footnote text ends with a couple newlines (for some
        # block gamut matches).
        self.footnotes[normed_id] = text + &#34;\n\n&#34;
        return &#34;&#34;

    def _strip_footnote_definitions(self, text):
        &#34;&#34;&#34;A footnote definition looks like this:

            [^note-id]: Text of the note.

                May include one or more indented paragraphs.

        Where,
        - The &#39;note-id&#39; can be pretty much anything, though typically it
          is the number of the footnote.
        - The first paragraph may start on the next line, like so:

            [^note-id]:
                Text of the note.
        &#34;&#34;&#34;
        less_than_tab = self.tab_width - 1
        footnote_def_re = re.compile(r&#39;&#39;&#39;
            ^[ ]{0,%d}\[\^(.+)\]:   # id = \1
            [ \t]*
            (                       # footnote text = \2
              # First line need not start with the spaces.
              (?:\s*.*\n+)
              (?:
                (?:[ ]{%d} | \t)  # Subsequent lines must be indented.
                .*\n+
              )*
            )
            # Lookahead for non-space at line-start, or end of doc.
            (?:(?=^[ ]{0,%d}\S)|\Z)
            &#39;&#39;&#39; % (less_than_tab, self.tab_width, self.tab_width),
            re.X | re.M)
        return footnote_def_re.sub(self._extract_footnote_def_sub, text)

    _hr_re = re.compile(r&#39;^[ ]{0,3}([-_*])[ ]{0,2}(\1[ ]{0,2}){2,}$&#39;, re.M)

    def _run_block_gamut(self, text):
        # These are all the transformations that form block-level
        # tags like paragraphs, headers, and list items.

        if &#39;admonitions&#39; in self.extras:
            text = self._do_admonitions(text)

        if &#39;wavedrom&#39; in self.extras:
            text = self._do_wavedrom_blocks(text)

        if &#34;fenced-code-blocks&#34; in self.extras:
            text = self._do_fenced_code_blocks(text)

        text = self._do_headers(text)

        # Do Horizontal Rules:
        # On the number of spaces in horizontal rules: The spec is fuzzy: &#34;If
        # you wish, you may use spaces between the hyphens or asterisks.&#34;
        # Markdown.pl 1.0.1&#39;s hr regexes limit the number of spaces between the
        # hr chars to one or two. We&#39;ll reproduce that limit here.
        hr = &#34;\n&lt;hr&#34;+self.empty_element_suffix+&#34;\n&#34;
        text = re.sub(self._hr_re, hr, text)

        text = self._do_lists(text)

        if &#34;pyshell&#34; in self.extras:
            text = self._prepare_pyshell_blocks(text)
        if &#34;wiki-tables&#34; in self.extras:
            text = self._do_wiki_tables(text)
        if &#34;tables&#34; in self.extras:
            text = self._do_tables(text)

        text = self._do_code_blocks(text)

        text = self._do_block_quotes(text)

        # We already ran _HashHTMLBlocks() before, in Markdown(), but that
        # was to escape raw HTML in the original Markdown source. This time,
        # we&#39;re escaping the markup we&#39;ve just created, so that we don&#39;t wrap
        # &lt;p&gt; tags around block-level tags.
        text = self._hash_html_blocks(text)

        text = self._form_paragraphs(text)

        return text

    def _pyshell_block_sub(self, match):
        if &#34;fenced-code-blocks&#34; in self.extras:
            dedented = _dedent(match.group(0))
            return self._do_fenced_code_blocks(&#34;```pycon\n&#34; + dedented + &#34;```\n&#34;)
        lines = match.group(0).splitlines(0)
        _dedentlines(lines)
        indent = &#39; &#39; * self.tab_width
        s = (&#39;\n&#39;  # separate from possible cuddled paragraph
             + indent + (&#39;\n&#39;+indent).join(lines)
             + &#39;\n&#39;)
        return s

    def _prepare_pyshell_blocks(self, text):
        &#34;&#34;&#34;Ensure that Python interactive shell sessions are put in
        code blocks -- even if not properly indented.
        &#34;&#34;&#34;
        if &#34;&gt;&gt;&gt;&#34; not in text:
            return text

        less_than_tab = self.tab_width - 1
        _pyshell_block_re = re.compile(r&#34;&#34;&#34;
            ^([ ]{0,%d})&gt;&gt;&gt;[ ].*\n  # first line
            ^(\1[^\S\n]*\S.*\n)*    # any number of subsequent lines with at least one character
            (?=^\1?\n|\Z)           # ends with a blank line or end of document
            &#34;&#34;&#34; % less_than_tab, re.M | re.X)

        return _pyshell_block_re.sub(self._pyshell_block_sub, text)

    def _table_sub(self, match):
        trim_space_re = &#39;^[ \t\n]+|[ \t\n]+$&#39;
        trim_bar_re = r&#39;^\||\|$&#39;
        split_bar_re = r&#39;^\||(?&lt;![\`\\])\|&#39;
        escape_bar_re = r&#39;\\\|&#39;

        head, underline, body = match.groups()

        # Determine aligns for columns.
        cols = [re.sub(escape_bar_re, &#39;|&#39;, cell.strip()) for cell in re.split(split_bar_re, re.sub(trim_bar_re, &#34;&#34;, re.sub(trim_space_re, &#34;&#34;, underline)))]
        align_from_col_idx = {}
        for col_idx, col in enumerate(cols):
            if col[0] == &#39;:&#39; and col[-1] == &#39;:&#39;:
                align_from_col_idx[col_idx] = &#39; style=&#34;text-align:center;&#34;&#39;
            elif col[0] == &#39;:&#39;:
                align_from_col_idx[col_idx] = &#39; style=&#34;text-align:left;&#34;&#39;
            elif col[-1] == &#39;:&#39;:
                align_from_col_idx[col_idx] = &#39; style=&#34;text-align:right;&#34;&#39;

        # thead
        hlines = [&#39;&lt;table%s&gt;&#39; % self._html_class_str_from_tag(&#39;table&#39;), &#39;&lt;thead%s&gt;&#39; % self._html_class_str_from_tag(&#39;thead&#39;), &#39;&lt;tr&gt;&#39;]
        cols = [re.sub(escape_bar_re, &#39;|&#39;, cell.strip()) for cell in re.split(split_bar_re, re.sub(trim_bar_re, &#34;&#34;, re.sub(trim_space_re, &#34;&#34;, head)))]
        for col_idx, col in enumerate(cols):
            hlines.append(&#39;  &lt;th%s&gt;%s&lt;/th&gt;&#39; % (
                align_from_col_idx.get(col_idx, &#39;&#39;),
                self._run_span_gamut(col)
            ))
        hlines.append(&#39;&lt;/tr&gt;&#39;)
        hlines.append(&#39;&lt;/thead&gt;&#39;)

        # tbody
        hlines.append(&#39;&lt;tbody&gt;&#39;)
        for line in body.strip(&#39;\n&#39;).split(&#39;\n&#39;):
            hlines.append(&#39;&lt;tr&gt;&#39;)
            cols = [re.sub(escape_bar_re, &#39;|&#39;, cell.strip()) for cell in re.split(split_bar_re, re.sub(trim_bar_re, &#34;&#34;, re.sub(trim_space_re, &#34;&#34;, line)))]
            for col_idx, col in enumerate(cols):
                hlines.append(&#39;  &lt;td%s&gt;%s&lt;/td&gt;&#39; % (
                    align_from_col_idx.get(col_idx, &#39;&#39;),
                    self._run_span_gamut(col)
                ))
            hlines.append(&#39;&lt;/tr&gt;&#39;)
        hlines.append(&#39;&lt;/tbody&gt;&#39;)
        hlines.append(&#39;&lt;/table&gt;&#39;)

        return &#39;\n&#39;.join(hlines) + &#39;\n&#39;

    def _do_tables(self, text):
        &#34;&#34;&#34;Copying PHP-Markdown and GFM table syntax. Some regex borrowed from
        https://github.com/michelf/php-markdown/blob/lib/Michelf/Markdown.php#L2538
        &#34;&#34;&#34;
        less_than_tab = self.tab_width - 1
        table_re = re.compile(r&#39;&#39;&#39;
                (?:(?&lt;=\n\n)|\A\n?)             # leading blank line

                ^[ ]{0,%d}                      # allowed whitespace
                (.*[|].*)  \n                   # $1: header row (at least one pipe)

                ^[ ]{0,%d}                      # allowed whitespace
                (                               # $2: underline row
                    # underline row with leading bar
                    (?:  \|\ *:?-+:?\ *  )+  \|? \s? \n
                    |
                    # or, underline row without leading bar
                    (?:  \ *:?-+:?\ *\|  )+  (?:  \ *:?-+:?\ *  )? \s? \n
                )

                (                               # $3: data rows
                    (?:
                        ^[ ]{0,%d}(?!\ )         # ensure line begins with 0 to less_than_tab spaces
                        .*\|.*  \n
                    )+
                )
            &#39;&#39;&#39; % (less_than_tab, less_than_tab, less_than_tab), re.M | re.X)
        return table_re.sub(self._table_sub, text)

    def _wiki_table_sub(self, match):
        ttext = match.group(0).strip()
        # print(&#39;wiki table: %r&#39; % match.group(0))
        rows = []
        for line in ttext.splitlines(0):
            line = line.strip()[2:-2].strip()
            row = [c.strip() for c in re.split(r&#39;(?&lt;!\\)\|\|&#39;, line)]
            rows.append(row)
        # from pprint import pprint
        # pprint(rows)
        hlines = []

        def add_hline(line, indents=0):
            hlines.append((self.tab * indents) + line)

        def format_cell(text):
            return self._run_span_gamut(re.sub(r&#34;^\s*~&#34;, &#34;&#34;, cell).strip(&#34; &#34;))

        add_hline(&#39;&lt;table%s&gt;&#39; % self._html_class_str_from_tag(&#39;table&#39;))
        # Check if first cell of first row is a header cell. If so, assume the whole row is a header row.
        if rows and rows[0] and re.match(r&#34;^\s*~&#34;, rows[0][0]):
            add_hline(&#39;&lt;thead%s&gt;&#39; % self._html_class_str_from_tag(&#39;thead&#39;), 1)
            add_hline(&#39;&lt;tr&gt;&#39;, 2)
            for cell in rows[0]:
                add_hline(&#34;&lt;th&gt;{}&lt;/th&gt;&#34;.format(format_cell(cell)), 3)
            add_hline(&#39;&lt;/tr&gt;&#39;, 2)
            add_hline(&#39;&lt;/thead&gt;&#39;, 1)
            # Only one header row allowed.
            rows = rows[1:]
        # If no more rows, don&#39;t create a tbody.
        if rows:
            add_hline(&#39;&lt;tbody&gt;&#39;, 1)
            for row in rows:
                add_hline(&#39;&lt;tr&gt;&#39;, 2)
                for cell in row:
                    add_hline(&#39;&lt;td&gt;{}&lt;/td&gt;&#39;.format(format_cell(cell)), 3)
                add_hline(&#39;&lt;/tr&gt;&#39;, 2)
            add_hline(&#39;&lt;/tbody&gt;&#39;, 1)
        add_hline(&#39;&lt;/table&gt;&#39;)
        return &#39;\n&#39;.join(hlines) + &#39;\n&#39;

    def _do_wiki_tables(self, text):
        # Optimization.
        if &#34;||&#34; not in text:
            return text

        less_than_tab = self.tab_width - 1
        wiki_table_re = re.compile(r&#39;&#39;&#39;
            (?:(?&lt;=\n\n)|\A\n?)            # leading blank line
            ^([ ]{0,%d})\|\|.+?\|\|[ ]*\n  # first line
            (^\1\|\|.+?\|\|\n)*        # any number of subsequent lines
            &#39;&#39;&#39; % less_than_tab, re.M | re.X)
        return wiki_table_re.sub(self._wiki_table_sub, text)

    def _run_span_gamut(self, text):
        # These are all the transformations that occur *within* block-level
        # tags like paragraphs, headers, and list items.

        text = self._do_code_spans(text)

        text = self._escape_special_chars(text)

        # Process anchor and image tags.
        if &#34;link-patterns&#34; in self.extras:
            text = self._do_link_patterns(text)

        text = self._do_links(text)

        # Make links out of things like `&lt;http://example.com/&gt;`
        # Must come after _do_links(), because you can use &lt; and &gt;
        # delimiters in inline links like [this](&lt;url&gt;).
        text = self._do_auto_links(text)

        text = self._encode_amps_and_angles(text)

        if &#34;strike&#34; in self.extras:
            text = self._do_strike(text)

        if &#34;underline&#34; in self.extras:
            text = self._do_underline(text)

        text = self._do_italics_and_bold(text)

        if &#34;tg-spoiler&#34; in self.extras:
            text = self._do_tg_spoiler(text)

        if &#34;smarty-pants&#34; in self.extras:
            text = self._do_smart_punctuation(text)

        # Do hard breaks:
        if &#34;break-on-newline&#34; in self.extras:
            text = re.sub(r&#34; *\n(?!\&lt;(?:\/?(ul|ol|li))\&gt;)&#34;, &#34;&lt;br%s\n&#34; % self.empty_element_suffix, text)
        else:
            text = re.sub(r&#34; {2,}\n&#34;, &#34; &lt;br%s\n&#34; % self.empty_element_suffix, text)

        return text

    # &#34;Sorta&#34; because auto-links are identified as &#34;tag&#34; tokens.
    _sorta_html_tokenize_re = re.compile(r&#34;&#34;&#34;
        (
            \\*  # escapes
            (?:
                # tag
                &lt;/?
                (?:\w+)                                     # tag name
                (?:\s+(?:[\w-]+:)?[\w-]+=(?:&#34;.*?&#34;|&#39;.*?&#39;))*  # attributes
                \s*/?&gt;
                |
                # auto-link (e.g., &lt;http://www.activestate.com/&gt;)
                &lt;[\w~:/?#\[\]@!$&amp;&#39;\(\)*+,;%=\.\\-]+&gt;
                |
                &lt;!--.*?--&gt;      # comment
                |
                &lt;\?.*?\?&gt;       # processing instruction
            )
        )
        &#34;&#34;&#34;, re.X)

    def _escape_special_chars(self, text):
        # Python markdown note: the HTML tokenization here differs from
        # that in Markdown.pl, hence the behaviour for subtle cases can
        # differ (I believe the tokenizer here does a better job because
        # it isn&#39;t susceptible to unmatched &#39;&lt;&#39; and &#39;&gt;&#39; in HTML tags).
        # Note, however, that &#39;&gt;&#39; is not allowed in an auto-link URL
        # here.
        lead_escape_re = re.compile(r&#39;^((?:\\\\)*(?!\\))&#39;)
        escaped = []
        is_html_markup = False
        for token in self._sorta_html_tokenize_re.split(text):
            # check token is preceded by 0 or more PAIRS of escapes, because escape pairs
            # escape themselves and don&#39;t affect the token
            if is_html_markup and lead_escape_re.match(token):
                # Within tags/HTML-comments/auto-links, encode * and _
                # so they don&#39;t conflict with their use in Markdown for
                # italics and strong.  We&#39;re replacing each such
                # character with its corresponding MD5 checksum value;
                # this is likely overkill, but it should prevent us from
                # colliding with the escape values by accident.
                escape_seq, token = lead_escape_re.split(token)[1:] or (&#39;&#39;, token)
                escaped.append(
                    escape_seq.replace(&#39;\\\\&#39;, self._escape_table[&#39;\\&#39;])
                    + token.replace(&#39;*&#39;, self._escape_table[&#39;*&#39;])
                           .replace(&#39;_&#39;, self._escape_table[&#39;_&#39;])
                )
            else:
                escaped.append(self._encode_backslash_escapes(token.replace(&#39;\\&lt;&#39;, &#39;&amp;lt;&#39;)))
            is_html_markup = not is_html_markup
        return &#39;&#39;.join(escaped)

    def _hash_html_spans(self, text):
        # Used for safe_mode.

        def _is_auto_link(s):
            if &#39;:&#39; in s and self._auto_link_re.match(s):
                return True
            elif &#39;@&#39; in s and self._auto_email_link_re.match(s):
                return True
            return False

        def _is_code_span(index, token):
            try:
                if token == &#39;&lt;code&gt;&#39;:
                    peek_tokens = split_tokens[index: index + 3]
                elif token == &#39;&lt;/code&gt;&#39;:
                    peek_tokens = split_tokens[index - 2: index + 1]
                else:
                    return False
            except IndexError:
                return False

            return re.match(r&#39;&lt;code&gt;md5-[A-Fa-f0-9]{32}&lt;/code&gt;&#39;, &#39;&#39;.join(peek_tokens))

        tokens = []
        split_tokens = self._sorta_html_tokenize_re.split(text)
        is_html_markup = False
        for index, token in enumerate(split_tokens):
            if is_html_markup and not _is_auto_link(token) and not _is_code_span(index, token):
                sanitized = self._sanitize_html(token)
                key = _hash_text(sanitized)
                self.html_spans[key] = sanitized
                tokens.append(key)
            else:
                tokens.append(self._encode_incomplete_tags(token))
            is_html_markup = not is_html_markup
        return &#39;&#39;.join(tokens)

    def _unhash_html_spans(self, text):
        for key, sanitized in list(self.html_spans.items()):
            text = text.replace(key, sanitized)
        return text

    def _sanitize_html(self, s):
        if self.safe_mode == &#34;replace&#34;:
            return self.html_removed_text
        elif self.safe_mode == &#34;escape&#34;:
            replacements = [
                (&#39;&amp;&#39;, &#39;&amp;amp;&#39;),
                (&#39;&lt;&#39;, &#39;&amp;lt;&#39;),
                (&#39;&gt;&#39;, &#39;&amp;gt;&#39;),
            ]
            for before, after in replacements:
                s = s.replace(before, after)
            return s
        else:
            raise MarkdownError(&#34;invalid value for &#39;safe_mode&#39;: %r (must be &#34;
                                &#34;&#39;escape&#39; or &#39;replace&#39;)&#34; % self.safe_mode)

    _inline_link_title = re.compile(r&#39;&#39;&#39;
            (                   # \1
              [ \t]+
              ([&#39;&#34;])            # quote char = \2
              (?P&lt;title&gt;.*?)
              \2
            )?                  # title is optional
          \)$
        &#39;&#39;&#39;, re.X | re.S)
    _tail_of_reference_link_re = re.compile(r&#39;&#39;&#39;
          # Match tail of: [text][id]
          [ ]?          # one optional space
          (?:\n[ ]*)?   # one optional newline followed by spaces
          \[
            (?P&lt;id&gt;.*?)
          \]
        &#39;&#39;&#39;, re.X | re.S)

    _whitespace = re.compile(r&#39;\s*&#39;)

    _strip_anglebrackets = re.compile(r&#39;&lt;(.*)&gt;.*&#39;)

    def _find_non_whitespace(self, text, start):
        &#34;&#34;&#34;Returns the index of the first non-whitespace character in text
        after (and including) start
        &#34;&#34;&#34;
        match = self._whitespace.match(text, start)
        return match.end()

    def _find_balanced(self, text, start, open_c, close_c):
        &#34;&#34;&#34;Returns the index where the open_c and close_c characters balance
        out - the same number of open_c and close_c are encountered - or the
        end of string if it&#39;s reached before the balance point is found.
        &#34;&#34;&#34;
        i = start
        l = len(text)
        count = 1
        while count &gt; 0 and i &lt; l:
            if text[i] == open_c:
                count += 1
            elif text[i] == close_c:
                count -= 1
            i += 1
        return i

    def _extract_url_and_title(self, text, start):
        &#34;&#34;&#34;Extracts the url and (optional) title from the tail of a link&#34;&#34;&#34;
        # text[start] equals the opening parenthesis
        idx = self._find_non_whitespace(text, start+1)
        if idx == len(text):
            return None, None, None
        end_idx = idx
        has_anglebrackets = text[idx] == &#34;&lt;&#34;
        if has_anglebrackets:
            end_idx = self._find_balanced(text, end_idx+1, &#34;&lt;&#34;, &#34;&gt;&#34;)
        end_idx = self._find_balanced(text, end_idx, &#34;(&#34;, &#34;)&#34;)
        match = self._inline_link_title.search(text, idx, end_idx)
        if not match:
            return None, None, None
        url, title = text[idx:match.start()], match.group(&#34;title&#34;)
        if has_anglebrackets:
            url = self._strip_anglebrackets.sub(r&#39;\1&#39;, url)
        return url, title, end_idx

    def _protect_url(self, url):
        &#39;&#39;&#39;
        Function that passes a URL through `_html_escape_url` to remove any nasty characters,
        and then hashes the now &#34;safe&#34; URL to prevent other safety mechanisms from tampering
        with it (eg: escaping &#34;&amp;&#34; in URL parameters)
        &#39;&#39;&#39;
        url = _html_escape_url(url, safe_mode=self.safe_mode)
        key = _hash_text(url)
        self._escape_table[url] = key
        return key

    _safe_protocols = re.compile(r&#39;(https?|ftp):&#39;, re.I)
    def _do_links(self, text):
        &#34;&#34;&#34;Turn Markdown link shortcuts into XHTML &lt;a&gt; and &lt;img&gt; tags.

        This is a combination of Markdown.pl&#39;s _DoAnchors() and
        _DoImages(). They are done together because that simplified the
        approach. It was necessary to use a different approach than
        Markdown.pl because of the lack of atomic matching support in
        Python&#39;s regex engine used in $g_nested_brackets.
        &#34;&#34;&#34;
        MAX_LINK_TEXT_SENTINEL = 3000  # markdown2 issue 24

        # `anchor_allowed_pos` is used to support img links inside
        # anchors, but not anchors inside anchors. An anchor&#39;s start
        # pos must be `&gt;= anchor_allowed_pos`.
        anchor_allowed_pos = 0

        curr_pos = 0
        while True:  # Handle the next link.
            # The next &#39;[&#39; is the start of:
            # - an inline anchor:   [text](url &#34;title&#34;)
            # - a reference anchor: [text][id]
            # - an inline img:      ![text](url &#34;title&#34;)
            # - a reference img:    ![text][id]
            # - a footnote ref:     [^id]
            #   (Only if &#39;footnotes&#39; extra enabled)
            # - a footnote defn:    [^id]: ...
            #   (Only if &#39;footnotes&#39; extra enabled) These have already
            #   been stripped in _strip_footnote_definitions() so no
            #   need to watch for them.
            # - a link definition:  [id]: url &#34;title&#34;
            #   These have already been stripped in
            #   _strip_link_definitions() so no need to watch for them.
            # - not markup:         [...anything else...
            try:
                start_idx = text.index(&#39;[&#39;, curr_pos)
            except ValueError:
                break
            text_length = len(text)

            # Find the matching closing &#39;]&#39;.
            # Markdown.pl allows *matching* brackets in link text so we
            # will here too. Markdown.pl *doesn&#39;t* currently allow
            # matching brackets in img alt text -- we&#39;ll differ in that
            # regard.
            bracket_depth = 0
            for p in range(start_idx+1, min(start_idx+MAX_LINK_TEXT_SENTINEL,
                                            text_length)):
                ch = text[p]
                if ch == &#39;]&#39;:
                    bracket_depth -= 1
                    if bracket_depth &lt; 0:
                        break
                elif ch == &#39;[&#39;:
                    bracket_depth += 1
            else:
                # Closing bracket not found within sentinel length.
                # This isn&#39;t markup.
                curr_pos = start_idx + 1
                continue
            link_text = text[start_idx+1:p]

            # Fix for issue 341 - Injecting XSS into link text
            if self.safe_mode:
                link_text = self._hash_html_spans(link_text)
                link_text = self._unhash_html_spans(link_text)

            # Possibly a footnote ref?
            if &#34;footnotes&#34; in self.extras and link_text.startswith(&#34;^&#34;):
                normed_id = re.sub(r&#39;\W&#39;, &#39;-&#39;, link_text[1:])
                if normed_id in self.footnotes:
                    self.footnote_ids.append(normed_id)
                    result = &#39;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref-%s&#34;&gt;&#39; \
                             &#39;&lt;a href=&#34;#fn-%s&#34;&gt;%s&lt;/a&gt;&lt;/sup&gt;&#39; \
                             % (normed_id, normed_id, len(self.footnote_ids))
                    text = text[:start_idx] + result + text[p+1:]
                else:
                    # This id isn&#39;t defined, leave the markup alone.
                    curr_pos = p+1
                continue

            # Now determine what this is by the remainder.
            p += 1

            # Inline anchor or img?
            if text[p:p + 1] == &#39;(&#39;:  # attempt at perf improvement
                url, title, url_end_idx = self._extract_url_and_title(text, p)
                if url is not None:
                    # Handle an inline anchor or img.
                    is_img = start_idx &gt; 0 and text[start_idx-1] == &#34;!&#34;
                    if is_img:
                        start_idx -= 1

                    # We&#39;ve got to encode these to avoid conflicting
                    # with italics/bold.
                    url = url.replace(&#39;*&#39;, self._escape_table[&#39;*&#39;]) \
                             .replace(&#39;_&#39;, self._escape_table[&#39;_&#39;])
                    if title:
                        title_str = &#39; title=&#34;%s&#34;&#39; % (
                            _xml_escape_attr(title)
                                .replace(&#39;*&#39;, self._escape_table[&#39;*&#39;])
                                .replace(&#39;_&#39;, self._escape_table[&#39;_&#39;]))
                    else:
                        title_str = &#39;&#39;
                    if is_img:
                        img_class_str = self._html_class_str_from_tag(&#34;img&#34;)
                        result = &#39;&lt;img src=&#34;%s&#34; alt=&#34;%s&#34;%s%s%s&#39; \
                            % (self._protect_url(url),
                               _xml_escape_attr(link_text),
                               title_str,
                               img_class_str,
                               self.empty_element_suffix)
                        if &#34;smarty-pants&#34; in self.extras:
                            result = result.replace(&#39;&#34;&#39;, self._escape_table[&#39;&#34;&#39;])
                        curr_pos = start_idx + len(result)
                        anchor_allowed_pos = start_idx + len(result)
                        text = text[:start_idx] + result + text[url_end_idx:]
                    elif start_idx &gt;= anchor_allowed_pos:
                        safe_link = self._safe_protocols.match(url) or url.startswith(&#39;#&#39;)
                        if self.safe_mode and not safe_link:
                            result_head = &#39;&lt;a href=&#34;#&#34;%s&gt;&#39; % (title_str)
                        else:
                            result_head = &#39;&lt;a href=&#34;%s&#34;%s&gt;&#39; % (self._protect_url(url), title_str)
                        result = &#39;%s%s&lt;/a&gt;&#39; % (result_head, link_text)
                        if &#34;smarty-pants&#34; in self.extras:
                            result = result.replace(&#39;&#34;&#39;, self._escape_table[&#39;&#34;&#39;])
                        # &lt;img&gt; allowed from curr_pos on, &lt;a&gt; from
                        # anchor_allowed_pos on.
                        curr_pos = start_idx + len(result_head)
                        anchor_allowed_pos = start_idx + len(result)
                        text = text[:start_idx] + result + text[url_end_idx:]
                    else:
                        # Anchor not allowed here.
                        curr_pos = start_idx + 1
                    continue

            # Reference anchor or img?
            else:
                match = self._tail_of_reference_link_re.match(text, p)
                if match:
                    # Handle a reference-style anchor or img.
                    is_img = start_idx &gt; 0 and text[start_idx-1] == &#34;!&#34;
                    if is_img:
                        start_idx -= 1
                    link_id = match.group(&#34;id&#34;).lower()
                    if not link_id:
                        link_id = link_text.lower()  # for links like [this][]
                    if link_id in self.urls:
                        url = self.urls[link_id]
                        # We&#39;ve got to encode these to avoid conflicting
                        # with italics/bold.
                        url = url.replace(&#39;*&#39;, self._escape_table[&#39;*&#39;]) \
                                 .replace(&#39;_&#39;, self._escape_table[&#39;_&#39;])
                        title = self.titles.get(link_id)
                        if title:
                            title = _xml_escape_attr(title) \
                                .replace(&#39;*&#39;, self._escape_table[&#39;*&#39;]) \
                                .replace(&#39;_&#39;, self._escape_table[&#39;_&#39;])
                            title_str = &#39; title=&#34;%s&#34;&#39; % title
                        else:
                            title_str = &#39;&#39;
                        if is_img:
                            img_class_str = self._html_class_str_from_tag(&#34;img&#34;)
                            result = &#39;&lt;img src=&#34;%s&#34; alt=&#34;%s&#34;%s%s%s&#39; \
                                % (self._protect_url(url),
                                   _xml_escape_attr(link_text),
                                   title_str,
                                   img_class_str,
                                   self.empty_element_suffix)
                            if &#34;smarty-pants&#34; in self.extras:
                                result = result.replace(&#39;&#34;&#39;, self._escape_table[&#39;&#34;&#39;])
                            curr_pos = start_idx + len(result)
                            text = text[:start_idx] + result + text[match.end():]
                        elif start_idx &gt;= anchor_allowed_pos:
                            if self.safe_mode and not self._safe_protocols.match(url):
                                result_head = &#39;&lt;a href=&#34;#&#34;%s&gt;&#39; % (title_str)
                            else:
                                result_head = &#39;&lt;a href=&#34;%s&#34;%s&gt;&#39; % (self._protect_url(url), title_str)
                            result = &#39;%s%s&lt;/a&gt;&#39; % (result_head, link_text)
                            if &#34;smarty-pants&#34; in self.extras:
                                result = result.replace(&#39;&#34;&#39;, self._escape_table[&#39;&#34;&#39;])
                            # &lt;img&gt; allowed from curr_pos on, &lt;a&gt; from
                            # anchor_allowed_pos on.
                            curr_pos = start_idx + len(result_head)
                            anchor_allowed_pos = start_idx + len(result)
                            text = text[:start_idx] + result + text[match.end():]
                        else:
                            # Anchor not allowed here.
                            curr_pos = start_idx + 1
                    else:
                        # This id isn&#39;t defined, leave the markup alone.
                        curr_pos = match.end()
                    continue

            # Otherwise, it isn&#39;t markup.
            curr_pos = start_idx + 1

        return text

    def header_id_from_text(self, text, prefix, n):
        &#34;&#34;&#34;Generate a header id attribute value from the given header
        HTML content.

        This is only called if the &#34;header-ids&#34; extra is enabled.
        Subclasses may override this for different header ids.

        @param text {str} The text of the header tag
        @param prefix {str} The requested prefix for header ids. This is the
            value of the &#34;header-ids&#34; extra key, if any. Otherwise, None.
        @param n {int} The &lt;hN&gt; tag number, i.e. `1` for an &lt;h1&gt; tag.
        @returns {str} The value for the header tag&#39;s &#34;id&#34; attribute. Return
            None to not have an id attribute and to exclude this header from
            the TOC (if the &#34;toc&#34; extra is specified).
        &#34;&#34;&#34;
        header_id = _slugify(text)
        if prefix and isinstance(prefix, str):
            header_id = prefix + &#39;-&#39; + header_id

        self._count_from_header_id[header_id] += 1
        if 0 == len(header_id) or self._count_from_header_id[header_id] &gt; 1:
            header_id += &#39;-%s&#39; % self._count_from_header_id[header_id]

        return header_id

    def _toc_add_entry(self, level, id, name):
        if level &gt; self._toc_depth:
            return
        if self._toc is None:
            self._toc = []
        self._toc.append((level, id, self._unescape_special_chars(name)))

    _h_re_base = r&#39;&#39;&#39;
        (^(.+)[ \t]{0,99}\n(=+|-+)[ \t]*\n+)
        |
        (^(\#{1,6})  # \1 = string of #&#39;s
        [ \t]%s
        (.+?)       # \2 = Header text
        [ \t]{0,99}
        (?&lt;!\\)     # ensure not an escaped trailing &#39;#&#39;
        \#*         # optional closing #&#39;s (not counted)
        \n+
        )
        &#39;&#39;&#39;

    _h_re = re.compile(_h_re_base % &#39;*&#39;, re.X | re.M)
    _h_re_tag_friendly = re.compile(_h_re_base % &#39;+&#39;, re.X | re.M)

    def _h_sub(self, match):
        if match.group(1) is not None and match.group(3) == &#34;-&#34;:
            return match.group(1)
        elif match.group(1) is not None:
            # Setext header
            n = {&#34;=&#34;: 1, &#34;-&#34;: 2}[match.group(3)[0]]
            header_group = match.group(2)
        else:
            # atx header
            n = len(match.group(5))
            header_group = match.group(6)

        demote_headers = self.extras.get(&#34;demote-headers&#34;)
        if demote_headers:
            n = min(n + demote_headers, 6)
        header_id_attr = &#34;&#34;
        if &#34;header-ids&#34; in self.extras:
            header_id = self.header_id_from_text(header_group,
                self.extras[&#34;header-ids&#34;], n)
            if header_id:
                header_id_attr = &#39; id=&#34;%s&#34;&#39; % header_id
        html = self._run_span_gamut(header_group)
        if &#34;toc&#34; in self.extras and header_id:
            self._toc_add_entry(n, header_id, html)
        return &#34;&lt;h%d%s&gt;%s&lt;/h%d&gt;\n\n&#34; % (n, header_id_attr, html, n)

    def _do_headers(self, text):
        # Setext-style headers:
        #     Header 1
        #     ========
        #
        #     Header 2
        #     --------

        # atx-style headers:
        #   # Header 1
        #   ## Header 2
        #   ## Header 2 with closing hashes ##
        #   ...
        #   ###### Header 6

        if &#39;tag-friendly&#39; in self.extras:
            return self._h_re_tag_friendly.sub(self._h_sub, text)
        return self._h_re.sub(self._h_sub, text)

    _marker_ul_chars = &#39;*+-&#39;
    _marker_any = r&#39;(?:[%s]|\d+\.)&#39; % _marker_ul_chars
    _marker_ul = &#39;(?:[%s])&#39; % _marker_ul_chars
    _marker_ol = r&#39;(?:\d+\.)&#39;

    def _list_sub(self, match):
        lst = match.group(1)
        lst_type = match.group(4) in self._marker_ul_chars and &#34;ul&#34; or &#34;ol&#34;

        if lst_type == &#39;ol&#39; and match.group(4) != &#39;1.&#39;:
            # if list doesn&#39;t start at 1 then set the ol start attribute
            lst_opts = &#39; start=&#34;%s&#34;&#39; % match.group(4)[:-1]
        else:
            lst_opts = &#39;&#39;

        lst_opts = lst_opts + self._html_class_str_from_tag(lst_type)

        result = self._process_list_items(lst)
        if self.list_level:
            return &#34;&lt;%s%s&gt;\n%s&lt;/%s&gt;\n&#34; % (lst_type, lst_opts, result, lst_type)
        else:
            return &#34;&lt;%s%s&gt;\n%s&lt;/%s&gt;\n\n&#34; % (lst_type, lst_opts, result, lst_type)

    def _do_lists(self, text):
        # Form HTML ordered (numbered) and unordered (bulleted) lists.

        # Iterate over each *non-overlapping* list match.
        pos = 0
        while True:
            # Find the *first* hit for either list style (ul or ol). We
            # match ul and ol separately to avoid adjacent lists of different
            # types running into each other (see issue #16).
            hits = []
            for marker_pat in (self._marker_ul, self._marker_ol):
                less_than_tab = self.tab_width - 1
                other_marker_pat = self._marker_ul if marker_pat == self._marker_ol else self._marker_ol
                whole_list = r&#39;&#39;&#39;
                    (                   # \1 = whole list
                      (                 # \2
                        ([ ]{0,%d})     # \3 = the indentation level of the list item marker
                        (%s)            # \4 = first list item marker
                        [ \t]+
                        (?!\ *\4\ )     # &#39;- - - ...&#39; isn&#39;t a list. See &#39;not_quite_a_list&#39; test case.
                      )
                      (?:.+?)
                      (                 # \5
                          \Z
                        |
                          \n{2,}
                          (?=\S)
                          (?!           # Negative lookahead for another list item marker
                            [ \t]*
                            %s[ \t]+
                          )
                        |
                          \n+
                          (?=
                            \3          # lookahead for a different style of list item marker
                            %s[ \t]+
                          )
                      )
                    )
                &#39;&#39;&#39; % (less_than_tab, marker_pat, marker_pat, other_marker_pat)
                if self.list_level:  # sub-list
                    list_re = re.compile(&#34;^&#34;+whole_list, re.X | re.M | re.S)
                else:
                    list_re = re.compile(r&#34;(?:(?&lt;=\n\n)|\A\n?)&#34;+whole_list,
                                         re.X | re.M | re.S)
                match = list_re.search(text, pos)
                if match:
                    hits.append((match.start(), match))
            if not hits:
                break
            hits.sort()
            match = hits[0][1]
            start, end = match.span()
            middle = self._list_sub(match)
            text = text[:start] + middle + text[end:]
            pos = start + len(middle)  # start pos for next attempted match

        return text

    _list_item_re = re.compile(r&#39;&#39;&#39;
        (\n)?                   # leading line = \1
        (^[ \t]*)               # leading whitespace = \2
        (?P&lt;marker&gt;%s) [ \t]+   # list marker = \3
        ((?:.+?)                # list item text = \4
        (\n{1,2}))              # eols = \5
        (?= \n* (\Z | \2 (?P&lt;next_marker&gt;%s) [ \t]+))
        &#39;&#39;&#39; % (_marker_any, _marker_any),
        re.M | re.X | re.S)

    _task_list_item_re = re.compile(r&#39;&#39;&#39;
        (\[[\ xX]\])[ \t]+       # tasklist marker = \1
        (.*)                   # list item text = \2
    &#39;&#39;&#39;, re.M | re.X | re.S)

    _task_list_warpper_str = r&#39;&lt;input type=&#34;checkbox&#34; class=&#34;task-list-item-checkbox&#34; %sdisabled&gt; %s&#39;

    def _task_list_item_sub(self, match):
        marker = match.group(1)
        item_text = match.group(2)
        if marker in [&#39;[x]&#39;,&#39;[X]&#39;]:
                return self._task_list_warpper_str % (&#39;checked &#39;, item_text)
        elif marker == &#39;[ ]&#39;:
                return self._task_list_warpper_str % (&#39;&#39;, item_text)

    _last_li_endswith_two_eols = False
    def _list_item_sub(self, match):
        item = match.group(4)
        leading_line = match.group(1)
        if leading_line or &#34;\n\n&#34; in item or self._last_li_endswith_two_eols:
            item = self._run_block_gamut(self._outdent(item))
        else:
            # Recursion for sub-lists:
            item = self._do_lists(self._uniform_outdent(item, min_outdent=&#39; &#39;)[1])
            if item.endswith(&#39;\n&#39;):
                item = item[:-1]
            item = self._run_span_gamut(item)
        self._last_li_endswith_two_eols = (len(match.group(5)) == 2)

        if &#34;task_list&#34; in self.extras:
            item = self._task_list_item_re.sub(self._task_list_item_sub, item)

        return &#34;&lt;li&gt;%s&lt;/li&gt;\n&#34; % item

    def _process_list_items(self, list_str):
        # Process the contents of a single ordered or unordered list,
        # splitting it into individual list items.

        # The $g_list_level global keeps track of when we&#39;re inside a list.
        # Each time we enter a list, we increment it; when we leave a list,
        # we decrement. If it&#39;s zero, we&#39;re not in a list anymore.
        #
        # We do this because when we&#39;re not inside a list, we want to treat
        # something like this:
        #
        #       I recommend upgrading to version
        #       8. Oops, now this line is treated
        #       as a sub-list.
        #
        # As a single paragraph, despite the fact that the second line starts
        # with a digit-period-space sequence.
        #
        # Whereas when we&#39;re inside a list (or sub-list), that line will be
        # treated as the start of a sub-list. What a kludge, huh? This is
        # an aspect of Markdown&#39;s syntax that&#39;s hard to parse perfectly
        # without resorting to mind-reading. Perhaps the solution is to
        # change the syntax rules such that sub-lists must start with a
        # starting cardinal number; e.g. &#34;1.&#34; or &#34;a.&#34;.
        self.list_level += 1
        self._last_li_endswith_two_eols = False
        list_str = list_str.rstrip(&#39;\n&#39;) + &#39;\n&#39;
        list_str = self._list_item_re.sub(self._list_item_sub, list_str)
        self.list_level -= 1
        return list_str

    def _get_pygments_lexer(self, lexer_name):
        try:
            from pygments import lexers, util
        except ImportError:
            return None
        try:
            return lexers.get_lexer_by_name(lexer_name)
        except util.ClassNotFound:
            return None

    def _color_with_pygments(self, codeblock, lexer, **formatter_opts):
        import pygments
        import pygments.formatters

        class HtmlCodeFormatter(pygments.formatters.HtmlFormatter):
            def _wrap_code(self, inner):
                &#34;&#34;&#34;A function for use in a Pygments Formatter which
                wraps in &lt;code&gt; tags.
                &#34;&#34;&#34;
                yield 0, &#34;&lt;code&gt;&#34;
                for tup in inner:
                    yield tup
                yield 0, &#34;&lt;/code&gt;&#34;

            def _add_newline(self, inner):
                # Add newlines around the inner contents so that _strict_tag_block_re matches the outer div.
                yield 0, &#34;\n&#34;
                yield from inner
                yield 0, &#34;\n&#34;

            def wrap(self, source, outfile=None):
                &#34;&#34;&#34;Return the source with a code, pre, and div.&#34;&#34;&#34;
                if outfile is None:
                    # pygments &gt;= 2.12
                    return self._add_newline(self._wrap_pre(self._wrap_code(source)))
                else:
                    # pygments &lt; 2.12
                    return self._wrap_div(self._add_newline(self._wrap_pre(self._wrap_code(source))))

        formatter_opts.setdefault(&#34;cssclass&#34;, &#34;codehilite&#34;)
        formatter = HtmlCodeFormatter(**formatter_opts)
        return pygments.highlight(codeblock, lexer, formatter)

    def _code_block_sub(self, match, is_fenced_code_block=False):
        lexer_name = None
        if is_fenced_code_block:
            lexer_name = match.group(2)
            codeblock = match.group(3)
            codeblock = codeblock[:-1]  # drop one trailing newline
        else:
            codeblock = match.group(1)
            codeblock = self._outdent(codeblock)
            codeblock = self._detab(codeblock)
            codeblock = codeblock.lstrip(&#39;\n&#39;)  # trim leading newlines
            codeblock = codeblock.rstrip()      # trim trailing whitespace

        # Use pygments only if not using the highlightjs-lang extra
        if lexer_name and &#34;highlightjs-lang&#34; not in self.extras:
            lexer = self._get_pygments_lexer(lexer_name)
            if lexer:
                leading_indent = &#39; &#39;*(len(match.group(1)) - len(match.group(1).lstrip()))
                return self._code_block_with_lexer_sub(codeblock, leading_indent, lexer, is_fenced_code_block)

        pre_class_str = self._html_class_str_from_tag(&#34;pre&#34;)

        if &#34;highlightjs-lang&#34; in self.extras and lexer_name:
            code_class_str = &#39; class=&#34;%s language-%s&#34;&#39; % (lexer_name, lexer_name)
        else:
            code_class_str = self._html_class_str_from_tag(&#34;code&#34;)

        if is_fenced_code_block:
            # Fenced code blocks need to be outdented before encoding, and then reapplied
            leading_indent = &#39; &#39; * (len(match.group(1)) - len(match.group(1).lstrip()))
            if codeblock:
                # only run the codeblock through the outdenter if not empty
                leading_indent, codeblock = self._uniform_outdent(codeblock, max_outdent=leading_indent)

            codeblock = self._encode_code(codeblock)

            if lexer_name == &#39;mermaid&#39; and &#39;mermaid&#39; in self.extras:
                return &#39;\n%s&lt;pre class=&#34;mermaid-pre&#34;&gt;&lt;div class=&#34;mermaid&#34;&gt;%s\n&lt;/div&gt;&lt;/pre&gt;\n&#39; % (
                    leading_indent, codeblock)

            return &#34;\n%s&lt;pre%s&gt;&lt;code%s&gt;%s\n&lt;/code&gt;&lt;/pre&gt;\n&#34; % (
                leading_indent, pre_class_str, code_class_str, codeblock)
        else:
            codeblock = self._encode_code(codeblock)

            return &#34;\n&lt;pre%s&gt;&lt;code%s&gt;%s\n&lt;/code&gt;&lt;/pre&gt;\n&#34; % (
                pre_class_str, code_class_str, codeblock)

    def _code_block_with_lexer_sub(self, codeblock, leading_indent, lexer, is_fenced_code_block):
        if is_fenced_code_block:
            formatter_opts = self.extras[&#39;fenced-code-blocks&#39;] or {}
        else:
            formatter_opts = {}

        def unhash_code(codeblock):
            for key, sanitized in list(self.html_spans.items()):
                codeblock = codeblock.replace(key, sanitized)
            replacements = [
                (&#34;&amp;amp;&#34;, &#34;&amp;&#34;),
                (&#34;&amp;lt;&#34;, &#34;&lt;&#34;),
                (&#34;&amp;gt;&#34;, &#34;&gt;&#34;)
            ]
            for old, new in replacements:
                codeblock = codeblock.replace(old, new)
            return codeblock
        # remove leading indent from code block
        _, codeblock = self._uniform_outdent(codeblock, max_outdent=leading_indent)

        codeblock = unhash_code(codeblock)
        colored = self._color_with_pygments(codeblock, lexer,
                                            **formatter_opts)

        # add back the indent to all lines
        return &#34;\n%s\n&#34; % self._uniform_indent(colored, leading_indent, True)

    def _html_class_str_from_tag(self, tag):
        &#34;&#34;&#34;Get the appropriate &#39; class=&#34;...&#34;&#39; string (note the leading
        space), if any, for the given tag.
        &#34;&#34;&#34;
        if &#34;html-classes&#34; not in self.extras:
            return &#34;&#34;
        try:
            html_classes_from_tag = self.extras[&#34;html-classes&#34;]
        except TypeError:
            return &#34;&#34;
        else:
            if isinstance(html_classes_from_tag, dict):
                if tag in html_classes_from_tag:
                    return &#39; class=&#34;%s&#34;&#39; % html_classes_from_tag[tag]
        return &#34;&#34;

    def _do_code_blocks(self, text):
        &#34;&#34;&#34;Process Markdown `&lt;pre&gt;&lt;code&gt;` blocks.&#34;&#34;&#34;
        code_block_re = re.compile(r&#39;&#39;&#39;
            (?:\n\n|\A\n?)
            (               # $1 = the code block -- one or more lines, starting with a space/tab
              (?:
                (?:[ ]{%d} | \t)  # Lines must start with a tab or a tab-width of spaces
                .*\n+
              )+
            )
            ((?=^[ ]{0,%d}\S)|\Z)   # Lookahead for non-space at line-start, or end of doc
            # Lookahead to make sure this block isn&#39;t already in a code block.
            # Needed when syntax highlighting is being used.
            (?!([^&lt;]|&lt;(/?)span)*\&lt;/code\&gt;)
            &#39;&#39;&#39; % (self.tab_width, self.tab_width),
            re.M | re.X)
        return code_block_re.sub(self._code_block_sub, text)

    _fenced_code_block_re = re.compile(r&#39;&#39;&#39;
        (?:\n+|\A\n?|(?&lt;=\n))
        (^[ \t]*`{3,})\s{0,99}?([\w+-]+)?\s{0,99}?\n  # $1 = opening fence (captured for back-referencing), $2 = optional lang
        (.*?)                             # $3 = code block content
        \1[ \t]*\n                      # closing fence
        &#39;&#39;&#39;, re.M | re.X | re.S)

    def _fenced_code_block_sub(self, match):
        return self._code_block_sub(match, is_fenced_code_block=True)

    def _do_fenced_code_blocks(self, text):
        &#34;&#34;&#34;Process ```-fenced unindented code blocks (&#39;fenced-code-blocks&#39; extra).&#34;&#34;&#34;
        return self._fenced_code_block_re.sub(self._fenced_code_block_sub, text)

    # Rules for a code span:
    # - backslash escapes are not interpreted in a code span
    # - to include one or or a run of more backticks the delimiters must
    #   be a longer run of backticks
    # - cannot start or end a code span with a backtick; pad with a
    #   space and that space will be removed in the emitted HTML
    # See `test/tm-cases/escapes.text` for a number of edge-case
    # examples.
    _code_span_re = re.compile(r&#39;&#39;&#39;
            (?&lt;!\\)
            (`+)        # \1 = Opening run of `
            (?!`)       # See Note A test/tm-cases/escapes.text
            (.+?)       # \2 = The code block
            (?&lt;!`)
            \1          # Matching closer
            (?!`)
        &#39;&#39;&#39;, re.X | re.S)

    def _code_span_sub(self, match):
        c = match.group(2).strip(&#34; \t&#34;)
        c = self._encode_code(c)
        return &#34;&lt;code%s&gt;%s&lt;/code&gt;&#34; % (self._html_class_str_from_tag(&#34;code&#34;), c)

    def _do_code_spans(self, text):
        #   *   Backtick quotes are used for &lt;code&gt;&lt;/code&gt; spans.
        #
        #   *   You can use multiple backticks as the delimiters if you want to
        #       include literal backticks in the code span. So, this input:
        #
        #         Just type ``foo `bar` baz`` at the prompt.
        #
        #       Will translate to:
        #
        #         &lt;p&gt;Just type &lt;code&gt;foo `bar` baz&lt;/code&gt; at the prompt.&lt;/p&gt;
        #
        #       There&#39;s no arbitrary limit to the number of backticks you
        #       can use as delimters. If you need three consecutive backticks
        #       in your code, use four for delimiters, etc.
        #
        #   *   You can use spaces to get literal backticks at the edges:
        #
        #         ... type `` `bar` `` ...
        #
        #       Turns to:
        #
        #         ... type &lt;code&gt;`bar`&lt;/code&gt; ...
        return self._code_span_re.sub(self._code_span_sub, text)

    def _encode_code(self, text):
        &#34;&#34;&#34;Encode/escape certain characters inside Markdown code runs.
        The point is that in code, these characters are literals,
        and lose their special Markdown meanings.
        &#34;&#34;&#34;
        replacements = [
            # Encode all ampersands; HTML entities are not
            # entities within a Markdown code span.
            (&#39;&amp;&#39;, &#39;&amp;amp;&#39;),
            # Do the angle bracket song and dance:
            (&#39;&lt;&#39;, &#39;&amp;lt;&#39;),
            (&#39;&gt;&#39;, &#39;&amp;gt;&#39;),
        ]
        for before, after in replacements:
            text = text.replace(before, after)
        hashed = _hash_text(text)
        self._code_table[text] = hashed
        return hashed

    def _wavedrom_block_sub(self, match):
        # if this isn&#39;t a wavedrom diagram block, exit now
        if match.group(2) != &#39;wavedrom&#39;:
            return match.string[match.start():match.end()]

        # dedent the block for processing
        lead_indent, waves = self._uniform_outdent(match.group(3))
        # default tags to wrap the wavedrom block in
        open_tag, close_tag = &#39;&lt;script type=&#34;WaveDrom&#34;&gt;\n&#39;, &#39;&lt;/script&gt;&#39;

        # check if the user would prefer to have the SVG embedded directly
        if not isinstance(self.extras[&#39;wavedrom&#39;], dict):
            embed_svg = True
        else:
            # default behaviour is to embed SVGs
            embed_svg = self.extras[&#39;wavedrom&#39;].get(&#39;prefer_embed_svg&#39;, True)

        if embed_svg:
            try:
                import wavedrom
                waves = wavedrom.render(waves).tostring()
                open_tag, close_tag = &#39;&lt;div&gt;&#39;, &#39;\n&lt;/div&gt;&#39;
            except ImportError:
                pass

        # hash SVG to prevent &lt;&gt; chars being messed with
        self._escape_table[waves] = _hash_text(waves)

        return self._uniform_indent(
            &#39;\n%s%s%s\n&#39; % (open_tag, self._escape_table[waves], close_tag),
            lead_indent, include_empty_lines=True
        )

    def _do_wavedrom_blocks(self, text):
        return self._fenced_code_block_re.sub(self._wavedrom_block_sub, text)

    _admonitions = r&#39;admonition|attention|caution|danger|error|hint|important|note|tip|warning&#39;
    _admonitions_re = re.compile(r&#39;&#39;&#39;
        ^(\ *)\.\.\ (%s)::\ *                # $1 leading indent, $2 the admonition
        (.*)?                                # $3 admonition title
        ((?:\s*\n\1\ {3,}.*)+?)              # $4 admonition body (required)
        (?=\s*(?:\Z|\n{4,}|\n\1?\ {0,2}\S))  # until EOF, 3 blank lines or something less indented
        &#39;&#39;&#39; % _admonitions,
        re.IGNORECASE | re.MULTILINE | re.VERBOSE
    )

    def _do_admonitions_sub(self, match):
        lead_indent, admonition_name, title, body = match.groups()

        admonition_type = &#39;&lt;strong&gt;%s&lt;/strong&gt;&#39; % admonition_name

        # figure out the class names to assign the block
        if admonition_name.lower() == &#39;admonition&#39;:
            admonition_class = &#39;admonition&#39;
        else:
            admonition_class = &#39;admonition %s&#39; % admonition_name.lower()

        # titles are generally optional
        if title:
            title = &#39;&lt;em&gt;%s&lt;/em&gt;&#39; % title

        # process the admonition body like regular markdown
        body = self._run_block_gamut(&#34;\n%s\n&#34; % self._uniform_outdent(body)[1])

        # indent the body before placing inside the aside block
        admonition = self._uniform_indent(&#39;%s\n%s\n\n%s\n&#39; % (admonition_type, title, body), self.tab, False)
        # wrap it in an aside
        admonition = &#39;&lt;aside class=&#34;%s&#34;&gt;\n%s&lt;/aside&gt;&#39; % (admonition_class, admonition)
        # now indent the whole admonition back to where it started
        return self._uniform_indent(admonition, lead_indent, False)

    def _do_admonitions(self, text):
        return self._admonitions_re.sub(self._do_admonitions_sub, text)

    _strike_re = re.compile(r&#34;~~(?=\S)(.+?)(?&lt;=\S)~~&#34;, re.S)
    def _do_strike(self, text):
        text = self._strike_re.sub(r&#34;&lt;s&gt;\1&lt;/s&gt;&#34;, text)
        return text

    _underline_re = re.compile(r&#34;(?&lt;!&lt;!)--(?!&gt;)(?=\S)(.+?)(?&lt;=\S)(?&lt;!&lt;!)--(?!&gt;)&#34;, re.S)
    def _do_underline(self, text):
        text = self._underline_re.sub(r&#34;&lt;u&gt;\1&lt;/u&gt;&#34;, text)
        return text

    _tg_spoiler_re = re.compile(r&#34;\|\|\s?(.+?)\s?\|\|&#34;, re.S)
    def _do_tg_spoiler(self, text):
        text = self._tg_spoiler_re.sub(r&#34;&lt;tg-spoiler&gt;\1&lt;/tg-spoiler&gt;&#34;, text)
        return text

    _strong_re = re.compile(r&#34;(\*\*|__)(?=\S)(.+?[*_]*)(?&lt;=\S)\1&#34;, re.S)
    _em_re = re.compile(r&#34;(\*|_)(?=\S)(.+?)(?&lt;=\S)\1&#34;, re.S)
    _code_friendly_strong_re = re.compile(r&#34;\*\*(?=\S)(.+?[*_]*)(?&lt;=\S)\*\*&#34;, re.S)
    _code_friendly_em_re = re.compile(r&#34;\*(?=\S)(.+?)(?&lt;=\S)\*&#34;, re.S)
    def _do_italics_and_bold(self, text):
        # &lt;strong&gt; must go first:
        if &#34;code-friendly&#34; in self.extras:
            text = self._code_friendly_strong_re.sub(r&#34;&lt;strong&gt;\1&lt;/strong&gt;&#34;, text)
            text = self._code_friendly_em_re.sub(r&#34;&lt;em&gt;\1&lt;/em&gt;&#34;, text)
        else:
            text = self._strong_re.sub(r&#34;&lt;strong&gt;\2&lt;/strong&gt;&#34;, text)
            text = self._em_re.sub(r&#34;&lt;em&gt;\2&lt;/em&gt;&#34;, text)
        return text

    # &#34;smarty-pants&#34; extra: Very liberal in interpreting a single prime as an
    # apostrophe; e.g. ignores the fact that &#34;round&#34;, &#34;bout&#34;, &#34;twer&#34;, and
    # &#34;twixt&#34; can be written without an initial apostrophe. This is fine because
    # using scare quotes (single quotation marks) is rare.
    _apostrophe_year_re = re.compile(r&#34;&#39;(\d\d)(?=(\s|,|;|\.|\?|!|$))&#34;)
    _contractions = [&#34;tis&#34;, &#34;twas&#34;, &#34;twer&#34;, &#34;neath&#34;, &#34;o&#34;, &#34;n&#34;,
        &#34;round&#34;, &#34;bout&#34;, &#34;twixt&#34;, &#34;nuff&#34;, &#34;fraid&#34;, &#34;sup&#34;]
    def _do_smart_contractions(self, text):
        text = self._apostrophe_year_re.sub(r&#34;&amp;#8217;\1&#34;, text)
        for c in self._contractions:
            text = text.replace(&#34;&#39;%s&#34; % c, &#34;&amp;#8217;%s&#34; % c)
            text = text.replace(&#34;&#39;%s&#34; % c.capitalize(),
                &#34;&amp;#8217;%s&#34; % c.capitalize())
        return text

    # Substitute double-quotes before single-quotes.
    _opening_single_quote_re = re.compile(r&#34;(?&lt;!\S)&#39;(?=\S)&#34;)
    _opening_double_quote_re = re.compile(r&#39;(?&lt;!\S)&#34;(?=\S)&#39;)
    _closing_single_quote_re = re.compile(r&#34;(?&lt;=\S)&#39;&#34;)
    _closing_double_quote_re = re.compile(r&#39;(?&lt;=\S)&#34;(?=(\s|,|;|\.|\?|!|$))&#39;)
    def _do_smart_punctuation(self, text):
        &#34;&#34;&#34;Fancifies &#39;single quotes&#39;, &#34;double quotes&#34;, and apostrophes.
        Converts --, ---, and ... into en dashes, em dashes, and ellipses.

        Inspiration is: &lt;http://daringfireball.net/projects/smartypants/&gt;
        See &#34;test/tm-cases/smarty_pants.text&#34; for a full discussion of the
        support here and
        &lt;http://code.google.com/p/python-markdown2/issues/detail?id=42&gt; for a
        discussion of some diversion from the original SmartyPants.
        &#34;&#34;&#34;
        if &#34;&#39;&#34; in text:  # guard for perf
            text = self._do_smart_contractions(text)
            text = self._opening_single_quote_re.sub(&#34;&amp;#8216;&#34;, text)
            text = self._closing_single_quote_re.sub(&#34;&amp;#8217;&#34;, text)

        if &#39;&#34;&#39; in text:  # guard for perf
            text = self._opening_double_quote_re.sub(&#34;&amp;#8220;&#34;, text)
            text = self._closing_double_quote_re.sub(&#34;&amp;#8221;&#34;, text)

        text = text.replace(&#34;---&#34;, &#34;&amp;#8212;&#34;)
        text = text.replace(&#34;--&#34;, &#34;&amp;#8211;&#34;)
        text = text.replace(&#34;...&#34;, &#34;&amp;#8230;&#34;)
        text = text.replace(&#34; . . . &#34;, &#34;&amp;#8230;&#34;)
        text = text.replace(&#34;. . .&#34;, &#34;&amp;#8230;&#34;)

        # TODO: Temporary hack to fix https://github.com/trentm/python-markdown2/issues/150
        if &#34;footnotes&#34; in self.extras and &#34;footnote-ref&#34; in text:
            # Quotes in the footnote back ref get converted to &#34;smart&#34; quotes
            # Change them back here to ensure they work.
            text = text.replace(&#39;class=&#34;footnote-ref&amp;#8221;&#39;, &#39;class=&#34;footnote-ref&#34;&#39;)

        return text

    _block_quote_base = r&#39;&#39;&#39;
        (                           # Wrap whole match in \1
          (
            ^[ \t]*&gt;%s[ \t]?        # &#39;&gt;&#39; at the start of a line
              .+\n                  # rest of the first line
            (.+\n)*                 # subsequent consecutive lines
          )+
        )
    &#39;&#39;&#39;
    _block_quote_re = re.compile(_block_quote_base % &#39;&#39;, re.M | re.X)
    _block_quote_re_spoiler = re.compile(_block_quote_base % &#39;[ \t]*?!?&#39;, re.M | re.X)
    _bq_one_level_re = re.compile(&#39;^[ \t]*&gt;[ \t]?&#39;, re.M)
    _bq_one_level_re_spoiler = re.compile(&#39;^[ \t]*&gt;[ \t]*?![ \t]?&#39;, re.M)
    _bq_all_lines_spoilers = re.compile(r&#39;\A(?:^[ \t]*&gt;[ \t]*?!.*[\n\r]*)+\Z&#39;, re.M)
    _html_pre_block_re = re.compile(r&#39;(\s*&lt;pre&gt;.+?&lt;/pre&gt;)&#39;, re.S)
    def _dedent_two_spaces_sub(self, match):
        return re.sub(r&#39;(?m)^  &#39;, &#39;&#39;, match.group(1))

    def _block_quote_sub(self, match):
        bq = match.group(1)
        is_spoiler = &#39;spoiler&#39; in self.extras and self._bq_all_lines_spoilers.match(bq)
        # trim one level of quoting
        if is_spoiler:
            bq = self._bq_one_level_re_spoiler.sub(&#39;&#39;, bq)
        else:
            bq = self._bq_one_level_re.sub(&#39;&#39;, bq)
        # trim whitespace-only lines
        bq = self._ws_only_line_re.sub(&#39;&#39;, bq)
        bq = self._run_block_gamut(bq)          # recurse

        bq = re.sub(&#39;(?m)^&#39;, &#39;  &#39;, bq)
        # These leading spaces screw with &lt;pre&gt; content, so we need to fix that:
        bq = self._html_pre_block_re.sub(self._dedent_two_spaces_sub, bq)

        if is_spoiler:
            return &#39;&lt;blockquote class=&#34;spoiler&#34;&gt;\n%s\n&lt;/blockquote&gt;\n\n&#39; % bq
        else:
            return &#39;&lt;blockquote&gt;\n%s\n&lt;/blockquote&gt;\n\n&#39; % bq

    def _do_block_quotes(self, text):
        if &#39;&gt;&#39; not in text:
            return text
        if &#39;spoiler&#39; in self.extras:
            return self._block_quote_re_spoiler.sub(self._block_quote_sub, text)
        else:
            return self._block_quote_re.sub(self._block_quote_sub, text)

    def _form_paragraphs(self, text):
        # Strip leading and trailing lines:
        text = text.strip(&#39;\n&#39;)

        # Wrap &lt;p&gt; tags.
        grafs = []
        for i, graf in enumerate(re.split(r&#34;\n{2,}&#34;, text)):
            if graf in self.html_blocks:
                # Unhashify HTML blocks
                grafs.append(self.html_blocks[graf])
            else:
                cuddled_list = None
                if &#34;cuddled-lists&#34; in self.extras:
                    # Need to put back trailing &#39;\n&#39; for `_list_item_re`
                    # match at the end of the paragraph.
                    li = self._list_item_re.search(graf + &#39;\n&#39;)
                    # Two of the same list marker in this paragraph: a likely
                    # candidate for a list cuddled to preceding paragraph
                    # text (issue 33). Note the `[-1]` is a quick way to
                    # consider numeric bullets (e.g. &#34;1.&#34; and &#34;2.&#34;) to be
                    # equal.
                    if (li and len(li.group(2)) &lt;= 3
                            and (
                                    (li.group(&#34;next_marker&#34;) and li.group(&#34;marker&#34;)[-1] == li.group(&#34;next_marker&#34;)[-1])
                                    or
                                    li.group(&#34;next_marker&#34;) is None
                            )
                    ):
                        start = li.start()
                        cuddled_list = self._do_lists(graf[start:]).rstrip(&#34;\n&#34;)
                        assert re.match(r&#39;^&lt;(?:ul|ol).*?&gt;&#39;, cuddled_list)
                        graf = graf[:start]

                # Wrap &lt;p&gt; tags.
                graf = self._run_span_gamut(graf)
                grafs.append(&#34;&lt;p%s&gt;&#34; % self._html_class_str_from_tag(&#39;p&#39;) + graf.lstrip(&#34; \t&#34;) + &#34;&lt;/p&gt;&#34;)

                if cuddled_list:
                    grafs.append(cuddled_list)

        return &#34;\n\n&#34;.join(grafs)

    def _add_footnotes(self, text):
        if self.footnotes:
            footer = [
                &#39;&lt;div class=&#34;footnotes&#34;&gt;&#39;,
                &#39;&lt;hr&#39; + self.empty_element_suffix,
                &#39;&lt;ol&gt;&#39;,
            ]

            if not self.footnote_title:
                self.footnote_title = &#34;Jump back to footnote %d in the text.&#34;
            if not self.footnote_return_symbol:
                self.footnote_return_symbol = &#34;&amp;#8617;&#34;

            for i, id in enumerate(self.footnote_ids):
                if i != 0:
                    footer.append(&#39;&#39;)
                footer.append(&#39;&lt;li id=&#34;fn-%s&#34;&gt;&#39; % id)
                footer.append(self._run_block_gamut(self.footnotes[id]))
                try:
                    backlink = (&#39;&lt;a href=&#34;#fnref-%s&#34; &#39; +
                            &#39;class=&#34;footnoteBackLink&#34; &#39; +
                            &#39;title=&#34;&#39; + self.footnote_title + &#39;&#34;&gt;&#39; +
                            self.footnote_return_symbol +
                            &#39;&lt;/a&gt;&#39;) % (id, i+1)
                except TypeError:
                    log.debug(&#34;Footnote error. `footnote_title` &#34;
                              &#34;must include parameter. Using defaults.&#34;)
                    backlink = (&#39;&lt;a href=&#34;#fnref-%s&#34; &#39;
                        &#39;class=&#34;footnoteBackLink&#34; &#39;
                        &#39;title=&#34;Jump back to footnote %d in the text.&#34;&gt;&#39;
                        &#39;&amp;#8617;&lt;/a&gt;&#39; % (id, i+1))

                if footer[-1].endswith(&#34;&lt;/p&gt;&#34;):
                    footer[-1] = footer[-1][:-len(&#34;&lt;/p&gt;&#34;)] \
                        + &#39;&amp;#160;&#39; + backlink + &#34;&lt;/p&gt;&#34;
                else:
                    footer.append(&#34;\n&lt;p&gt;%s&lt;/p&gt;&#34; % backlink)
                footer.append(&#39;&lt;/li&gt;&#39;)
            footer.append(&#39;&lt;/ol&gt;&#39;)
            footer.append(&#39;&lt;/div&gt;&#39;)
            return text + &#39;\n\n&#39; + &#39;\n&#39;.join(footer)
        else:
            return text

    _naked_lt_re = re.compile(r&#39;&lt;(?![a-z/?\$!])&#39;, re.I)
    _naked_gt_re = re.compile(r&#39;&#39;&#39;(?&lt;![a-z0-9?!/&#39;&#34;-])&gt;&#39;&#39;&#39;, re.I)

    def _encode_amps_and_angles(self, text):
        # Smart processing for ampersands and angle brackets that need
        # to be encoded.
        text = _AMPERSAND_RE.sub(&#39;&amp;amp;&#39;, text)

        # Encode naked &lt;&#39;s
        text = self._naked_lt_re.sub(&#39;&amp;lt;&#39;, text)

        # Encode naked &gt;&#39;s
        # Note: Other markdown implementations (e.g. Markdown.pl, PHP
        # Markdown) don&#39;t do this.
        text = self._naked_gt_re.sub(&#39;&amp;gt;&#39;, text)
        return text

    _incomplete_tags_re = re.compile(r&#34;&lt;(/?\w+?(?!\w)\s*?.+?[\s/]+?)&#34;)

    def _encode_incomplete_tags(self, text):
        if self.safe_mode not in (&#34;replace&#34;, &#34;escape&#34;):
            return text

        if text.endswith(&#34;&gt;&#34;):
            return text  # this is not an incomplete tag, this is a link in the form &lt;http://x.y.z&gt;

        def incomplete_tags_sub(match):
            return match.group().replace(&#39;&lt;&#39;, &#39;&amp;lt;&#39;)

        return self._incomplete_tags_re.sub(incomplete_tags_sub, text)

    def _encode_backslash_escapes(self, text):
        for ch, escape in list(self._escape_table.items()):
            text = text.replace(&#34;\\&#34;+ch, escape)
        return text

    _auto_link_re = re.compile(r&#39;&lt;((https?|ftp):[^\&#39;&#34;&gt;\s]+)&gt;&#39;, re.I)
    def _auto_link_sub(self, match):
        g1 = match.group(1)
        return &#39;&lt;a href=&#34;%s&#34;&gt;%s&lt;/a&gt;&#39; % (self._protect_url(g1), g1)

    _auto_email_link_re = re.compile(r&#34;&#34;&#34;
          &lt;
           (?:mailto:)?
          (
              [-.\w]+
              \@
              [-\w]+(\.[-\w]+)*\.[a-z]+
          )
          &gt;
        &#34;&#34;&#34;, re.I | re.X | re.U)
    def _auto_email_link_sub(self, match):
        return self._encode_email_address(
            self._unescape_special_chars(match.group(1)))

    def _do_auto_links(self, text):
        text = self._auto_link_re.sub(self._auto_link_sub, text)
        text = self._auto_email_link_re.sub(self._auto_email_link_sub, text)
        return text

    def _encode_email_address(self, addr):
        #  Input: an email address, e.g. &#34;foo@example.com&#34;
        #
        #  Output: the email address as a mailto link, with each character
        #      of the address encoded as either a decimal or hex entity, in
        #      the hopes of foiling most address harvesting spam bots. E.g.:
        #
        #    &lt;a href=&#34;&amp;#x6D;&amp;#97;&amp;#105;&amp;#108;&amp;#x74;&amp;#111;:&amp;#102;&amp;#111;&amp;#111;&amp;#64;&amp;#101;
        #       x&amp;#x61;&amp;#109;&amp;#x70;&amp;#108;&amp;#x65;&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&#34;&gt;&amp;#102;&amp;#111;&amp;#111;
        #       &amp;#64;&amp;#101;x&amp;#x61;&amp;#109;&amp;#x70;&amp;#108;&amp;#x65;&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;
        #
        #  Based on a filter by Matthew Wickline, posted to the BBEdit-Talk
        #  mailing list: &lt;http://tinyurl.com/yu7ue&gt;
        chars = [_xml_encode_email_char_at_random(ch)
                 for ch in &#34;mailto:&#34; + addr]
        # Strip the mailto: from the visible part.
        addr = &#39;&lt;a href=&#34;%s&#34;&gt;%s&lt;/a&gt;&#39; \
               % (&#39;&#39;.join(chars), &#39;&#39;.join(chars[7:]))
        return addr

    _basic_link_re = re.compile(r&#39;!?\[.*?\]\(.*?\)&#39;)
    def _do_link_patterns(self, text):
        link_from_hash = {}
        for regex, repl in self.link_patterns:
            replacements = []
            for match in regex.finditer(text):
                if any(self._match_overlaps_substr(text, match, h) for h in link_from_hash):
                    continue

                if hasattr(repl, &#34;__call__&#34;):
                    href = repl(match)
                else:
                    href = match.expand(repl)
                replacements.append((match.span(), href))
            for (start, end), href in reversed(replacements):

                # Do not match against links inside brackets.
                if text[start - 1:start] == &#39;[&#39; and text[end:end + 1] == &#39;]&#39;:
                    continue

                # Do not match against links in the standard markdown syntax.
                if text[start - 2:start] == &#39;](&#39; or text[end:end + 2] == &#39;&#34;)&#39;:
                    continue

                # Do not match against links which are escaped.
                if text[start - 3:start] == &#39;&#34;&#34;&#34;&#39; and text[end:end + 3] == &#39;&#34;&#34;&#34;&#39;:
                    text = text[:start - 3] + text[start:end] + text[end + 3:]
                    continue

                # search the text for anything that looks like a link
                is_inside_link = False
                for link_re in (self._auto_link_re, self._basic_link_re):
                    for match in link_re.finditer(text):
                        if any((r[0] &lt;= start and end &lt;= r[1]) for r in match.regs):
                            # if the link pattern start and end pos is within the bounds of
                            # something that looks like a link, then don&#39;t process it
                            is_inside_link = True
                            break
                    else:
                        continue
                    break

                if is_inside_link:
                    continue

                escaped_href = (
                    href.replace(&#39;&#34;&#39;, &#39;&amp;quot;&#39;)  # b/c of attr quote
                        # To avoid markdown &lt;em&gt; and &lt;strong&gt;:
                        .replace(&#39;*&#39;, self._escape_table[&#39;*&#39;])
                        .replace(&#39;_&#39;, self._escape_table[&#39;_&#39;]))
                link = &#39;&lt;a href=&#34;%s&#34;&gt;%s&lt;/a&gt;&#39; % (escaped_href, text[start:end])
                hash = _hash_text(link)
                link_from_hash[hash] = link
                text = text[:start] + hash + text[end:]
        for hash, link in list(link_from_hash.items()):
            text = text.replace(hash, link)
        return text

    def _unescape_special_chars(self, text):
        # Swap back in all the special characters we&#39;ve hidden.
        while True:
            orig_text = text
            for ch, hash in list(self._escape_table.items()) + list(self._code_table.items()):
                text = text.replace(hash, ch)
            if text == orig_text:
                break
        return text

    def _outdent(self, text):
        # Remove one level of line-leading tabs or spaces
        return self._outdent_re.sub(&#39;&#39;, text)

    def _uniform_outdent(self, text, min_outdent=None, max_outdent=None):
        # Removes the smallest common leading indentation from each (non empty)
        # line of `text` and returns said indent along with the outdented text.
        # The `min_outdent` kwarg makes sure the smallest common whitespace
        # must be at least this size
        # The `max_outdent` sets the maximum amount a line can be
        # outdented by

        # find the leading whitespace for every line
        whitespace = [
            re.findall(r&#39;^[ \t]*&#39;, line)[0] if line else None
            for line in text.splitlines()
        ]
        whitespace_not_empty = [i for i in whitespace if i is not None]

        # if no whitespace detected (ie: no lines in code block, issue #505)
        if not whitespace_not_empty:
            return &#39;&#39;, text

        # get minimum common whitespace
        outdent = min(whitespace_not_empty)
        # adjust min common ws to be within bounds
        if min_outdent is not None:
            outdent = min([i for i in whitespace_not_empty if i &gt;= min_outdent] or [min_outdent])
        if max_outdent is not None:
            outdent = min(outdent, max_outdent)

        outdented = []
        for line_ws, line in zip(whitespace, text.splitlines(True)):
            if line.startswith(outdent):
                # if line starts with smallest common ws, dedent it
                outdented.append(line.replace(outdent, &#39;&#39;, 1))
            elif line_ws is not None and line_ws &lt; outdent:
                # if less indented than min common whitespace then outdent as much as possible
                outdented.append(line.replace(line_ws, &#39;&#39;, 1))
            else:
                outdented.append(line)

        return outdent, &#39;&#39;.join(outdented)

    def _uniform_indent(self, text, indent, include_empty_lines=False):
        return &#39;&#39;.join(
            (indent + line if line.strip() or include_empty_lines else &#39;&#39;)
            for line in text.splitlines(True)
        )

    @staticmethod
    def _match_overlaps_substr(text, match, substr):
        &#39;&#39;&#39;
        Checks if a regex match overlaps with a substring in the given text.
        &#39;&#39;&#39;
        for instance in re.finditer(re.escape(substr), text):
            start, end = instance.span()
            if start &lt;= match.start() &lt;= end:
                return True
            if start &lt;= match.end() &lt;= end:
                return True
        return False</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pdoc.markdown2.MarkdownWithExtras" href="#pdoc.markdown2.MarkdownWithExtras">MarkdownWithExtras</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pdoc.markdown2.Markdown.extras"><code class="name">var <span class="ident">extras</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pdoc.markdown2.Markdown.html_blocks"><code class="name">var <span class="ident">html_blocks</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pdoc.markdown2.Markdown.html_removed_text"><code class="name">var <span class="ident">html_removed_text</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pdoc.markdown2.Markdown.html_removed_text_compat"><code class="name">var <span class="ident">html_removed_text_compat</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pdoc.markdown2.Markdown.html_spans"><code class="name">var <span class="ident">html_spans</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pdoc.markdown2.Markdown.list_level"><code class="name">var <span class="ident">list_level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pdoc.markdown2.Markdown.titles"><code class="name">var <span class="ident">titles</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pdoc.markdown2.Markdown.urls"><code class="name">var <span class="ident">urls</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pdoc.markdown2.Markdown.convert"><code class="name flex">
<span>def <span class="ident">convert</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the given text.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert(self, text):
    &#34;&#34;&#34;Convert the given text.&#34;&#34;&#34;
    # Main function. The order in which other subs are called here is
    # essential. Link and image substitutions need to happen before
    # _EscapeSpecialChars(), so that any *&#39;s or _&#39;s in the &lt;a&gt;
    # and &lt;img&gt; tags get encoded.

    # Clear the global hashes. If we don&#39;t clear these, you get conflicts
    # from other articles when generating a page which contains more than
    # one article (e.g. an index page that shows the N most recent
    # articles):
    self.reset()

    if not isinstance(text, str):
        # TODO: perhaps shouldn&#39;t presume UTF-8 for string input?
        text = str(text, &#39;utf-8&#39;)

    if self.use_file_vars:
        # Look for emacs-style file variable hints.
        text = self._emacs_oneliner_vars_pat.sub(self._emacs_vars_oneliner_sub, text)
        emacs_vars = self._get_emacs_vars(text)
        if &#34;markdown-extras&#34; in emacs_vars:
            splitter = re.compile(&#34;[ ,]+&#34;)
            for e in splitter.split(emacs_vars[&#34;markdown-extras&#34;]):
                if &#39;=&#39; in e:
                    ename, earg = e.split(&#39;=&#39;, 1)
                    try:
                        earg = int(earg)
                    except ValueError:
                        pass
                else:
                    ename, earg = e, None
                self.extras[ename] = earg

        self._setup_extras()

    # Standardize line endings:
    text = text.replace(&#34;\r\n&#34;, &#34;\n&#34;)
    text = text.replace(&#34;\r&#34;, &#34;\n&#34;)

    # Make sure $text ends with a couple of newlines:
    text += &#34;\n\n&#34;

    # Convert all tabs to spaces.
    text = self._detab(text)

    # Strip any lines consisting only of spaces and tabs.
    # This makes subsequent regexen easier to write, because we can
    # match consecutive blank lines with /\n+/ instead of something
    # contorted like /[ \t]*\n+/ .
    text = self._ws_only_line_re.sub(&#34;&#34;, text)

    # strip metadata from head and extract
    if &#34;metadata&#34; in self.extras:
        text = self._extract_metadata(text)

    text = self.preprocess(text)

    if &#39;wavedrom&#39; in self.extras:
        text = self._do_wavedrom_blocks(text)

    if &#34;fenced-code-blocks&#34; in self.extras and not self.safe_mode:
        text = self._do_fenced_code_blocks(text)

    if self.safe_mode:
        text = self._hash_html_spans(text)

    # Turn block-level HTML blocks into hash entries
    text = self._hash_html_blocks(text, raw=True)

    if &#34;fenced-code-blocks&#34; in self.extras and self.safe_mode:
        text = self._do_fenced_code_blocks(text)

    if &#39;admonitions&#39; in self.extras:
        text = self._do_admonitions(text)

    # Because numbering references aren&#39;t links (yet?) then we can do everything associated with counters
    # before we get started
    if &#34;numbering&#34; in self.extras:
        text = self._do_numbering(text)

    # Strip link definitions, store in hashes.
    if &#34;footnotes&#34; in self.extras:
        # Must do footnotes first because an unlucky footnote defn
        # looks like a link defn:
        #   [^4]: this &#34;looks like a link defn&#34;
        text = self._strip_footnote_definitions(text)
    text = self._strip_link_definitions(text)

    text = self._run_block_gamut(text)

    if &#34;footnotes&#34; in self.extras:
        text = self._add_footnotes(text)

    text = self.postprocess(text)

    text = self._unescape_special_chars(text)

    if self.safe_mode:
        text = self._unhash_html_spans(text)
        # return the removed text warning to its markdown.py compatible form
        text = text.replace(self.html_removed_text, self.html_removed_text_compat)

    do_target_blank_links = &#34;target-blank-links&#34; in self.extras
    do_nofollow_links = &#34;nofollow&#34; in self.extras

    if do_target_blank_links and do_nofollow_links:
        text = self._a_nofollow_or_blank_links.sub(r&#39;&lt;\1 rel=&#34;nofollow noopener&#34; target=&#34;_blank&#34;\2&#39;, text)
    elif do_target_blank_links:
        text = self._a_nofollow_or_blank_links.sub(r&#39;&lt;\1 rel=&#34;noopener&#34; target=&#34;_blank&#34;\2&#39;, text)
    elif do_nofollow_links:
        text = self._a_nofollow_or_blank_links.sub(r&#39;&lt;\1 rel=&#34;nofollow&#34;\2&#39;, text)

    if &#34;toc&#34; in self.extras and self._toc:
        self._toc_html = calculate_toc_html(self._toc)

        # Prepend toc html to output
        if self.cli:
            text = &#39;{}\n{}&#39;.format(self._toc_html, text)

    text += &#34;\n&#34;

    # Attach attrs to output
    rv = UnicodeWithAttrs(text)

    if &#34;toc&#34; in self.extras and self._toc:
        rv.toc_html = self._toc_html

    if &#34;metadata&#34; in self.extras:
        rv.metadata = self.metadata
    return rv</code></pre>
</details>
</dd>
<dt id="pdoc.markdown2.Markdown.header_id_from_text"><code class="name flex">
<span>def <span class="ident">header_id_from_text</span></span>(<span>self, text, prefix, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a header id attribute value from the given header
HTML content.</p>
<p>This is only called if the "header-ids" extra is enabled.
Subclasses may override this for different header ids.</p>
<p>@param text {str} The text of the header tag
@param prefix {str} The requested prefix for header ids. This is the
value of the "header-ids" extra key, if any. Otherwise, None.
@param n {int} The <hN> tag number, i.e. <code>1</code> for an <h1> tag.
@returns {str} The value for the header tag's "id" attribute. Return
None to not have an id attribute and to exclude this header from
the TOC (if the "toc" extra is specified).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header_id_from_text(self, text, prefix, n):
    &#34;&#34;&#34;Generate a header id attribute value from the given header
    HTML content.

    This is only called if the &#34;header-ids&#34; extra is enabled.
    Subclasses may override this for different header ids.

    @param text {str} The text of the header tag
    @param prefix {str} The requested prefix for header ids. This is the
        value of the &#34;header-ids&#34; extra key, if any. Otherwise, None.
    @param n {int} The &lt;hN&gt; tag number, i.e. `1` for an &lt;h1&gt; tag.
    @returns {str} The value for the header tag&#39;s &#34;id&#34; attribute. Return
        None to not have an id attribute and to exclude this header from
        the TOC (if the &#34;toc&#34; extra is specified).
    &#34;&#34;&#34;
    header_id = _slugify(text)
    if prefix and isinstance(prefix, str):
        header_id = prefix + &#39;-&#39; + header_id

    self._count_from_header_id[header_id] += 1
    if 0 == len(header_id) or self._count_from_header_id[header_id] &gt; 1:
        header_id += &#39;-%s&#39; % self._count_from_header_id[header_id]

    return header_id</code></pre>
</details>
</dd>
<dt id="pdoc.markdown2.Markdown.postprocess"><code class="name flex">
<span>def <span class="ident">postprocess</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>A hook for subclasses to do some postprocessing of the html, if
desired. This is called before unescaping of special chars and
unhashing of raw HTML spans.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def postprocess(self, text):
    &#34;&#34;&#34;A hook for subclasses to do some postprocessing of the html, if
    desired. This is called before unescaping of special chars and
    unhashing of raw HTML spans.
    &#34;&#34;&#34;
    return text</code></pre>
</details>
</dd>
<dt id="pdoc.markdown2.Markdown.preprocess"><code class="name flex">
<span>def <span class="ident">preprocess</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>A hook for subclasses to do some preprocessing of the Markdown, if
desired. This is called after basic formatting of the text, but prior
to any extras, safe mode, etc. processing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess(self, text):
    &#34;&#34;&#34;A hook for subclasses to do some preprocessing of the Markdown, if
    desired. This is called after basic formatting of the text, but prior
    to any extras, safe mode, etc. processing.
    &#34;&#34;&#34;
    return text</code></pre>
</details>
</dd>
<dt id="pdoc.markdown2.Markdown.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    self.urls = {}
    self.titles = {}
    self.html_blocks = {}
    self.html_spans = {}
    self.list_level = 0
    self.extras = self._instance_extras.copy()
    self._setup_extras()
    self._toc = None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pdoc.markdown2.MarkdownError"><code class="flex name class">
<span>class <span class="ident">MarkdownError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MarkdownError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="pdoc.markdown2.MarkdownWithExtras"><code class="flex name class">
<span>class <span class="ident">MarkdownWithExtras</span></span>
<span>(</span><span>html4tags=False, tab_width=4, safe_mode=None, extras=None, link_patterns=None, footnote_title=None, footnote_return_symbol=None, use_file_vars=False, cli=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A markdowner class that enables most extras:</p>
<ul>
<li>footnotes</li>
<li>fenced-code-blocks (only highlights code if 'pygments' Python module on path)</li>
</ul>
<p>These are not included:
- pyshell (specific to Python-related documenting)
- code-friendly (because it <em>disables</em> part of the syntax)
- link-patterns (because you need to specify some actual
link-patterns anyway)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MarkdownWithExtras(Markdown):
    &#34;&#34;&#34;A markdowner class that enables most extras:

    - footnotes
    - fenced-code-blocks (only highlights code if &#39;pygments&#39; Python module on path)

    These are not included:
    - pyshell (specific to Python-related documenting)
    - code-friendly (because it *disables* part of the syntax)
    - link-patterns (because you need to specify some actual
      link-patterns anyway)
    &#34;&#34;&#34;
    extras = [&#34;footnotes&#34;, &#34;fenced-code-blocks&#34;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdoc.markdown2.Markdown" href="#pdoc.markdown2.Markdown">Markdown</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pdoc.markdown2.MarkdownWithExtras.extras"><code class="name">var <span class="ident">extras</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdoc.markdown2.Markdown" href="#pdoc.markdown2.Markdown">Markdown</a></b></code>:
<ul class="hlist">
<li><code><a title="pdoc.markdown2.Markdown.convert" href="#pdoc.markdown2.Markdown.convert">convert</a></code></li>
<li><code><a title="pdoc.markdown2.Markdown.header_id_from_text" href="#pdoc.markdown2.Markdown.header_id_from_text">header_id_from_text</a></code></li>
<li><code><a title="pdoc.markdown2.Markdown.postprocess" href="#pdoc.markdown2.Markdown.postprocess">postprocess</a></code></li>
<li><code><a title="pdoc.markdown2.Markdown.preprocess" href="#pdoc.markdown2.Markdown.preprocess">preprocess</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdoc.markdown2.UnicodeWithAttrs"><code class="flex name class">
<span>class <span class="ident">UnicodeWithAttrs</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of unicode used for the return value of conversion to
possibly attach some attributes. E.g. the "toc_html" attribute when
the "toc" extra is used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnicodeWithAttrs(str):
    &#34;&#34;&#34;A subclass of unicode used for the return value of conversion to
    possibly attach some attributes. E.g. the &#34;toc_html&#34; attribute when
    the &#34;toc&#34; extra is used.
    &#34;&#34;&#34;
    metadata = None
    toc_html = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pdoc.markdown2.UnicodeWithAttrs.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pdoc.markdown2.UnicodeWithAttrs.toc_html"><code class="name">var <span class="ident">toc_html</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pdoc" href="../index.html">pdoc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pdoc.markdown2.calculate_toc_html" href="#pdoc.markdown2.calculate_toc_html">calculate_toc_html</a></code></li>
<li><code><a title="pdoc.markdown2.main" href="#pdoc.markdown2.main">main</a></code></li>
<li><code><a title="pdoc.markdown2.markdown" href="#pdoc.markdown2.markdown">markdown</a></code></li>
<li><code><a title="pdoc.markdown2.markdown_path" href="#pdoc.markdown2.markdown_path">markdown_path</a></code></li>
<li><code><a title="pdoc.markdown2.random" href="#pdoc.markdown2.random">random</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pdoc.markdown2.Markdown" href="#pdoc.markdown2.Markdown">Markdown</a></code></h4>
<ul class="">
<li><code><a title="pdoc.markdown2.Markdown.convert" href="#pdoc.markdown2.Markdown.convert">convert</a></code></li>
<li><code><a title="pdoc.markdown2.Markdown.extras" href="#pdoc.markdown2.Markdown.extras">extras</a></code></li>
<li><code><a title="pdoc.markdown2.Markdown.header_id_from_text" href="#pdoc.markdown2.Markdown.header_id_from_text">header_id_from_text</a></code></li>
<li><code><a title="pdoc.markdown2.Markdown.html_blocks" href="#pdoc.markdown2.Markdown.html_blocks">html_blocks</a></code></li>
<li><code><a title="pdoc.markdown2.Markdown.html_removed_text" href="#pdoc.markdown2.Markdown.html_removed_text">html_removed_text</a></code></li>
<li><code><a title="pdoc.markdown2.Markdown.html_removed_text_compat" href="#pdoc.markdown2.Markdown.html_removed_text_compat">html_removed_text_compat</a></code></li>
<li><code><a title="pdoc.markdown2.Markdown.html_spans" href="#pdoc.markdown2.Markdown.html_spans">html_spans</a></code></li>
<li><code><a title="pdoc.markdown2.Markdown.list_level" href="#pdoc.markdown2.Markdown.list_level">list_level</a></code></li>
<li><code><a title="pdoc.markdown2.Markdown.postprocess" href="#pdoc.markdown2.Markdown.postprocess">postprocess</a></code></li>
<li><code><a title="pdoc.markdown2.Markdown.preprocess" href="#pdoc.markdown2.Markdown.preprocess">preprocess</a></code></li>
<li><code><a title="pdoc.markdown2.Markdown.reset" href="#pdoc.markdown2.Markdown.reset">reset</a></code></li>
<li><code><a title="pdoc.markdown2.Markdown.titles" href="#pdoc.markdown2.Markdown.titles">titles</a></code></li>
<li><code><a title="pdoc.markdown2.Markdown.urls" href="#pdoc.markdown2.Markdown.urls">urls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pdoc.markdown2.MarkdownError" href="#pdoc.markdown2.MarkdownError">MarkdownError</a></code></h4>
</li>
<li>
<h4><code><a title="pdoc.markdown2.MarkdownWithExtras" href="#pdoc.markdown2.MarkdownWithExtras">MarkdownWithExtras</a></code></h4>
<ul class="">
<li><code><a title="pdoc.markdown2.MarkdownWithExtras.extras" href="#pdoc.markdown2.MarkdownWithExtras.extras">extras</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pdoc.markdown2.UnicodeWithAttrs" href="#pdoc.markdown2.UnicodeWithAttrs">UnicodeWithAttrs</a></code></h4>
<ul class="">
<li><code><a title="pdoc.markdown2.UnicodeWithAttrs.metadata" href="#pdoc.markdown2.UnicodeWithAttrs.metadata">metadata</a></code></li>
<li><code><a title="pdoc.markdown2.UnicodeWithAttrs.toc_html" href="#pdoc.markdown2.UnicodeWithAttrs.toc_html">toc_html</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>