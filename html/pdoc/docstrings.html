<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pdoc.docstrings API documentation</title>
<meta name="description" content="This module handles the conversion of docstring flavors to Markdown …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pdoc.docstrings</code></h1>
</header>
<section id="section-intro">
<p>This module handles the conversion of docstring flavors to Markdown.</p>
<p>The conversion from docstring flavors to Markdown is mostly done with regular expressions.
This is not particularly beautiful, but good enough for our purposes.
The alternative would be to depend on <a href="https://github.com/rr-/docstring_parser">https://github.com/rr-/docstring_parser</a> or a similar project,
but that introduces more complexity than we are comfortable with.</p>
<p>If you miss a particular feature for your favorite flavor, contributions are welcome.
That being said, please keep the complexity low and make sure that changes are
accompanied by matching snapshot tests in <code>test/testdata/</code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module handles the conversion of docstring flavors to Markdown.

The conversion from docstring flavors to Markdown is mostly done with regular expressions.
This is not particularly beautiful, but good enough for our purposes.
The alternative would be to depend on &lt;https://github.com/rr-/docstring_parser&gt; or a similar project,
but that introduces more complexity than we are comfortable with.

If you miss a particular feature for your favorite flavor, contributions are welcome.
That being said, please keep the complexity low and make sure that changes are
accompanied by matching snapshot tests in `test/testdata/`.
&#34;&#34;&#34;
from __future__ import annotations

import base64
import inspect
import mimetypes
import os
from pathlib import Path
import re
from textwrap import dedent
from textwrap import indent
import warnings

from ._compat import cache


@cache
def convert(docstring: str, docformat: str, source_file: Path | None) -&gt; str:
    &#34;&#34;&#34;
    Convert `docstring` from `docformat` to Markdown.
    &#34;&#34;&#34;
    docformat = docformat.lower()

    if any(x in docformat for x in [&#34;google&#34;, &#34;numpy&#34;, &#34;restructuredtext&#34;]):
        docstring = rst(docstring, source_file)

    if &#34;google&#34; in docformat:
        docstring = google(docstring)

    if &#34;numpy&#34; in docformat:
        docstring = numpy(docstring)

    if source_file is not None and os.environ.get(&#34;PDOC_EMBED_IMAGES&#34;) != &#34;0&#34;:
        docstring = embed_images(docstring, source_file)

    return docstring


def embed_images(docstring: str, source_file: Path) -&gt; str:
    def embed_local_image(m: re.Match) -&gt; str:
        image_path = source_file.parent / m[&#34;href&#34;]
        try:
            image_data = image_path.read_bytes()
            image_mime = mimetypes.guess_type(image_path)[0]
        except Exception:
            return m[0]
        else:
            data = base64.b64encode(image_data).decode()
            return f&#34;![{m[&#39;alt&#39;]}](data:{image_mime};base64,{data})&#34;

    return re.sub(
        r&#34;!\[\s*(?P&lt;alt&gt;.*?)\s*]\(\s*(?P&lt;href&gt;.+?)\s*\)&#34;,
        embed_local_image,
        docstring,
    )
    # TODO: Could probably do more here, e.g. support rST or raw HTML replacements.


def google(docstring: str) -&gt; str:
    &#34;&#34;&#34;Convert Google-style docstring sections into Markdown.&#34;&#34;&#34;
    return re.sub(
        r&#34;&#34;&#34;
        ^(?P&lt;name&gt;[A-Z][A-Z a-z]+):\n
        (?P&lt;contents&gt;(
            \n        # empty lines
            |         # or
            [ \t]+.+  # lines with indentation
        )+)$
        &#34;&#34;&#34;,
        _google_section,
        docstring,
        flags=re.VERBOSE | re.MULTILINE,
    )


GOOGLE_LIST_SECTIONS = [&#34;Args&#34;, &#34;Raises&#34;, &#34;Attributes&#34;]
&#34;&#34;&#34;Section headers listed in the official Google docstring style guide.&#34;&#34;&#34;

GOOGLE_LIST_SECTION_ALIASES = {
    &#34;Parameters&#34;: &#34;Args&#34;,
    &#34;Params&#34;: &#34;Args&#34;,
    &#34;Arguments&#34;: &#34;Args&#34;,
}
&#34;&#34;&#34;
Alternative section headers that are not listed in the official Google
docstring style guide but that we recognize as sections containing lists
nevertheless.
&#34;&#34;&#34;


def _google_section(m: re.Match[str]) -&gt; str:
    name = m.group(&#34;name&#34;)
    contents = dedent(m.group(&#34;contents&#34;)).lstrip()

    if name in GOOGLE_LIST_SECTION_ALIASES:
        name = GOOGLE_LIST_SECTION_ALIASES[name]

    if name in GOOGLE_LIST_SECTIONS:
        items = _indented_list(contents)
        contents = &#34;&#34;
        for item in items:
            try:
                # first &#34;:&#34; on the first line
                _, attr, desc = re.split(r&#34;^(.+?:)&#34;, item, maxsplit=1)
            except ValueError:
                contents += &#34; - &#34; + indent(item, &#34;   &#34;)[3:]
            else:
                contents += f&#34; - **{attr}** &#34; + indent(desc, &#34;   &#34;)[3:]
            contents += &#34;\n&#34;
    else:
        contents = indent(contents, &#34;&gt; &#34;, lambda line: True)

    if name == &#34;Args&#34;:
        name = &#34;Arguments&#34;

    return f&#34;\n###### {name}:\n{contents}\n&#34;


def _indented_list(contents: str) -&gt; list[str]:
    &#34;&#34;&#34;
    Convert a list string into individual (dedented) elements. For example,

    foo:
        desc
    bar: int
        more desc
    baz:
        desc
            indented

    returns [
        &#34;foo:\ndesc&#34;,
        &#34;bar: int\nmore desc&#34;,
        &#34;baz:\ndesc\n    indented&#34;,
    ]
    &#34;&#34;&#34;
    # we expect this to be through cleandoc() already.
    assert not contents.startswith(&#34; &#34;), contents
    assert not contents.startswith(&#34;\n&#34;), contents

    ret: list[str] = []
    for line in contents.splitlines(keepends=True):
        empty = not line.strip()
        indented = line.startswith(&#34; &#34;)
        if not (empty or indented):
            # new section
            ret.append(line)
        else:
            # append to current section
            ret[-1] += line

    return [inspect.cleandoc(x) for x in ret]


def numpy(docstring: str) -&gt; str:
    &#34;&#34;&#34;Convert NumPy-style docstring sections into Markdown.

    See &lt;https://numpydoc.readthedocs.io/en/latest/format.html&gt; for details.
    &#34;&#34;&#34;
    sections = re.split(
        r&#34;&#34;&#34;
        ^([A-Z][A-Za-z ]+)\n  # a heading
        ---+\n+              # followed by a dashed line
        &#34;&#34;&#34;,
        docstring,
        flags=re.VERBOSE | re.MULTILINE,
    )
    contents = sections[0]
    for heading, content in zip(sections[1::2], sections[2::2]):
        if content.startswith(&#34; &#34;):
            # If the first line of section content is indented, we consider the section to be finished
            # on the first non-indented line. We take out the rest - the tail - here.
            content, tail = re.split(r&#34;\n(?![ \n])&#34;, content, maxsplit=1)
        else:
            tail = &#34;&#34;

        if heading in (
            &#34;Parameters&#34;,
            &#34;Returns&#34;,
            &#34;Yields&#34;,
            &#34;Receives&#34;,
            &#34;Other Parameters&#34;,
            &#34;Raises&#34;,
            &#34;Warns&#34;,
            &#34;Attributes&#34;,
        ):
            contents += f&#34;###### {heading}\n{_numpy_parameters(content)}&#34;
        elif heading == &#34;See Also&#34;:
            contents += f&#34;###### {heading}\n{_numpy_seealso(content)}&#34;
        else:
            contents += f&#34;###### {heading}\n{dedent(content)}&#34;
        contents += tail
    return contents


def _numpy_seealso(content: str) -&gt; str:
    &#34;&#34;&#34;Convert a NumPy-style &#34;See Also&#34; section into Markdown&#34;&#34;&#34;
    contents = &#34;&#34;
    for item in _indented_list(content):
        if &#34;:&#34; in item:
            funcstr, desc = item.split(&#34;:&#34;, maxsplit=1)
            desc = f&#34;: {desc}&#34;
        else:
            funcstr, desc = item, &#34;&#34;

        funclist = [f.strip() for f in funcstr.split(&#34; &#34;)]
        funcs = &#34;, &#34;.join(f&#34;`{f}`&#34; for f in funclist if f)
        contents += f&#34;{funcs}{desc}  \n&#34;
    return contents


def _numpy_parameters(content: str) -&gt; str:
    &#34;&#34;&#34;Convert a NumPy-style parameter section into Markdown&#34;&#34;&#34;
    contents = &#34;&#34;
    for item in _indented_list(content):
        m = re.match(r&#34;^(.+):(.+)([\s\S]*)&#34;, item)
        if m:
            contents += (
                f&#34; - **{m.group(1).strip()}** ({m.group(2).strip()}):\n&#34;
                f&#34;{indent(m.group(3).strip(), &#39;   &#39;)}\n&#34;
            )
        else:
            if &#34;\n&#34; in item:
                name, desc = item.split(&#34;\n&#34;, maxsplit=1)
                name = name.strip()
                desc = desc.strip()
            else:
                name, desc = item.strip(), &#34;&#34;

            if desc:
                contents += f&#34; - **{name}**: {desc}\n&#34;
            else:
                contents += f&#34; - **{name}**\n&#34;
    return f&#34;{contents}\n&#34;


def rst(contents: str, source_file: Path | None) -&gt; str:
    &#34;&#34;&#34;
    Convert reStructuredText elements to Markdown.
    We support the most common elements, but we do not aim to mirror the full complexity of the spec here.
    &#34;&#34;&#34;
    contents = _rst_admonitions(contents, source_file)
    contents = _rst_links(contents)

    def replace_reference(m):
        _, kind, name = m.groups()
        if kind in (&#34;meth&#34;, &#34;func&#34;):
            return f&#34;`{name}()`&#34;
        else:
            return f&#34;`{name}`&#34;

    # Code References: :obj:`foo` -&gt; `foo`
    contents = re.sub(
        r&#34;(:py)?:(mod|func|data|const|class|meth|attr|exc|obj):`([^`]+)`&#34;,
        replace_reference,
        contents,
    )

    # Math: :math:`foo` -&gt; \\( foo \\)
    # We don&#39;t use $ as that&#39;s not enabled by MathJax by default.
    contents = re.sub(r&#34;:math:`(.+?)`&#34;, r&#34;\\\\( \1 \\\\)&#34;, contents)

    contents = _rst_footnotes(contents)

    contents = _rst_fields(contents)

    return contents


def _rst_footnotes(contents: str) -&gt; str:
    &#34;&#34;&#34;Convert reStructuredText footnotes&#34;&#34;&#34;
    footnotes: set[str] = set()
    autonum: int

    def register_footnote(m: re.Match[str]) -&gt; str:
        nonlocal autonum
        fn_id = m.group(&#34;id&#34;)
        if fn_id in &#34;*#&#34;:
            fn_id = f&#34;fn-{autonum}&#34;
            autonum += 1
        fn_id = fn_id.lstrip(&#34;#*&#34;)
        footnotes.add(fn_id)
        content = indent(m.group(&#34;content&#34;), &#34;   &#34;).lstrip()
        return f&#34;{m.group(&#39;indent&#39;)}[^{fn_id}]: {content}&#34;

    # Register footnotes
    autonum = 1
    contents = re.sub(
        r&#34;&#34;&#34;
            ^(?P&lt;indent&gt;[ ]*)\.\.[ ]+\[(?P&lt;id&gt;\d+|[#*]\w*)](?P&lt;content&gt;.*
            (
                \n                 # empty lines
                |                  # or
                (?P=indent)[ ]+.+  # lines with indentation
            )*)$
            &#34;&#34;&#34;,
        register_footnote,
        contents,
        flags=re.MULTILINE | re.VERBOSE,
    )

    def replace_references(m: re.Match[str]) -&gt; str:
        nonlocal autonum
        fn_id = m.group(&#34;id&#34;)
        if fn_id in &#34;*#&#34;:
            fn_id = f&#34;fn-{autonum}&#34;
            autonum += 1
        fn_id = fn_id.lstrip(&#34;#*&#34;)
        if fn_id in footnotes:
            return f&#34;[^{fn_id}]&#34;
        else:
            return m.group(0)

    autonum = 1
    contents = re.sub(r&#34;\[(?P&lt;id&gt;\d+|[#*]\w*)]_&#34;, replace_references, contents)
    return contents


def _rst_links(contents: str) -&gt; str:
    &#34;&#34;&#34;Convert reStructuredText hyperlinks&#34;&#34;&#34;
    links = {}

    def register_link(m: re.Match[str]) -&gt; str:
        refid = re.sub(r&#34;\s&#34;, &#34;&#34;, m.group(&#34;id&#34;).lower())
        links[refid] = m.group(&#34;url&#34;)
        return &#34;&#34;

    def replace_link(m: re.Match[str]) -&gt; str:
        text = m.group(&#34;id&#34;)
        refid = re.sub(r&#34;[\s`]&#34;, &#34;&#34;, text.lower())
        try:
            return f&#34;[{text.strip(&#39;`&#39;)}]({links[refid]})&#34;
        except KeyError:
            return m.group(0)

    # Embedded URIs
    contents = re.sub(
        r&#34;`(?P&lt;text&gt;[^`]+)&lt;(?P&lt;url&gt;.+?)&gt;`_&#34;, r&#34;[\g&lt;text&gt;](\g&lt;url&gt;)&#34;, contents
    )
    # External Hyperlink Targets
    contents = re.sub(
        r&#34;^\s*..\s+_(?P&lt;id&gt;[^\n:]+):\s*(?P&lt;url&gt;http\S+)&#34;,
        register_link,
        contents,
        flags=re.MULTILINE,
    )
    contents = re.sub(r&#34;(?P&lt;id&gt;[A-Za-z0-9_\-.:+]|`[^`]+`)_&#34;, replace_link, contents)
    return contents


def _rst_admonitions(contents: str, source_file: Path | None) -&gt; str:
    &#34;&#34;&#34;
    Convert reStructuredText admonitions - a bit tricky because they may already be indented themselves.
    &lt;https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html&gt;
    &#34;&#34;&#34;

    def _rst_admonition(m: re.Match[str]) -&gt; str:
        ind = m.group(&#34;indent&#34;)
        type = m.group(&#34;type&#34;)
        val = m.group(&#34;val&#34;).strip()
        contents = dedent(m.group(&#34;contents&#34;)).strip()

        if type == &#34;include&#34;:
            loc = source_file or Path(&#34;.&#34;)
            try:
                included = (loc.parent / val).read_text(&#34;utf8&#34;, &#34;replace&#34;)
            except OSError as e:
                warnings.warn(f&#34;Cannot include {val!r}: {e}&#34;)
                included = &#34;\n&#34;
            included = _rst_admonitions(included, loc.parent / val)
            return indent(included, ind)
        if type == &#34;math&#34;:
            return f&#34;{ind}$${val}{contents}$$\n&#34;
        if type in (&#34;note&#34;, &#34;warning&#34;, &#34;danger&#34;):
            if val:
                heading = f&#34;{ind}###### {val}\n&#34;
            else:
                heading = &#34;&#34;
            return (
                f&#39;{ind}&lt;div class=&#34;pdoc-alert pdoc-alert-{type}&#34; markdown=&#34;1&#34;&gt;\n&#39;
                f&#34;{heading}&#34;
                f&#34;{indent(contents, ind)}\n&#34;
                f&#34;{ind}&lt;/div&gt;\n&#34;
            )
        if type == &#34;code-block&#34;:
            return f&#34;{ind}```{val}\n{contents}\n```\n&#34;
        if type == &#34;versionadded&#34;:
            text = f&#34;New in version {val}&#34;
        elif type == &#34;versionchanged&#34;:
            text = f&#34;Changed in version {val}&#34;
        elif type == &#34;deprecated&#34;:
            text = f&#34;Deprecated since version {val}&#34;
        else:
            text = f&#34;{type} {val}&#34;.strip()

        if contents:
            text = f&#34;{ind}*{text}:*\n{indent(contents, ind)}\n\n&#34;
        else:
            text = f&#34;{ind}*{text}.*\n&#34;

        return text

    admonition = &#34;note|warning|danger|versionadded|versionchanged|deprecated|seealso|math|include|code-block&#34;
    return re.sub(
        rf&#34;&#34;&#34;
            ^(?P&lt;indent&gt;[ ]*)\.\.[ ]+(?P&lt;type&gt;{admonition})::(?P&lt;val&gt;.*)
            (?P&lt;contents&gt;(
                \n                 # empty lines
                |                  # or
                (?P=indent)[ ]+.+  # lines with indentation
            )*)$
        &#34;&#34;&#34;,
        _rst_admonition,
        contents,
        flags=re.MULTILINE | re.VERBOSE,
    )


def _rst_fields(contents: str) -&gt; str:
    &#34;&#34;&#34;
    Convert reStructuredText fields to Markdown.
    &lt;https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html#rst-field-lists&gt;
    &#34;&#34;&#34;

    _has_parameter_section = False
    _has_raises_section = False

    def _rst_field(m: re.Match[str]) -&gt; str:
        type = m[&#34;type&#34;]
        body = m[&#34;body&#34;]

        if m[&#34;name&#34;]:
            name = f&#34;**{m[&#39;name&#39;].strip()}**: &#34;
        else:
            name = &#34;&#34;

        if type == &#34;param&#34;:
            nonlocal _has_parameter_section
            text = f&#34; - {name}{body}&#34;
            if not _has_parameter_section:
                _has_parameter_section = True
                text = &#34;\n###### Parameters\n&#34; + text
            return text
        elif type == &#34;type&#34;:
            return &#34;&#34;  # we expect users to use modern type annotations.
        elif type == &#34;return&#34;:
            body = indent(body, &#34;&gt; &#34;, lambda line: True)
            return f&#34;\n###### Returns\n{body}&#34;
        elif type == &#34;rtype&#34;:
            return &#34;&#34;  # we expect users to use modern type annotations.
        elif type == &#34;raises&#34;:
            nonlocal _has_raises_section
            text = f&#34; - {name}{body}&#34;
            if not _has_raises_section:
                _has_raises_section = True
                text = &#34;\n###### Raises\n&#34; + text
            return text
        else:  # pragma: no cover
            raise AssertionError(&#34;unreachable&#34;)

    field = &#34;param|type|return|rtype|raises&#34;
    return re.sub(
        rf&#34;&#34;&#34;
            ^:(?P&lt;type&gt;{field})(?:[ ]+(?P&lt;name&gt;.+))?:
            (?P&lt;body&gt;.*(
                (?:\n[ ]*)*  # maybe some empty lines followed by
                [ ]+.+       # lines with indentation
            )*(?:\n|$))
        &#34;&#34;&#34;,
        _rst_field,
        contents,
        flags=re.MULTILINE | re.VERBOSE,
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="pdoc.docstrings.GOOGLE_LIST_SECTIONS"><code class="name">var <span class="ident">GOOGLE_LIST_SECTIONS</span></code></dt>
<dd>
<div class="desc"><p>Section headers listed in the official Google docstring style guide.</p></div>
</dd>
<dt id="pdoc.docstrings.GOOGLE_LIST_SECTION_ALIASES"><code class="name">var <span class="ident">GOOGLE_LIST_SECTION_ALIASES</span></code></dt>
<dd>
<div class="desc"><p>Alternative section headers that are not listed in the official Google
docstring style guide but that we recognize as sections containing lists
nevertheless.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pdoc.docstrings.convert"><code class="name flex">
<span>def <span class="ident">convert</span></span>(<span>docstring: str, docformat: str, source_file: Path | None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert <code>docstring</code> from <code>docformat</code> to Markdown.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cache
def convert(docstring: str, docformat: str, source_file: Path | None) -&gt; str:
    &#34;&#34;&#34;
    Convert `docstring` from `docformat` to Markdown.
    &#34;&#34;&#34;
    docformat = docformat.lower()

    if any(x in docformat for x in [&#34;google&#34;, &#34;numpy&#34;, &#34;restructuredtext&#34;]):
        docstring = rst(docstring, source_file)

    if &#34;google&#34; in docformat:
        docstring = google(docstring)

    if &#34;numpy&#34; in docformat:
        docstring = numpy(docstring)

    if source_file is not None and os.environ.get(&#34;PDOC_EMBED_IMAGES&#34;) != &#34;0&#34;:
        docstring = embed_images(docstring, source_file)

    return docstring</code></pre>
</details>
</dd>
<dt id="pdoc.docstrings.embed_images"><code class="name flex">
<span>def <span class="ident">embed_images</span></span>(<span>docstring: str, source_file: Path) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def embed_images(docstring: str, source_file: Path) -&gt; str:
    def embed_local_image(m: re.Match) -&gt; str:
        image_path = source_file.parent / m[&#34;href&#34;]
        try:
            image_data = image_path.read_bytes()
            image_mime = mimetypes.guess_type(image_path)[0]
        except Exception:
            return m[0]
        else:
            data = base64.b64encode(image_data).decode()
            return f&#34;![{m[&#39;alt&#39;]}](data:{image_mime};base64,{data})&#34;

    return re.sub(
        r&#34;!\[\s*(?P&lt;alt&gt;.*?)\s*]\(\s*(?P&lt;href&gt;.+?)\s*\)&#34;,
        embed_local_image,
        docstring,
    )
    # TODO: Could probably do more here, e.g. support rST or raw HTML replacements.</code></pre>
</details>
</dd>
<dt id="pdoc.docstrings.google"><code class="name flex">
<span>def <span class="ident">google</span></span>(<span>docstring: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert Google-style docstring sections into Markdown.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def google(docstring: str) -&gt; str:
    &#34;&#34;&#34;Convert Google-style docstring sections into Markdown.&#34;&#34;&#34;
    return re.sub(
        r&#34;&#34;&#34;
        ^(?P&lt;name&gt;[A-Z][A-Z a-z]+):\n
        (?P&lt;contents&gt;(
            \n        # empty lines
            |         # or
            [ \t]+.+  # lines with indentation
        )+)$
        &#34;&#34;&#34;,
        _google_section,
        docstring,
        flags=re.VERBOSE | re.MULTILINE,
    )</code></pre>
</details>
</dd>
<dt id="pdoc.docstrings.numpy"><code class="name flex">
<span>def <span class="ident">numpy</span></span>(<span>docstring: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert NumPy-style docstring sections into Markdown.</p>
<p>See <a href="https://numpydoc.readthedocs.io/en/latest/format.html">https://numpydoc.readthedocs.io/en/latest/format.html</a> for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numpy(docstring: str) -&gt; str:
    &#34;&#34;&#34;Convert NumPy-style docstring sections into Markdown.

    See &lt;https://numpydoc.readthedocs.io/en/latest/format.html&gt; for details.
    &#34;&#34;&#34;
    sections = re.split(
        r&#34;&#34;&#34;
        ^([A-Z][A-Za-z ]+)\n  # a heading
        ---+\n+              # followed by a dashed line
        &#34;&#34;&#34;,
        docstring,
        flags=re.VERBOSE | re.MULTILINE,
    )
    contents = sections[0]
    for heading, content in zip(sections[1::2], sections[2::2]):
        if content.startswith(&#34; &#34;):
            # If the first line of section content is indented, we consider the section to be finished
            # on the first non-indented line. We take out the rest - the tail - here.
            content, tail = re.split(r&#34;\n(?![ \n])&#34;, content, maxsplit=1)
        else:
            tail = &#34;&#34;

        if heading in (
            &#34;Parameters&#34;,
            &#34;Returns&#34;,
            &#34;Yields&#34;,
            &#34;Receives&#34;,
            &#34;Other Parameters&#34;,
            &#34;Raises&#34;,
            &#34;Warns&#34;,
            &#34;Attributes&#34;,
        ):
            contents += f&#34;###### {heading}\n{_numpy_parameters(content)}&#34;
        elif heading == &#34;See Also&#34;:
            contents += f&#34;###### {heading}\n{_numpy_seealso(content)}&#34;
        else:
            contents += f&#34;###### {heading}\n{dedent(content)}&#34;
        contents += tail
    return contents</code></pre>
</details>
</dd>
<dt id="pdoc.docstrings.rst"><code class="name flex">
<span>def <span class="ident">rst</span></span>(<span>contents: str, source_file: Path | None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert reStructuredText elements to Markdown.
We support the most common elements, but we do not aim to mirror the full complexity of the spec here.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rst(contents: str, source_file: Path | None) -&gt; str:
    &#34;&#34;&#34;
    Convert reStructuredText elements to Markdown.
    We support the most common elements, but we do not aim to mirror the full complexity of the spec here.
    &#34;&#34;&#34;
    contents = _rst_admonitions(contents, source_file)
    contents = _rst_links(contents)

    def replace_reference(m):
        _, kind, name = m.groups()
        if kind in (&#34;meth&#34;, &#34;func&#34;):
            return f&#34;`{name}()`&#34;
        else:
            return f&#34;`{name}`&#34;

    # Code References: :obj:`foo` -&gt; `foo`
    contents = re.sub(
        r&#34;(:py)?:(mod|func|data|const|class|meth|attr|exc|obj):`([^`]+)`&#34;,
        replace_reference,
        contents,
    )

    # Math: :math:`foo` -&gt; \\( foo \\)
    # We don&#39;t use $ as that&#39;s not enabled by MathJax by default.
    contents = re.sub(r&#34;:math:`(.+?)`&#34;, r&#34;\\\\( \1 \\\\)&#34;, contents)

    contents = _rst_footnotes(contents)

    contents = _rst_fields(contents)

    return contents</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pdoc" href="index.html">pdoc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="pdoc.docstrings.GOOGLE_LIST_SECTIONS" href="#pdoc.docstrings.GOOGLE_LIST_SECTIONS">GOOGLE_LIST_SECTIONS</a></code></li>
<li><code><a title="pdoc.docstrings.GOOGLE_LIST_SECTION_ALIASES" href="#pdoc.docstrings.GOOGLE_LIST_SECTION_ALIASES">GOOGLE_LIST_SECTION_ALIASES</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pdoc.docstrings.convert" href="#pdoc.docstrings.convert">convert</a></code></li>
<li><code><a title="pdoc.docstrings.embed_images" href="#pdoc.docstrings.embed_images">embed_images</a></code></li>
<li><code><a title="pdoc.docstrings.google" href="#pdoc.docstrings.google">google</a></code></li>
<li><code><a title="pdoc.docstrings.numpy" href="#pdoc.docstrings.numpy">numpy</a></code></li>
<li><code><a title="pdoc.docstrings.rst" href="#pdoc.docstrings.rst">rst</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>