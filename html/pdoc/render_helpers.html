<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pdoc.render_helpers API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pdoc.render_helpers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

from collections.abc import Collection
from collections.abc import Iterable
from collections.abc import Mapping
from contextlib import contextmanager
import html
import inspect
import os
import re
from unittest.mock import patch
import warnings

from jinja2 import ext
from jinja2 import nodes
import pygments.formatters
import pygments.lexers

try:
    # Jinja2 &gt;= 3.0
    from jinja2 import pass_context  # type: ignore
except ImportError:  # pragma: no cover
    from jinja2 import contextfilter as pass_context  # type: ignore

from jinja2.runtime import Context
from markupsafe import Markup

import pdoc.markdown2

from . import docstrings
from ._compat import cache
from ._compat import removesuffix

lexer = pygments.lexers.PythonLexer()
&#34;&#34;&#34;
The pygments lexer used for pdoc.render_helpers.highlight.
Overwrite this to configure pygments lexing.
&#34;&#34;&#34;

formatter = pygments.formatters.HtmlFormatter(
    cssclass=&#34;pdoc-code codehilite&#34;,
    linenos=&#34;inline&#34;,
    anchorlinenos=True,
)
&#34;&#34;&#34;
The pygments formatter used for pdoc.render_helpers.highlight.
Overwrite this to configure pygments highlighting of code blocks.

The usage of the `.codehilite` CSS selector in custom templates is deprecated since pdoc 10, use `.pdoc-code` instead.
&#34;&#34;&#34;

signature_formatter = pygments.formatters.HtmlFormatter(nowrap=True)
&#34;&#34;&#34;
The pygments formatter used for pdoc.render_helpers.format_signature.
Overwrite this to configure pygments highlighting of signatures.
&#34;&#34;&#34;

# Keep in sync with the documentation in pdoc/__init__.py!
markdown_extensions = {
    &#34;code-friendly&#34;: None,
    &#34;cuddled-lists&#34;: None,
    &#34;fenced-code-blocks&#34;: {&#34;cssclass&#34;: formatter.cssclass},
    &#34;footnotes&#34;: None,
    &#34;header-ids&#34;: None,
    &#34;link-patterns&#34;: None,
    &#34;markdown-in-html&#34;: None,
    &#34;mermaid&#34;: None,
    &#34;pyshell&#34;: None,
    &#34;strike&#34;: None,
    &#34;tables&#34;: None,
    &#34;task_list&#34;: None,
    &#34;toc&#34;: {&#34;depth&#34;: 2},
}
&#34;&#34;&#34;
The default extensions loaded for `markdown2`.
Overwrite this to configure Markdown rendering.
&#34;&#34;&#34;
markdown_link_patterns = [
    (
        re.compile(
            r&#34;&#34;&#34;
            \b
            (
                (?:https?://|(?&lt;!//)www\.)    # prefix - https:// or www.
                \w[\w_\-]*(?:\.\w[\w_\-]*)*   # host
                [^&lt;&gt;\s&#34;&#39;]*                    # rest of url
                (?&lt;![?!.,:*_~);])             # exclude trailing punctuation
                (?=[?!.,:*_~);]?(?:[&lt;\s]|$))  # make sure that we&#39;re not followed by &#34; or &#39;, i.e. we&#39;re outside of href=&#34;...&#34;.
            )
        &#34;&#34;&#34;,
            re.X,
        ),
        r&#34;\1&#34;,
    )
]
&#34;&#34;&#34;
Link pattern used for markdown2&#39;s [`link-patterns` extra](https://github.com/trentm/python-markdown2/wiki/link-patterns).
&#34;&#34;&#34;


@cache
def highlight(doc: pdoc.doc.Doc) -&gt; str:
    &#34;&#34;&#34;Highlight the source code of a documentation object using pygments.&#34;&#34;&#34;
    if isinstance(doc, str):  # pragma: no cover
        warnings.warn(
            &#34;Passing a string to the `highlight` render helper is deprecated, pass a pdoc.doc.Doc object instead.&#34;,
            DeprecationWarning,
        )
        return Markup(pygments.highlight(doc, lexer, formatter))

    # set up correct line numbers and anchors
    formatter.linespans = doc.qualname or &#34;L&#34;
    formatter.linenostart = doc.source_lines[0] + 1 if doc.source_lines else 1
    return Markup(pygments.highlight(doc.source, lexer, formatter))


def format_signature(sig: inspect.Signature, colon: bool) -&gt; str:
    &#34;&#34;&#34;Format and highlight a function signature using pygments. Returns HTML.&#34;&#34;&#34;
    # First get a list with all params as strings.
    result = pdoc.doc._PrettySignature._params(sig)  # type: ignore
    return_annot = pdoc.doc._PrettySignature._return_annotation_str(sig)  # type: ignore

    multiline = (
        sum(len(x) + 2 for x in result) + len(return_annot)
        &gt; pdoc.doc._PrettySignature.MULTILINE_CUTOFF
    )

    def _try_highlight(code: str) -&gt; str:
        &#34;&#34;&#34;Try to highlight a piece of code using pygments, but return the input as-is if pygments detects errors.&#34;&#34;&#34;
        pretty = pygments.highlight(code, lexer, signature_formatter).strip()
        if &#39;&lt;span class=&#34;err&#34;&gt;&#39; not in pretty:
            return pretty
        else:
            return html.escape(code)

    # Next, individually highlight each parameter using pygments and wrap it in a span.param.
    # This later allows us to properly control line breaks.
    pretty_result = []
    for i, param in enumerate(result):
        pretty = _try_highlight(param)
        if multiline:
            pretty = f&#34;&#34;&#34;&lt;span class=&#34;param&#34;&gt;\t{pretty},&lt;/span&gt;&#34;&#34;&#34;
        else:
            pretty = f&#34;&#34;&#34;&lt;span class=&#34;param&#34;&gt;{pretty}, &lt;/span&gt;&#34;&#34;&#34;
        pretty_result.append(pretty)

    # remove last comma.
    if pretty_result:
        pretty_result[-1] = pretty_result[-1].rpartition(&#34;,&#34;)[0] + &#34;&lt;/span&gt;&#34;

    # Add return annotation.
    anno = &#34;)&#34;
    if return_annot:
        anno += f&#34; -&gt; {_try_highlight(return_annot)}&#34;
    if colon:
        anno += &#34;:&#34;
    if return_annot or colon:
        anno = f&#39;&lt;span class=&#34;return-annotation&#34;&gt;{anno}&lt;/span&gt;&#39;

    rendered = &#34;(&#34; + &#34;&#34;.join(pretty_result) + anno

    if multiline:
        rendered = f&#39;&lt;span class=&#34;signature pdoc-code multiline&#34;&gt;{rendered}&lt;/span&gt;&#39;
    else:
        rendered = f&#39;&lt;span class=&#34;signature pdoc-code condensed&#34;&gt;{rendered}&lt;/span&gt;&#39;

    return Markup(rendered)


@cache
def to_html(docstring: str) -&gt; str:
    &#34;&#34;&#34;
    Convert `docstring` from Markdown to HTML.
    &#34;&#34;&#34;
    # careful: markdown2 returns a subclass of str with an extra
    # .toc_html attribute. don&#39;t further process the result,
    # otherwise this attribute will be lost.
    return pdoc.markdown2.markdown(  # type: ignore
        docstring,
        extras=markdown_extensions,
        link_patterns=markdown_link_patterns,
    )


@pass_context
def to_markdown_with_context(context: Context, docstring: str) -&gt; str:
    &#34;&#34;&#34;
    Converts `docstring` from a custom docformat to Markdown (if necessary), and then from Markdown to HTML.
    &#34;&#34;&#34;
    module: pdoc.doc.Module = context[&#34;module&#34;]
    docformat: str = context[&#34;docformat&#34;]
    return to_markdown(docstring, module, docformat)


def to_markdown(docstring: str, module: pdoc.doc.Module, default_docformat: str) -&gt; str:
    docformat = getattr(module.obj, &#34;__docformat__&#34;, default_docformat) or &#34;&#34;
    return docstrings.convert(docstring, docformat, module.source_file)


def possible_sources(
    all_modules: Collection[str], identifier: str
) -&gt; Iterable[tuple[str, str]]:
    &#34;&#34;&#34;
    For a given identifier, return all possible sources where it could originate from.
    For example, assume `examplepkg._internal.Foo` with all_modules=[&#34;examplepkg&#34;].
    This could be a Foo class in _internal.py, or a nested `class _internal: class Foo` in examplepkg.
    We return both candidates as we don&#39;t know if _internal.py exists.
    It may not be in all_modules because it&#39;s been excluded by `__all__`.
    However, if `examplepkg._internal` is in all_modules we know that it can only be that option.
    &#34;&#34;&#34;
    if identifier in all_modules:
        yield identifier, &#34;&#34;
        return

    modulename = identifier
    qualname = None
    while modulename:
        modulename, _, add = modulename.rpartition(&#34;.&#34;)
        qualname = f&#34;{add}.{qualname}&#34; if qualname else add
        yield modulename, qualname
        if modulename in all_modules:
            return
    raise ValueError(f&#34;Invalid identifier: {identifier}&#34;)


def split_identifier(all_modules: Collection[str], fullname: str) -&gt; tuple[str, str]:
    &#34;&#34;&#34;
    Split an identifier into a `(modulename, qualname)` tuple. For example, `pdoc.render_helpers.split_identifier`
    would be split into `(&#34;pdoc.render_helpers&#34;,&#34;split_identifier&#34;)`. This is necessary to generate links to the
    correct module.
    &#34;&#34;&#34;
    warnings.warn(
        &#34;pdoc.render_helpers.split_identifier is deprecated and will be removed in a future release. &#34;
        &#34;Use pdoc.render_helpers.possible_sources instead.&#34;,
        DeprecationWarning,
    )
    *_, last = possible_sources(all_modules, fullname)
    return last


def _relative_link(current: list[str], target: list[str]) -&gt; str:
    if target == current:
        return f&#34;../{target[-1]}.html&#34;
    elif target[: len(current)] == current:
        return &#34;/&#34;.join(target[len(current) :]) + &#34;.html&#34;
    else:
        return &#34;../&#34; + _relative_link(current[:-1], target)


@cache
def relative_link(current_module: str, target_module: str) -&gt; str:
    &#34;&#34;&#34;Compute the relative link to another module&#39;s HTML file.&#34;&#34;&#34;
    if current_module == target_module:
        return &#34;&#34;
    return _relative_link(
        current_module.split(&#34;.&#34;)[:-1],
        target_module.split(&#34;.&#34;),
    )


def qualname_candidates(identifier: str, context_qualname: str) -&gt; list[str]:
    &#34;&#34;&#34;
    Given an identifier in a current namespace, return all possible qualnames in the current module.
    For example, if we are in Foo&#39;s subclass Bar and `baz()` is the identifier,
    return `Foo.Bar.baz()`, `Foo.baz()`, and `baz()`.
    &#34;&#34;&#34;
    end = len(context_qualname)
    ret = []
    while end &gt; 0:
        ret.append(f&#34;{context_qualname[:end]}.{identifier}&#34;)
        end = context_qualname.rfind(&#34;.&#34;, 0, end)
    ret.append(identifier)
    return ret


@pass_context
def linkify(context: Context, code: str, namespace: str = &#34;&#34;) -&gt; str:
    &#34;&#34;&#34;
    Link all identifiers in a block of text. Identifiers referencing unknown modules or modules that
    are not rendered at the moment will be ignored.
    A piece of text is considered to be an identifier if it either contains a `.` or is surrounded by `&lt;code&gt;` tags.
    &#34;&#34;&#34;

    def linkify_repl(m: re.Match):
        text = m.group(0)
        plain_text = text.replace(
            &#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;&#39;, &#34;.&#34;
        )
        identifier = removesuffix(plain_text, &#34;()&#34;)
        mod: pdoc.doc.Module = context[&#34;module&#34;]

        # Check if this is a relative reference?
        if identifier.startswith(&#34;.&#34;):
            taken_from_mod = mod
            if namespace and (ns := mod.get(namespace)):
                # Imported from somewhere else, so the relative reference should be from the original module.
                taken_from_mod = context[&#34;all_modules&#34;].get(ns.taken_from[0], mod)
            if taken_from_mod.is_package:
                # If we are in __init__.py, we want `.foo` to refer to a child module.
                parent_module = taken_from_mod.modulename
            else:
                # If we are in a leaf module, we want `.foo` to refer to the adjacent module.
                parent_module = taken_from_mod.modulename.rpartition(&#34;.&#34;)[0]
            while identifier.startswith(&#34;..&#34;):
                identifier = identifier[1:]
                parent_module = parent_module.rpartition(&#34;.&#34;)[0]
            identifier = parent_module + identifier
        else:
            # Check if this is a local reference within this module?
            for qualname in qualname_candidates(identifier, namespace):
                doc = mod.get(qualname)
                if doc and context[&#34;is_public&#34;](doc).strip():
                    return f&#39;&lt;a href=&#34;#{qualname}&#34;&gt;{plain_text}&lt;/a&gt;&#39;

        module = &#34;&#34;
        qualname = &#34;&#34;
        try:
            # Check if the object we are interested in is imported and re-exposed in the current namespace.
            for module, qualname in possible_sources(
                context[&#34;all_modules&#34;], identifier
            ):
                doc = mod.get(qualname)
                if (
                    doc
                    and doc.taken_from == (module, qualname)
                    and context[&#34;is_public&#34;](doc).strip()
                ):
                    if plain_text.endswith(&#34;()&#34;):
                        plain_text = f&#34;{doc.qualname}()&#34;
                    else:
                        plain_text = doc.qualname
                    return f&#39;&lt;a href=&#34;#{qualname}&#34;&gt;{plain_text}&lt;/a&gt;&#39;
        except ValueError:
            # possible_sources did not find a parent module.
            return text
        else:
            # It&#39;s not, but we now know the parent module. Does the target exist?
            doc = context[&#34;all_modules&#34;][module]
            if qualname:
                assert isinstance(doc, pdoc.doc.Module)
                doc = doc.get(qualname)
            target_exists_and_public = (
                doc is not None and context[&#34;is_public&#34;](doc).strip()
            )
            if target_exists_and_public:
                assert doc is not None  # mypy
                if qualname:
                    qualname = f&#34;#{qualname}&#34;
                if plain_text.endswith(&#34;()&#34;):
                    plain_text = f&#34;{doc.fullname}()&#34;
                else:
                    plain_text = doc.fullname
                return f&#39;&lt;a href=&#34;{relative_link(context[&#34;module&#34;].modulename, module)}{qualname}&#34;&gt;{plain_text}&lt;/a&gt;&#39;
            else:
                return text

    return Markup(
        re.sub(
            r&#34;&#34;&#34;
            # Part 1: foo.bar or foo.bar() (without backticks)
            (?&lt;![/=?#&amp;])  # heuristic: not part of a URL
            # First part of the identifier (e.g. &#34;foo&#34;) - this is optional for relative references.
            (?:
                \b
                (?!\d)[a-zA-Z0-9_]+
                |
                \.*  # We may also start with multiple dots.
            )
            # Rest of the identifier (e.g. &#34;.bar&#34; or &#34;..bar&#34;)
            (?:
                # A single dot or a dot surrounded with pygments highlighting.
                (?:\.|&lt;/span&gt;&lt;span\ class=&#34;o&#34;&gt;\.&lt;/span&gt;&lt;span\ class=&#34;n&#34;&gt;)
                (?!\d)[a-zA-Z0-9_]+
            )+
            (?:\(\)|\b(?!\(\)))  # we either end on () or on a word boundary.
            (?!&lt;/a&gt;)  # not an existing link
            (?![/#])  # heuristic: not part of a URL

            | # Part 2: `foo` or `foo()`. `foo.bar` is already covered with part 1.
            (?&lt;=&lt;code&gt;)
                 (?!\d)[a-zA-Z0-9_]+
            (?:\(\))?
            (?=&lt;/code&gt;(?!&lt;/a&gt;))
            &#34;&#34;&#34;,
            linkify_repl,
            code,
            flags=re.VERBOSE,
        )
    )


@pass_context
def link(context: Context, spec: tuple[str, str], text: str | None = None) -&gt; str:
    &#34;&#34;&#34;Create a link for a specific `(modulename, qualname)` tuple.&#34;&#34;&#34;
    mod: pdoc.doc.Module = context[&#34;module&#34;]
    modulename, qualname = spec

    # Check if the object we are interested is also imported and re-exposed in the current namespace.
    # https://github.com/mitmproxy/pdoc/issues/490: We need to do this for every level, not just the tail.
    doc: pdoc.doc.Doc | None = mod
    for part in qualname.split(&#34;.&#34;):
        doc = doc.get(part) if isinstance(doc, pdoc.doc.Namespace) else None
        if not (
            doc
            and doc.taken_from[0] == modulename
            and context[&#34;is_public&#34;](doc).strip()
        ):
            break
    else:
        # everything down to the tail is imported and re-exposed.
        if text:
            text = text.replace(f&#34;{modulename}.&#34;, f&#34;{mod.modulename}.&#34;)
        modulename = mod.modulename

    if mod.modulename == modulename:
        fullname = qualname
    else:
        fullname = removesuffix(f&#34;{modulename}.{qualname}&#34;, &#34;.&#34;)

    if qualname:
        qualname = f&#34;#{qualname}&#34;
    if modulename in context[&#34;all_modules&#34;]:
        return Markup(
            f&#39;&lt;a href=&#34;{relative_link(context[&#34;module&#34;].modulename, modulename)}{qualname}&#34;&gt;{text or fullname}&lt;/a&gt;&#39;
        )
    return text or fullname


def edit_url(
    modulename: str, is_package: bool, mapping: Mapping[str, str]
) -&gt; str | None:
    &#34;&#34;&#34;Create a link to edit a particular file in the used version control system.&#34;&#34;&#34;
    for m, prefix in mapping.items():
        if m == modulename or modulename.startswith(f&#34;{m}.&#34;):
            filename = modulename[len(m) + 1 :].replace(&#34;.&#34;, &#34;/&#34;)
            if is_package:
                filename = f&#34;{filename}/__init__.py&#34;.lstrip(&#34;/&#34;)
            else:
                filename += &#34;.py&#34;
            return f&#34;{prefix}{filename}&#34;
    return None


def root_module_name(all_modules: Mapping[str, pdoc.doc.Module]) -&gt; str | None:
    &#34;&#34;&#34;
    Return the name of the (unique) top-level module, or `None`
    if no such module exists.

    For example, assuming `foo`, `foo.bar`, and `foo.baz` are documented,
    this function will return `foo`. If `foo` and `bar` are documented,
    this function will return `None` as there is no unique top-level module.
    &#34;&#34;&#34;
    shortest_name = min(all_modules, key=len, default=None)
    prefix = f&#34;{shortest_name}.&#34;
    all_others_are_submodules = all(
        x.startswith(prefix) or x == shortest_name for x in all_modules
    )
    if all_others_are_submodules:
        return shortest_name
    else:
        return None


def minify_css(css: str) -&gt; str:
    &#34;&#34;&#34;Do some very basic CSS minification.&#34;&#34;&#34;
    css = re.sub(r&#34;[ ]{4}|\n|(?&lt;=[:{}]) | (?=[{}])&#34;, &#34;&#34;, css)
    css = re.sub(
        r&#34;/\*.+?\*/&#34;, lambda m: m.group(0) if m.group(0).startswith(&#34;/*!&#34;) else &#34;&#34;, css
    )
    return Markup(css.replace(&#34;&lt;style&#34;, &#34;\n&lt;style&#34;))


@contextmanager
def defuse_unsafe_reprs():
    &#34;&#34;&#34;This decorator is applied by pdoc before calling an object&#39;s repr().
    It applies some heuristics to patch our sensitive information.
    For example, `os.environ`&#39;s default `__repr__` implementation exposes all
    local secrets.
    &#34;&#34;&#34;
    with patch.object(os._Environ, &#34;__repr__&#34;, lambda self: &#34;os.environ&#34;):
        yield


class DefaultMacroExtension(ext.Extension):
    &#34;&#34;&#34;
    This extension provides a new `{% defaultmacro %}` statement, which defines a macro only if it does not exist.

    For example,

    ```html+jinja
    {% defaultmacro example() %}
        test 123
    {% enddefaultmacro %}
    ```

    is equivalent to

    ```html+jinja
    {% macro default_example() %}
    test 123
    {% endmacro %}
    {% if not example %}
        {% macro example() %}
            test 123
        {% endmacro %}
    {% endif %}
    ```

    Additionally, the default implementation is also available as `default_$macroname`, which makes it possible
    to reference it in the override.
    &#34;&#34;&#34;

    tags = {&#34;defaultmacro&#34;}

    def parse(self, parser):
        m = nodes.Macro(lineno=next(parser.stream).lineno)
        name = parser.parse_assign_target(name_only=True).name
        m.name = f&#34;default_{name}&#34;
        parser.parse_signature(m)
        m.body = parser.parse_statements((&#34;name:enddefaultmacro&#34;,), drop_needle=True)

        if_stmt = nodes.If(
            nodes.Not(nodes.Name(name, &#34;load&#34;)),
            [nodes.Macro(name, m.args, m.defaults, m.body)],
            [],
            [],
        )
        return [m, if_stmt]</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="pdoc.render_helpers.formatter"><code class="name">var <span class="ident">formatter</span></code></dt>
<dd>
<div class="desc"><p>The pygments formatter used for pdoc.render_helpers.highlight.
Overwrite this to configure pygments highlighting of code blocks.</p>
<p>The usage of the <code>.codehilite</code> CSS selector in custom templates is deprecated since pdoc 10, use <code>.pdoc-code</code> instead.</p></div>
</dd>
<dt id="pdoc.render_helpers.lexer"><code class="name">var <span class="ident">lexer</span></code></dt>
<dd>
<div class="desc"><p>The pygments lexer used for pdoc.render_helpers.highlight.
Overwrite this to configure pygments lexing.</p></div>
</dd>
<dt id="pdoc.render_helpers.markdown_extensions"><code class="name">var <span class="ident">markdown_extensions</span></code></dt>
<dd>
<div class="desc"><p>The default extensions loaded for <code>markdown2</code>.
Overwrite this to configure Markdown rendering.</p></div>
</dd>
<dt id="pdoc.render_helpers.markdown_link_patterns"><code class="name">var <span class="ident">markdown_link_patterns</span></code></dt>
<dd>
<div class="desc"><p>Link pattern used for markdown2's <a href="https://github.com/trentm/python-markdown2/wiki/link-patterns"><code>link-patterns</code> extra</a>.</p></div>
</dd>
<dt id="pdoc.render_helpers.signature_formatter"><code class="name">var <span class="ident">signature_formatter</span></code></dt>
<dd>
<div class="desc"><p>The pygments formatter used for pdoc.render_helpers.format_signature.
Overwrite this to configure pygments highlighting of signatures.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pdoc.render_helpers.defuse_unsafe_reprs"><code class="name flex">
<span>def <span class="ident">defuse_unsafe_reprs</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>This decorator is applied by pdoc before calling an object's repr().
It applies some heuristics to patch our sensitive information.
For example, <code>os.environ</code>'s default <code>__repr__</code> implementation exposes all
local secrets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def defuse_unsafe_reprs():
    &#34;&#34;&#34;This decorator is applied by pdoc before calling an object&#39;s repr().
    It applies some heuristics to patch our sensitive information.
    For example, `os.environ`&#39;s default `__repr__` implementation exposes all
    local secrets.
    &#34;&#34;&#34;
    with patch.object(os._Environ, &#34;__repr__&#34;, lambda self: &#34;os.environ&#34;):
        yield</code></pre>
</details>
</dd>
<dt id="pdoc.render_helpers.edit_url"><code class="name flex">
<span>def <span class="ident">edit_url</span></span>(<span>modulename: str, is_package: bool, mapping: Mapping[str, str]) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Create a link to edit a particular file in the used version control system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edit_url(
    modulename: str, is_package: bool, mapping: Mapping[str, str]
) -&gt; str | None:
    &#34;&#34;&#34;Create a link to edit a particular file in the used version control system.&#34;&#34;&#34;
    for m, prefix in mapping.items():
        if m == modulename or modulename.startswith(f&#34;{m}.&#34;):
            filename = modulename[len(m) + 1 :].replace(&#34;.&#34;, &#34;/&#34;)
            if is_package:
                filename = f&#34;{filename}/__init__.py&#34;.lstrip(&#34;/&#34;)
            else:
                filename += &#34;.py&#34;
            return f&#34;{prefix}{filename}&#34;
    return None</code></pre>
</details>
</dd>
<dt id="pdoc.render_helpers.format_signature"><code class="name flex">
<span>def <span class="ident">format_signature</span></span>(<span>sig: inspect.Signature, colon: bool) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Format and highlight a function signature using pygments. Returns HTML.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_signature(sig: inspect.Signature, colon: bool) -&gt; str:
    &#34;&#34;&#34;Format and highlight a function signature using pygments. Returns HTML.&#34;&#34;&#34;
    # First get a list with all params as strings.
    result = pdoc.doc._PrettySignature._params(sig)  # type: ignore
    return_annot = pdoc.doc._PrettySignature._return_annotation_str(sig)  # type: ignore

    multiline = (
        sum(len(x) + 2 for x in result) + len(return_annot)
        &gt; pdoc.doc._PrettySignature.MULTILINE_CUTOFF
    )

    def _try_highlight(code: str) -&gt; str:
        &#34;&#34;&#34;Try to highlight a piece of code using pygments, but return the input as-is if pygments detects errors.&#34;&#34;&#34;
        pretty = pygments.highlight(code, lexer, signature_formatter).strip()
        if &#39;&lt;span class=&#34;err&#34;&gt;&#39; not in pretty:
            return pretty
        else:
            return html.escape(code)

    # Next, individually highlight each parameter using pygments and wrap it in a span.param.
    # This later allows us to properly control line breaks.
    pretty_result = []
    for i, param in enumerate(result):
        pretty = _try_highlight(param)
        if multiline:
            pretty = f&#34;&#34;&#34;&lt;span class=&#34;param&#34;&gt;\t{pretty},&lt;/span&gt;&#34;&#34;&#34;
        else:
            pretty = f&#34;&#34;&#34;&lt;span class=&#34;param&#34;&gt;{pretty}, &lt;/span&gt;&#34;&#34;&#34;
        pretty_result.append(pretty)

    # remove last comma.
    if pretty_result:
        pretty_result[-1] = pretty_result[-1].rpartition(&#34;,&#34;)[0] + &#34;&lt;/span&gt;&#34;

    # Add return annotation.
    anno = &#34;)&#34;
    if return_annot:
        anno += f&#34; -&gt; {_try_highlight(return_annot)}&#34;
    if colon:
        anno += &#34;:&#34;
    if return_annot or colon:
        anno = f&#39;&lt;span class=&#34;return-annotation&#34;&gt;{anno}&lt;/span&gt;&#39;

    rendered = &#34;(&#34; + &#34;&#34;.join(pretty_result) + anno

    if multiline:
        rendered = f&#39;&lt;span class=&#34;signature pdoc-code multiline&#34;&gt;{rendered}&lt;/span&gt;&#39;
    else:
        rendered = f&#39;&lt;span class=&#34;signature pdoc-code condensed&#34;&gt;{rendered}&lt;/span&gt;&#39;

    return Markup(rendered)</code></pre>
</details>
</dd>
<dt id="pdoc.render_helpers.highlight"><code class="name flex">
<span>def <span class="ident">highlight</span></span>(<span>doc: <a title="pdoc.doc.Doc" href="doc.html#pdoc.doc.Doc">Doc</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Highlight the source code of a documentation object using pygments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cache
def highlight(doc: pdoc.doc.Doc) -&gt; str:
    &#34;&#34;&#34;Highlight the source code of a documentation object using pygments.&#34;&#34;&#34;
    if isinstance(doc, str):  # pragma: no cover
        warnings.warn(
            &#34;Passing a string to the `highlight` render helper is deprecated, pass a pdoc.doc.Doc object instead.&#34;,
            DeprecationWarning,
        )
        return Markup(pygments.highlight(doc, lexer, formatter))

    # set up correct line numbers and anchors
    formatter.linespans = doc.qualname or &#34;L&#34;
    formatter.linenostart = doc.source_lines[0] + 1 if doc.source_lines else 1
    return Markup(pygments.highlight(doc.source, lexer, formatter))</code></pre>
</details>
</dd>
<dt id="pdoc.render_helpers.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>context: Context, spec: tuple[str, str], text: str | None = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Create a link for a specific <code>(modulename, qualname)</code> tuple.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pass_context
def link(context: Context, spec: tuple[str, str], text: str | None = None) -&gt; str:
    &#34;&#34;&#34;Create a link for a specific `(modulename, qualname)` tuple.&#34;&#34;&#34;
    mod: pdoc.doc.Module = context[&#34;module&#34;]
    modulename, qualname = spec

    # Check if the object we are interested is also imported and re-exposed in the current namespace.
    # https://github.com/mitmproxy/pdoc/issues/490: We need to do this for every level, not just the tail.
    doc: pdoc.doc.Doc | None = mod
    for part in qualname.split(&#34;.&#34;):
        doc = doc.get(part) if isinstance(doc, pdoc.doc.Namespace) else None
        if not (
            doc
            and doc.taken_from[0] == modulename
            and context[&#34;is_public&#34;](doc).strip()
        ):
            break
    else:
        # everything down to the tail is imported and re-exposed.
        if text:
            text = text.replace(f&#34;{modulename}.&#34;, f&#34;{mod.modulename}.&#34;)
        modulename = mod.modulename

    if mod.modulename == modulename:
        fullname = qualname
    else:
        fullname = removesuffix(f&#34;{modulename}.{qualname}&#34;, &#34;.&#34;)

    if qualname:
        qualname = f&#34;#{qualname}&#34;
    if modulename in context[&#34;all_modules&#34;]:
        return Markup(
            f&#39;&lt;a href=&#34;{relative_link(context[&#34;module&#34;].modulename, modulename)}{qualname}&#34;&gt;{text or fullname}&lt;/a&gt;&#39;
        )
    return text or fullname</code></pre>
</details>
</dd>
<dt id="pdoc.render_helpers.linkify"><code class="name flex">
<span>def <span class="ident">linkify</span></span>(<span>context: Context, code: str, namespace: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Link all identifiers in a block of text. Identifiers referencing unknown modules or modules that
are not rendered at the moment will be ignored.
A piece of text is considered to be an identifier if it either contains a <code>.</code> or is surrounded by <code>&lt;code&gt;</code> tags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pass_context
def linkify(context: Context, code: str, namespace: str = &#34;&#34;) -&gt; str:
    &#34;&#34;&#34;
    Link all identifiers in a block of text. Identifiers referencing unknown modules or modules that
    are not rendered at the moment will be ignored.
    A piece of text is considered to be an identifier if it either contains a `.` or is surrounded by `&lt;code&gt;` tags.
    &#34;&#34;&#34;

    def linkify_repl(m: re.Match):
        text = m.group(0)
        plain_text = text.replace(
            &#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;&#39;, &#34;.&#34;
        )
        identifier = removesuffix(plain_text, &#34;()&#34;)
        mod: pdoc.doc.Module = context[&#34;module&#34;]

        # Check if this is a relative reference?
        if identifier.startswith(&#34;.&#34;):
            taken_from_mod = mod
            if namespace and (ns := mod.get(namespace)):
                # Imported from somewhere else, so the relative reference should be from the original module.
                taken_from_mod = context[&#34;all_modules&#34;].get(ns.taken_from[0], mod)
            if taken_from_mod.is_package:
                # If we are in __init__.py, we want `.foo` to refer to a child module.
                parent_module = taken_from_mod.modulename
            else:
                # If we are in a leaf module, we want `.foo` to refer to the adjacent module.
                parent_module = taken_from_mod.modulename.rpartition(&#34;.&#34;)[0]
            while identifier.startswith(&#34;..&#34;):
                identifier = identifier[1:]
                parent_module = parent_module.rpartition(&#34;.&#34;)[0]
            identifier = parent_module + identifier
        else:
            # Check if this is a local reference within this module?
            for qualname in qualname_candidates(identifier, namespace):
                doc = mod.get(qualname)
                if doc and context[&#34;is_public&#34;](doc).strip():
                    return f&#39;&lt;a href=&#34;#{qualname}&#34;&gt;{plain_text}&lt;/a&gt;&#39;

        module = &#34;&#34;
        qualname = &#34;&#34;
        try:
            # Check if the object we are interested in is imported and re-exposed in the current namespace.
            for module, qualname in possible_sources(
                context[&#34;all_modules&#34;], identifier
            ):
                doc = mod.get(qualname)
                if (
                    doc
                    and doc.taken_from == (module, qualname)
                    and context[&#34;is_public&#34;](doc).strip()
                ):
                    if plain_text.endswith(&#34;()&#34;):
                        plain_text = f&#34;{doc.qualname}()&#34;
                    else:
                        plain_text = doc.qualname
                    return f&#39;&lt;a href=&#34;#{qualname}&#34;&gt;{plain_text}&lt;/a&gt;&#39;
        except ValueError:
            # possible_sources did not find a parent module.
            return text
        else:
            # It&#39;s not, but we now know the parent module. Does the target exist?
            doc = context[&#34;all_modules&#34;][module]
            if qualname:
                assert isinstance(doc, pdoc.doc.Module)
                doc = doc.get(qualname)
            target_exists_and_public = (
                doc is not None and context[&#34;is_public&#34;](doc).strip()
            )
            if target_exists_and_public:
                assert doc is not None  # mypy
                if qualname:
                    qualname = f&#34;#{qualname}&#34;
                if plain_text.endswith(&#34;()&#34;):
                    plain_text = f&#34;{doc.fullname}()&#34;
                else:
                    plain_text = doc.fullname
                return f&#39;&lt;a href=&#34;{relative_link(context[&#34;module&#34;].modulename, module)}{qualname}&#34;&gt;{plain_text}&lt;/a&gt;&#39;
            else:
                return text

    return Markup(
        re.sub(
            r&#34;&#34;&#34;
            # Part 1: foo.bar or foo.bar() (without backticks)
            (?&lt;![/=?#&amp;])  # heuristic: not part of a URL
            # First part of the identifier (e.g. &#34;foo&#34;) - this is optional for relative references.
            (?:
                \b
                (?!\d)[a-zA-Z0-9_]+
                |
                \.*  # We may also start with multiple dots.
            )
            # Rest of the identifier (e.g. &#34;.bar&#34; or &#34;..bar&#34;)
            (?:
                # A single dot or a dot surrounded with pygments highlighting.
                (?:\.|&lt;/span&gt;&lt;span\ class=&#34;o&#34;&gt;\.&lt;/span&gt;&lt;span\ class=&#34;n&#34;&gt;)
                (?!\d)[a-zA-Z0-9_]+
            )+
            (?:\(\)|\b(?!\(\)))  # we either end on () or on a word boundary.
            (?!&lt;/a&gt;)  # not an existing link
            (?![/#])  # heuristic: not part of a URL

            | # Part 2: `foo` or `foo()`. `foo.bar` is already covered with part 1.
            (?&lt;=&lt;code&gt;)
                 (?!\d)[a-zA-Z0-9_]+
            (?:\(\))?
            (?=&lt;/code&gt;(?!&lt;/a&gt;))
            &#34;&#34;&#34;,
            linkify_repl,
            code,
            flags=re.VERBOSE,
        )
    )</code></pre>
</details>
</dd>
<dt id="pdoc.render_helpers.minify_css"><code class="name flex">
<span>def <span class="ident">minify_css</span></span>(<span>css: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Do some very basic CSS minification.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minify_css(css: str) -&gt; str:
    &#34;&#34;&#34;Do some very basic CSS minification.&#34;&#34;&#34;
    css = re.sub(r&#34;[ ]{4}|\n|(?&lt;=[:{}]) | (?=[{}])&#34;, &#34;&#34;, css)
    css = re.sub(
        r&#34;/\*.+?\*/&#34;, lambda m: m.group(0) if m.group(0).startswith(&#34;/*!&#34;) else &#34;&#34;, css
    )
    return Markup(css.replace(&#34;&lt;style&#34;, &#34;\n&lt;style&#34;))</code></pre>
</details>
</dd>
<dt id="pdoc.render_helpers.possible_sources"><code class="name flex">
<span>def <span class="ident">possible_sources</span></span>(<span>all_modules: Collection[str], identifier: str) ‑> collections.abc.Iterable[tuple[str, str]]</span>
</code></dt>
<dd>
<div class="desc"><p>For a given identifier, return all possible sources where it could originate from.
For example, assume <code>examplepkg._internal.Foo</code> with all_modules=["examplepkg"].
This could be a Foo class in _internal.py, or a nested <code>class _internal: class Foo</code> in examplepkg.
We return both candidates as we don't know if _internal.py exists.
It may not be in all_modules because it's been excluded by <code>__all__</code>.
However, if <code>examplepkg._internal</code> is in all_modules we know that it can only be that option.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def possible_sources(
    all_modules: Collection[str], identifier: str
) -&gt; Iterable[tuple[str, str]]:
    &#34;&#34;&#34;
    For a given identifier, return all possible sources where it could originate from.
    For example, assume `examplepkg._internal.Foo` with all_modules=[&#34;examplepkg&#34;].
    This could be a Foo class in _internal.py, or a nested `class _internal: class Foo` in examplepkg.
    We return both candidates as we don&#39;t know if _internal.py exists.
    It may not be in all_modules because it&#39;s been excluded by `__all__`.
    However, if `examplepkg._internal` is in all_modules we know that it can only be that option.
    &#34;&#34;&#34;
    if identifier in all_modules:
        yield identifier, &#34;&#34;
        return

    modulename = identifier
    qualname = None
    while modulename:
        modulename, _, add = modulename.rpartition(&#34;.&#34;)
        qualname = f&#34;{add}.{qualname}&#34; if qualname else add
        yield modulename, qualname
        if modulename in all_modules:
            return
    raise ValueError(f&#34;Invalid identifier: {identifier}&#34;)</code></pre>
</details>
</dd>
<dt id="pdoc.render_helpers.qualname_candidates"><code class="name flex">
<span>def <span class="ident">qualname_candidates</span></span>(<span>identifier: str, context_qualname: str) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Given an identifier in a current namespace, return all possible qualnames in the current module.
For example, if we are in Foo's subclass Bar and <code>baz()</code> is the identifier,
return <code>Foo.Bar.baz()</code>, <code>Foo.baz()</code>, and <code>baz()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def qualname_candidates(identifier: str, context_qualname: str) -&gt; list[str]:
    &#34;&#34;&#34;
    Given an identifier in a current namespace, return all possible qualnames in the current module.
    For example, if we are in Foo&#39;s subclass Bar and `baz()` is the identifier,
    return `Foo.Bar.baz()`, `Foo.baz()`, and `baz()`.
    &#34;&#34;&#34;
    end = len(context_qualname)
    ret = []
    while end &gt; 0:
        ret.append(f&#34;{context_qualname[:end]}.{identifier}&#34;)
        end = context_qualname.rfind(&#34;.&#34;, 0, end)
    ret.append(identifier)
    return ret</code></pre>
</details>
</dd>
<dt id="pdoc.render_helpers.relative_link"><code class="name flex">
<span>def <span class="ident">relative_link</span></span>(<span>current_module: str, target_module: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the relative link to another module's HTML file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cache
def relative_link(current_module: str, target_module: str) -&gt; str:
    &#34;&#34;&#34;Compute the relative link to another module&#39;s HTML file.&#34;&#34;&#34;
    if current_module == target_module:
        return &#34;&#34;
    return _relative_link(
        current_module.split(&#34;.&#34;)[:-1],
        target_module.split(&#34;.&#34;),
    )</code></pre>
</details>
</dd>
<dt id="pdoc.render_helpers.removesuffix"><code class="name flex">
<span>def <span class="ident">removesuffix</span></span>(<span>self, suffix, /)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a str with the given suffix string removed if present.</p>
<p>If the string ends with the suffix string and that suffix is not empty,
return string[:-len(suffix)]. Otherwise, return a copy of the original
string.</p></div>
</dd>
<dt id="pdoc.render_helpers.root_module_name"><code class="name flex">
<span>def <span class="ident">root_module_name</span></span>(<span>all_modules: Mapping[str, <a title="pdoc.doc.Module" href="doc.html#pdoc.doc.Module">Module</a>]) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the name of the (unique) top-level module, or <code>None</code>
if no such module exists.</p>
<p>For example, assuming <code>foo</code>, <code>foo.bar</code>, and <code>foo.baz</code> are documented,
this function will return <code>foo</code>. If <code>foo</code> and <code>bar</code> are documented,
this function will return <code>None</code> as there is no unique top-level module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def root_module_name(all_modules: Mapping[str, pdoc.doc.Module]) -&gt; str | None:
    &#34;&#34;&#34;
    Return the name of the (unique) top-level module, or `None`
    if no such module exists.

    For example, assuming `foo`, `foo.bar`, and `foo.baz` are documented,
    this function will return `foo`. If `foo` and `bar` are documented,
    this function will return `None` as there is no unique top-level module.
    &#34;&#34;&#34;
    shortest_name = min(all_modules, key=len, default=None)
    prefix = f&#34;{shortest_name}.&#34;
    all_others_are_submodules = all(
        x.startswith(prefix) or x == shortest_name for x in all_modules
    )
    if all_others_are_submodules:
        return shortest_name
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pdoc.render_helpers.split_identifier"><code class="name flex">
<span>def <span class="ident">split_identifier</span></span>(<span>all_modules: Collection[str], fullname: str) ‑> tuple[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Split an identifier into a <code>(modulename, qualname)</code> tuple. For example, <code><a title="pdoc.render_helpers.split_identifier" href="#pdoc.render_helpers.split_identifier">split_identifier()</a></code>
would be split into <code>("pdoc.render_helpers","split_identifier")</code>. This is necessary to generate links to the
correct module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_identifier(all_modules: Collection[str], fullname: str) -&gt; tuple[str, str]:
    &#34;&#34;&#34;
    Split an identifier into a `(modulename, qualname)` tuple. For example, `pdoc.render_helpers.split_identifier`
    would be split into `(&#34;pdoc.render_helpers&#34;,&#34;split_identifier&#34;)`. This is necessary to generate links to the
    correct module.
    &#34;&#34;&#34;
    warnings.warn(
        &#34;pdoc.render_helpers.split_identifier is deprecated and will be removed in a future release. &#34;
        &#34;Use pdoc.render_helpers.possible_sources instead.&#34;,
        DeprecationWarning,
    )
    *_, last = possible_sources(all_modules, fullname)
    return last</code></pre>
</details>
</dd>
<dt id="pdoc.render_helpers.to_html"><code class="name flex">
<span>def <span class="ident">to_html</span></span>(<span>docstring: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert <code>docstring</code> from Markdown to HTML.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cache
def to_html(docstring: str) -&gt; str:
    &#34;&#34;&#34;
    Convert `docstring` from Markdown to HTML.
    &#34;&#34;&#34;
    # careful: markdown2 returns a subclass of str with an extra
    # .toc_html attribute. don&#39;t further process the result,
    # otherwise this attribute will be lost.
    return pdoc.markdown2.markdown(  # type: ignore
        docstring,
        extras=markdown_extensions,
        link_patterns=markdown_link_patterns,
    )</code></pre>
</details>
</dd>
<dt id="pdoc.render_helpers.to_markdown"><code class="name flex">
<span>def <span class="ident">to_markdown</span></span>(<span>docstring: str, module: <a title="pdoc.doc.Module" href="doc.html#pdoc.doc.Module">Module</a>, default_docformat: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_markdown(docstring: str, module: pdoc.doc.Module, default_docformat: str) -&gt; str:
    docformat = getattr(module.obj, &#34;__docformat__&#34;, default_docformat) or &#34;&#34;
    return docstrings.convert(docstring, docformat, module.source_file)</code></pre>
</details>
</dd>
<dt id="pdoc.render_helpers.to_markdown_with_context"><code class="name flex">
<span>def <span class="ident">to_markdown_with_context</span></span>(<span>context: Context, docstring: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Converts <code>docstring</code> from a custom docformat to Markdown (if necessary), and then from Markdown to HTML.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pass_context
def to_markdown_with_context(context: Context, docstring: str) -&gt; str:
    &#34;&#34;&#34;
    Converts `docstring` from a custom docformat to Markdown (if necessary), and then from Markdown to HTML.
    &#34;&#34;&#34;
    module: pdoc.doc.Module = context[&#34;module&#34;]
    docformat: str = context[&#34;docformat&#34;]
    return to_markdown(docstring, module, docformat)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pdoc.render_helpers.DefaultMacroExtension"><code class="flex name class">
<span>class <span class="ident">DefaultMacroExtension</span></span>
<span>(</span><span>environment: jinja2.environment.Environment)</span>
</code></dt>
<dd>
<div class="desc"><p>This extension provides a new <code>{% defaultmacro %}</code> statement, which defines a macro only if it does not exist.</p>
<p>For example,</p>
<pre><code class="language-html+jinja">{% defaultmacro example() %}
    test 123
{% enddefaultmacro %}
</code></pre>
<p>is equivalent to</p>
<pre><code class="language-html+jinja">{% macro default_example() %}
test 123
{% endmacro %}
{% if not example %}
    {% macro example() %}
        test 123
    {% endmacro %}
{% endif %}
</code></pre>
<p>Additionally, the default implementation is also available as <code>default_$macroname</code>, which makes it possible
to reference it in the override.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DefaultMacroExtension(ext.Extension):
    &#34;&#34;&#34;
    This extension provides a new `{% defaultmacro %}` statement, which defines a macro only if it does not exist.

    For example,

    ```html+jinja
    {% defaultmacro example() %}
        test 123
    {% enddefaultmacro %}
    ```

    is equivalent to

    ```html+jinja
    {% macro default_example() %}
    test 123
    {% endmacro %}
    {% if not example %}
        {% macro example() %}
            test 123
        {% endmacro %}
    {% endif %}
    ```

    Additionally, the default implementation is also available as `default_$macroname`, which makes it possible
    to reference it in the override.
    &#34;&#34;&#34;

    tags = {&#34;defaultmacro&#34;}

    def parse(self, parser):
        m = nodes.Macro(lineno=next(parser.stream).lineno)
        name = parser.parse_assign_target(name_only=True).name
        m.name = f&#34;default_{name}&#34;
        parser.parse_signature(m)
        m.body = parser.parse_statements((&#34;name:enddefaultmacro&#34;,), drop_needle=True)

        if_stmt = nodes.If(
            nodes.Not(nodes.Name(name, &#34;load&#34;)),
            [nodes.Macro(name, m.args, m.defaults, m.body)],
            [],
            [],
        )
        return [m, if_stmt]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>jinja2.ext.Extension</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pdoc.render_helpers.DefaultMacroExtension.identifier"><code class="name">var <span class="ident">identifier</span> : ClassVar[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pdoc.render_helpers.DefaultMacroExtension.tags"><code class="name">var <span class="ident">tags</span> : Set[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pdoc.render_helpers.DefaultMacroExtension.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, parser)</span>
</code></dt>
<dd>
<div class="desc"><p>If any of the :attr:<code>tags</code> matched this method is called with the
parser as first argument.
The token the parser stream is pointing at
is the name token that matched.
This method has to return one or a
list of multiple nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, parser):
    m = nodes.Macro(lineno=next(parser.stream).lineno)
    name = parser.parse_assign_target(name_only=True).name
    m.name = f&#34;default_{name}&#34;
    parser.parse_signature(m)
    m.body = parser.parse_statements((&#34;name:enddefaultmacro&#34;,), drop_needle=True)

    if_stmt = nodes.If(
        nodes.Not(nodes.Name(name, &#34;load&#34;)),
        [nodes.Macro(name, m.args, m.defaults, m.body)],
        [],
        [],
    )
    return [m, if_stmt]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pdoc" href="index.html">pdoc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="pdoc.render_helpers.formatter" href="#pdoc.render_helpers.formatter">formatter</a></code></li>
<li><code><a title="pdoc.render_helpers.lexer" href="#pdoc.render_helpers.lexer">lexer</a></code></li>
<li><code><a title="pdoc.render_helpers.markdown_extensions" href="#pdoc.render_helpers.markdown_extensions">markdown_extensions</a></code></li>
<li><code><a title="pdoc.render_helpers.markdown_link_patterns" href="#pdoc.render_helpers.markdown_link_patterns">markdown_link_patterns</a></code></li>
<li><code><a title="pdoc.render_helpers.signature_formatter" href="#pdoc.render_helpers.signature_formatter">signature_formatter</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pdoc.render_helpers.defuse_unsafe_reprs" href="#pdoc.render_helpers.defuse_unsafe_reprs">defuse_unsafe_reprs</a></code></li>
<li><code><a title="pdoc.render_helpers.edit_url" href="#pdoc.render_helpers.edit_url">edit_url</a></code></li>
<li><code><a title="pdoc.render_helpers.format_signature" href="#pdoc.render_helpers.format_signature">format_signature</a></code></li>
<li><code><a title="pdoc.render_helpers.highlight" href="#pdoc.render_helpers.highlight">highlight</a></code></li>
<li><code><a title="pdoc.render_helpers.link" href="#pdoc.render_helpers.link">link</a></code></li>
<li><code><a title="pdoc.render_helpers.linkify" href="#pdoc.render_helpers.linkify">linkify</a></code></li>
<li><code><a title="pdoc.render_helpers.minify_css" href="#pdoc.render_helpers.minify_css">minify_css</a></code></li>
<li><code><a title="pdoc.render_helpers.possible_sources" href="#pdoc.render_helpers.possible_sources">possible_sources</a></code></li>
<li><code><a title="pdoc.render_helpers.qualname_candidates" href="#pdoc.render_helpers.qualname_candidates">qualname_candidates</a></code></li>
<li><code><a title="pdoc.render_helpers.relative_link" href="#pdoc.render_helpers.relative_link">relative_link</a></code></li>
<li><code><a title="pdoc.render_helpers.removesuffix" href="#pdoc.render_helpers.removesuffix">removesuffix</a></code></li>
<li><code><a title="pdoc.render_helpers.root_module_name" href="#pdoc.render_helpers.root_module_name">root_module_name</a></code></li>
<li><code><a title="pdoc.render_helpers.split_identifier" href="#pdoc.render_helpers.split_identifier">split_identifier</a></code></li>
<li><code><a title="pdoc.render_helpers.to_html" href="#pdoc.render_helpers.to_html">to_html</a></code></li>
<li><code><a title="pdoc.render_helpers.to_markdown" href="#pdoc.render_helpers.to_markdown">to_markdown</a></code></li>
<li><code><a title="pdoc.render_helpers.to_markdown_with_context" href="#pdoc.render_helpers.to_markdown_with_context">to_markdown_with_context</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pdoc.render_helpers.DefaultMacroExtension" href="#pdoc.render_helpers.DefaultMacroExtension">DefaultMacroExtension</a></code></h4>
<ul class="">
<li><code><a title="pdoc.render_helpers.DefaultMacroExtension.identifier" href="#pdoc.render_helpers.DefaultMacroExtension.identifier">identifier</a></code></li>
<li><code><a title="pdoc.render_helpers.DefaultMacroExtension.parse" href="#pdoc.render_helpers.DefaultMacroExtension.parse">parse</a></code></li>
<li><code><a title="pdoc.render_helpers.DefaultMacroExtension.tags" href="#pdoc.render_helpers.DefaultMacroExtension.tags">tags</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>